
//#region O
function o_tableDiv_bounds(divParent, o) {
  let html = treee(o);
  let dNew = document.createElement('div');
  dNew.style.float = 'left';
  dNew.innerHTML = html;
  let table = dNew.firstChild;
  divParent.appendChild(dNew);
  return [dNew, table, dNew.offsetWidth, dNew.offsetHeight];
}
function o2yaml(o) { return '<pre>' + jsonToYaml(o) + '</pre>'; }
function o2yamlHtml(el, o) {
  el.innerHTML = '<pre>' + jsonToYaml(o) + '</pre>';
}
function object2string(o, props = [], except_props = []) {
  let s = '';
  if (nundef(o)) return s;
  if (isString(o)) return o;
  let keys = Object.keys(o).sort();
  for (const k of keys) {
    if (!isEmpty(props) && props.includes(k) || !except_props.includes(k)) {
      let val = isList(o[k]) ? o[k].join(',') : isDict(o[k]) ? object2string(o[k].props, except_props) : o[k];
      let key_part = isEmpty(s) ? '' : `, ${k}:`;
      s += val;
    }
  }
  return s;
}
function odict2olist(d, keyName = 'id') {
  let res = [];
  for (const key in d) {
    let o = jsCopy(d[key]);
    o[keyName] = key;
    res.push(o);
  }
  return res;
}
function ohneRegexMix(s, onlylive = false) {
  let arr = onlylive ? CODE.codelist.filter(x => isLiveInBrowser(x.key)) : CODE.codelist;
  let ws = parseSearchString(s);
  let [sno, syes, smay] = [[], [], []];
  for (const w of ws) {
    if (w[0] == '-') sno.push(w.substring(1));
    else if (w[0] == '+') syes.push(w.substring(1));
    else smay.push(w);
  }
  let res = [];
  let opts = lookup(CODE, ['searchOptions', 'case']) == true ? '' : 'i';
  let prop = lookup(CODE, ['searchOptions', 'fulltext']) == true ? 'value' : 'key';
  let prefix = lookup(CODE, ['searchOptions', 'where']); // == true ? 'value' : 'key';
  for (const el of arr) {
    let text = el[prop]; 
    if (sno.some(x => text.includes(x))) continue;
    if (syes.some(x => !text.includes(x))) continue;
    let patt = smay.join('|');
    if (prefix) patt = '\\b' + patt;
    let regex = new RegExp(patt, opts);
    if (regex.test(text)) res.push(el.key);
  }
  CODE.selectedKeys = res; 
  if (!isEmpty(res)) show_sidebar(res, myOnclickCodeInSidebar); 
}
function old_ensure_buttons_visible_ferro() {
  if (isdef(mBy('dbPlayer'))) return;
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  if (fen.players[uplayer].hand.length <= 1) return;
  let d = iDiv(UI.players[uplayer]);
  mStyle(d, { position: 'relative' })
  let dbPlayer = mDiv(d, { position: 'absolute', bottom: 2, left: 100, height: 25 }, 'dbPlayer');
  let styles = { rounding: 6, bg: 'silver', fg: 'black', border: 0, maleft: 10 };
  let bByRank = mButton('by rank', onclick_by_rank_ferro, dbPlayer, styles, 'enabled');
  let bBySuit = mButton('by suit', onclick_by_suit_ferro, dbPlayer, styles, 'enabled');
  if (Z.game == 'ferro') {
    let b = mButton('clear selection', onclick_clear_selection_ferro, dbPlayer, styles, 'enabled', 'bClearSelection');
    if (isEmpty(A.selected)) hide(b);
  }
}
function old_mButtonX(dParent, pos = 'tr', handler = null, defaultBehavior = 'hide', sz = 40) {
  dParent = toElem(dParent);
  let styles = { cursor: 'pointer', w: sz, h: sz };
  let d2 = mDiv(dParent, styles, null, `<svg width='100%' height='100%' ><use xlink:href="#Times" /></svg>`);
  mClass(d2, 'svgbtnX');
  d2.onclick = isdef(handler) ? handler : defaultBehavior == 'hide' ? () => hide(dParent) : () => dParent.remove();
  mPlace(d2, pos, 10);
  return d2;
}
function old_show_settings(dParent) {
  let [options, fen, uplayer] = [Z.options, Z.fen, Z.uplayer];
  clearElement(dParent);
  mFlex(dParent);
  let playermode = get_playmode(uplayer);
  let game_mode = Z.mode;
  let dplaymode = mDiv(dParent, { fg: 'blue' }, null, playermode);
  let dgamemode = mDiv(dParent, { fg: 'red' }, null, Z.mode);
  let d = miPic('gear', dParent, { fz: 20, padding: 6, h: 40, box: true, matop: 2, rounding: '50%', cursor: 'pointer' });
  options.playermode = playermode;
  d.onmouseenter = () => show_options_popup(options);
  d.onmouseleave = hide_options_popup;
}
function old_stage_moves() {
  for (const a of arguments) {
    let [uname, x, cardname] = a.split('.');
    DA.chain.push(() => {
      let g = Session;
      let state = { selected: {} };
      state.selected[uname] = [a];
      let o = { uname: uname, tid: g.table.id, state: state, player_status: 'joined' };
      to_server(o, 'turn_send_move');
    })
  }
}
function on_poll_bot_send_move(obj) {
  console.log('game is over for AI', DA.poll.data.uname);
  clearTimeout(BotTicker);
  delete DA.poll;
}
function on_poll_table_seen(obj) {
  delete DA.poll;
  update_session(obj);
  if (is_game_host()) {
    let txt = jsyaml.dump(DB);
    DA.next = get_games;
    let fen = get_score_fen_from_cur_players();
    to_server({ tid: Session.cur_tid, fen: fen, uname: Session.cur_user, db: txt }, 'save_and_delete');
  } else {
    show_user_intro_screen(true);
  }
}
function on_poll_table_show(obj) {
  delete DA.poll;
  status_message_off();
  present_table(obj);
}
function on_poll_table_started(obj) {
  let t = obj.tables[0];
  update_db_user_from_pl_options(t.pl_options, t.game);
  Session.cur_tid = t.id;
  Session.cur_game = t.game;
  delete DA.poll;
  status_message_off();
  hide('divTest');
  close_sidebar();
  mBy('user_info_mini').style.display = 'flex';
  Session.scoring_complete = false;
  get_play();
}
function on_ticker_status(obj) {
  console.log('status:', TCount);
  if (in_game_open_prompt()) {
    update_session(obj);
    update_game_status(Session.cur_players);
    TOTicker = setTimeout(send_timer_ticker, 3000);
  }
}
function onAvailableGames(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
}
function onAvailablePlayers(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  S.availablePlayers = d;
  console.log('availablePlayers', S.availablePlayers);
  S.playersTaken = {};
  let i = 0;
  for (const plid of S.gameInfo.player_names) {
    console.log(plid)
    if (S.availablePlayers.includes(plid)) {
      console.log('it includes', plid);
      break;
    }
    if (isdef(S.plAddedByMe) && plid in S.plAddedByMe) {
      i += 1;
      continue;
    }
    console.log('still here!!!')
    S.playersTaken[plid] = { username: '?', index: i, id: plid };
    pageHeaderAddPlayer('?', plid, inferPlayerColorFromNameOrInit(plid, i));
    i += 1;
  }
  console.log(S.playersTaken);
  if (!empty(S.availablePlayers)) addUserAsFirstAvailablePlayer();
  else restartHost(onHostStarted);
}
function onBeginRequest(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { enterWaitingLoop(); return; }
  d = d.response;
  if (S.settings.useSpec) loadUserSpec([loadUserCode, sendInit]); else sendInit();
}
function onChatReceived(d) { if (!USE_SOCKETIO) return; addChat(d); }
function onChatSubmitted(e) { if (!USE_SOCKETIO) return; e.preventDefault(); socketEmitChat(); }
function onclick_account() { if (!menu_enabled('account')) return; stop_game(); get_account(); }
function onclick_ack() {
  if (nundef(Z) || nundef(Z.func.clear_ack)) return;
  Z.func.clear_ack();
}
function onclick_add_question() { show_question_editor(); }
function onclick_animate() { interval_id = setInterval(onclick_layer, 500); }
function onClick_belinda() { window.location = '../belinda/index.php'; }
function onclick_bigredloginbutton() { boalogin_start(); }
function onclick_bill() {
  let dParent = mBy('dBoaMain');
  if (dParent.children.length > 1) dParent.lastChild.remove();
  let acclist = get_fake_boa_data_list().filter(x => isdef(x['Last Payment']));
  let boacc = rChoose(acclist);
  let item = generate_statement(dParent, boacc, boacc.brand);
  DA.bill = item;
  lookupAddIfToList(DA, ['challengedata'], item);
}
function onclick_boa_cancel() { onclick_location('home'); }
function onclick_boa_sendcode() {
  let list1 = get_checked_radios(mBy('dPhoneContact'));
  let list2 = get_checked_radios(mBy('dTextOrPhone'))
  console.log(list1, list2);
  let success_phone = list1.length == 1 && list1[0] == 'text_3';
  let success_textOrPhone = list2.length == 1 && list2[0] == 'text_1';
  let TESTSKIP = false;
  console.log('TESTSKIP', TESTSKIP);
  if (!TESTSKIP) {
    if (!success_phone) { alert("Please select the phone number ending in '0297'!"); return; }
    if (!success_textOrPhone) { alert("Please select the option 'Text message'!"); return; }
  }
  boahavecode_start();
}
function onclick_boa_submit_code() {
  let list1 = get_input_value('inpAuthocode');
  let success_code = list1 == S.boa_authorization_code;
  if (!success_code) {
    show_eval_message(false);
    return;
  }
  boamain_start();
}
function onClick_books() { closeLeftPane(); }
function onclick_bw_symbol(app, key) {
  if (nundef(key)) key = S.current_label;
  let s = lookup(DIBOA, ['bw_info', app, key]);
  if (s && isdef(S.current_input)) {
    S.current_input.value = s;
  } else {
    console.log('no bw_info for', app, key);
  }
}
function onclick_by_rank() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer).map(x => x.o);
  let h = UI.players[uplayer].hand;
  pl.handsorting = 'rank';
  Clientdata.handsorting = pl.handsorting;
  localStorage.setItem('handsorting', Clientdata.handsorting);
  let cardcont = h.cardcontainer;
  let ch = arrChildren(cardcont);
  ch.map(x => x.remove());
  let sorted = sortCardItemsByRank(items, Z.func.rankstr); 
  h.sortedBy = 'rank';
  for (const item of sorted) {
    mAppend(cardcont, iDiv(item));
  }
}
function onclick_by_rank_ferro() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer).map(x => x.o);
  let h = UI.players[uplayer].hand;
  pl.handsorting = { n: items.length, by: 'rank' };
  let cardcont = h.cardcontainer;
  let ch = arrChildren(cardcont);
  ch.map(x => x.remove());
  let sorted = sortCardItemsByRank(items, '23456789TJQKA*');
  h.sortedBy = 'rank';
  for (const item of sorted) {
    mAppend(cardcont, iDiv(item));
  }
}
function onclick_by_suit() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer).map(x => x.o);
  let h = UI.players[uplayer].hand;
  Clientdata.handsorting = pl.handsorting = 'suit';
  localStorage.setItem('handsorting', Clientdata.handsorting);
  let cardcont = h.cardcontainer;
  let ch = arrChildren(cardcont);
  ch.map(x => x.remove());
  let sorted = sortCardItemsByRank(items, Z.func.rankstr); 
  sorted = sortCardItemsBySuit(sorted);
  h.sortedBy = 'suit';
  for (const item of sorted) {
    mAppend(cardcont, iDiv(item));
  }
}
function onclick_by_suit_ferro() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer).map(x => x.o);
  let h = UI.players[uplayer].hand;
  pl.handsorting = { n: items.length, by: 'suit' };
  let cardcont = h.cardcontainer;
  let ch = arrChildren(cardcont);
  ch.map(x => x.remove());
  let sorted = sortCardItemsByRank(items, '23456789TJQKA*');
  sorted = sortCardItemsBySuit(sorted);
  h.sortedBy = 'suit';
  for (const item of sorted) {
    mAppend(cardcont, iDiv(item));
  }
}
function onclick_cancelmenu() { hide('dMenu'); }
function onClick_cardgames() { closeLeftPane(); }
function onclick_chat() { if (!menu_enabled('chat')) return; game_interrupt(); get_chat(); }
function onclick_cities() {
  let layer = M.layers.city;
  let capitals = rChoose(M.capitals, 50);
  console.log('capitals', capitals);
  for (const c of M.capitals) {
    console.log('presenting', c)
    map_add_object(M.cities[c], { layer: layer });
  }
}
function onclick_clear_selection_ferro() { clear_selection(); }
function onclick_close_project_editor(ev) {
  console.log('click!!!')
  show_home();
}
function onclick_close_question_editor() {
  console.log('click!!!')
  show_home();
}
function onclick_color(prop) {
  return color => { let styles = {}; styles[prop] = color; mStyle(mBy('dAdmin'), styles); };
}
function onclick_compose() { show_project_editor(); }
function onclick_contacts() { if (!menu_enabled('contacts')) return; game_interrupt(); get_contacts(); }
function onclick_create_game_button() {
  console.assert(is_admin(), 'non admin is creating game!!!!!!!!!!!');
  collect_game_options();
  get_create_table();
}
function onclick_delete_table() { stop_game(); stop_polling(); delete_current_table(); }
function onclick_edit_players() {
  let ta = mBy('ta_edit_players');
  show(ta);
  let button = mBy('b_edit_players');
  button.innerHTML = 'submit';
  button.onclick = onclick_modify_def_players;
  ta.onkeyup = ev => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      ev.cancelBubble = true;
      onclick_modify_def_players(ev);
    }
  };
  ta.focus();
}
async function onclick_file() {
  let res = await route_path_yaml_dict('http://localhost:3000/file?name=test');
  console.log('res', res, typeof (res));
}
function onclick_fork() { add_element(addfork); }
function onclick_game_in_games_menu(ev) {
  Session.cur_game = ev_to_gname(ev);
  set_cur_tid_for_game();
  if (nundef(Session.cur_tid) && is_admin()) { present_game_options(Session.cur_game); }
  else if (isdef(Session.cur_tid)) get_play();
}
function onclick_game_in_gametable(tablename) {
  if (DA.simple) { show_table_simple(tablename); return; }
  stopgame();
  let table = firstCond(Serverdata.tables, x => x.friendly == tablename);
  ensure_polling();
  phpPost({ friendly: tablename }, 'table');
}
function onclick_game_menu_item(ev) {
  let gamename = ev_to_gname(ev);
  stop_game();
  show_game_options_menu(gamename);
}
function onclick_gameover_new() {
  if (is_admin()) {
    let txt = jsyaml.dump(DB);
    DA.chain = [get_games];
    let end_scoring = get_scores_from_cur_players();
    to_server({ tid: Session.cur_tid, end_scoring: end_scoring, uname: Session.cur_user, db: txt }, 'save_and_delete');
  } else {
    present_non_admin_user(Session.cur_user);
  }
}
function onclick_gameover_screen() {
  let game = Session.cur_game;
  let winners = Session.winners;
  if (!Session.scoring_complete) {
    console.log('scoring...')
    decrease_handicap_if_winstreak(winners, game);
    increase_handicap_if_losestreak();
    Session.scoring_complete = true;
  }
  if (is_admin()) {
    let txt = jsyaml.dump(DB);
    DA.next = get_games;
    let fen = get_score_fen_from_cur_players();
    to_server({ tid: Session.cur_tid, fen: fen, uname: Session.cur_user, db: txt }, 'save_and_delete');
  } else {
    get_got_user_in_intro_screen();
    let t = Session.cur_table;
    let fen = t.status == 'past' ? t.fen : get_score_fen_from_cur_players();
    intro_create_score_table(fen, t.friendly);
  }
}
function onclick_games() { if (!menu_enabled('games')) return; stop_game(); get_games(); }
function onclick_header(ev) { if (!is_admin() && ev.path[0].id != 'header') return; open_sidebar(); close_mini_user_info(); }
function onclick_home() { window.location = SERVER; }
function onclick_inno_ut0() { onclick_ut(inno_ut0_create_staged); }
function onclick_inno_ut1() { onclick_ut(inno_ut1_create_staged); }
function onclick_inno_ut2() { onclick_ut(inno_ut2_create_staged); }
function onclick_internet() { toogle_internet_status(); }
function onclick_jittering() {
  jittering = !jittering;
  if (!jittering) {
    tree.map(x => x.repair());
    leaves.map(x => x.current = x.orig.copy());
  }
  show_jittering();
}
function onclick_join_as_player() {
  let [uname, fen, options, uplayer] = [Z.uname, Z.fen, Z.options, Z.uplayer];
  console.log('uname', uname, 'uplayer', uplayer);
  phpPost({ friendly: Z.friendly, uname: uname }, 'join');
}
function onclick_lamp() {
  DA.simple = !DA.simple;
  if (DA.simple) show_simple_ui(); else show_advanced_ui();
  if (isVisible('dTables')) onclick_tables();
}
function onclick_last_test() {
  stop_game();
  stop_polling();
  DA.test.iter = 0;
  DA.test.suiteRunning = false;
  onclick_ut_n('ari', DA.test.number);
}
function onclick_layer() { addlayer(); }
function onclick_leaf() { add_element(addleaf); }
function onclick_left_panel(ev) { if (ev.path[0].id != 'left_panel') return; close_sidebar(); open_mini_user_info(); }
function onclick_list() { show_code_list(DB.code); }
function onclick_location(k) {
  show_correct_location(k);
  if (k == 'boa') {
    console.log('boa_state', S.boa_state);
    if (S.boa_state == 'authorized') { boamain_start(); }
    else if (S.boa_state == 'authorization_pending') boahavecode_start();
    else { S.boa_state = 'start'; boa_start(); }
  } else if (k == 'skype') {
    skype_start();
  } else if (k == 'home') {
    let b = mBy('tbbill'); if (isdef(b)) b.remove();
    scrollToTop();
    S.boa_state = null;
    let dband = mBy('dBandMessage');
    if (isdef(dband)) mStyle(dband, { display: 'none', h: 0, hmin: 0 });
    DA.challenge = DA.name = null;
  }
}
function onclick_log_otree() { log_object(Session.otree, 'otree'); }
function onclick_log_R() { log_object(Session.R, 'R'); }
function onclick_log_R_nodes() { if (isdef(Session.R)) log_object(Session.R.nodes, 'R.nodes'); }
function onclick_log_R_oid2uids() { if (isdef(Session.R)) log_object(Session.R.oid2uids, 'R.oid2uids'); }
function onclick_log_R_path2oid() { if (isdef(Session.R)) log_object(Session.R.path2oid, 'R.path2oid'); }
function onclick_log_R_uid2oids() { if (isdef(Session.R)) log_object(Session.R.uid2oids, 'R.uid2oids'); }
function onclick_log_R_uiNodes() { if (isdef(Session.R)) log_object(Session.R.uiNodes, 'R.uiNodes'); }
function onclick_log_session() { log_object(Session, 'Session'); }
function onclick_login() { if (!menu_enabled('login')) return; stop_game(); get_login(); }
function onclick_login_new() { if (!menu_enabled('login')) return; game_interrupt(); get_login_new(); }
function onclick_logout() {
  mFadeClearShow('dAdminRight', 300);
  mClear('dAdminMiddle');
  stop_game();
  clear_screen();
  U = null;
  show_users();
}
function onclick_menu_item(name) { G_init(name); onclick_playpause(); }
function onclick_modify_def_players(ev) {
  let ta = mBy('ta_edit_players');
  let text = ta.value;
  let words = splitAtAnyOf(text, ', \n');
  let names = [];
  let levels = {};
  for (const w of words) {
    if (w.indexOf('(') < 0) { names.push(w); continue; }
    let name = stringBefore(w, '(');
    let level = firstNumber(w);
    levels[name] = level;
    names.push(name);
  }
  console.log('levels', levels, 'names', names);
  if (!isEmpty(get_keys(levels))) {
    for (const n in levels) {
      lookupSetOverride(DB.users, [n, 'games', Session.cur_game, 'startlevel'], levels[n]);
    }
    db_save();
  }
  let non_existent = names.filter(x => nundef(DB.users[x]));
  if (!isEmpty(non_existent)) {
    status_message('the following players will be discarded because they dont exist: ' + non_existent.join(', '));
    names = arrMinus(names, non_existent);
    if (names.length < 2) {
      let plname = chooseRandom(get_keys(DB.users), x => x != Session.cur_user);
      names.push(plname);
    }
  }
  let final_players = get_def_players_for_user(Session.cur_user, names);
  populate_players(final_players);
}
async function onclick_modify_save() { }
function onclick_new() { show_code_editor(); }
function onclick_pause_continue() {
  let b = mBy('bPauseContinue');
  clearTimeout(TO.ai);
  onclick_stoppolling();
  show_status('game is paused', true);
  mStyle(b, { fg: 'grey' });
}
function onclick_play() {
  if (!menu_enabled('play')) return;
  stop_game();
  let tid = Session.cur_tid;
  if (isdef(tid)) get_play();
  else if (is_admin()) get_games();
  else present_non_admin_user();
}
function onclick_player_in_gametable(uname, tablename, rid) {
  stopgame();
  U = firstCond(Serverdata.users, x => x.name == uname);
  send_or_sim({ friendly: tablename, uname: U.name, }, 'table');
}
function onclick_plus(id, inc) {
  console.log('id', id);
  ensure_clientstate();
  Clientdata.state[id]++;
  console.log('sending Clientdata.state', Clientdata.state);
  let o = { friendly: 'feedback', uname: Clientdata.uid, state: jsCopy(Clientdata.state) };
  phpPost(o, 'update_player');
}
function onclick_plus_minus(color) { socket.emit('plus', color); }
async function onclick_poll() {
  if (Pollmode == 'manual') poll(true);
  else {
    console.log('STOP autopoll first!!!')
  }
}
function onclick_popup(k) {
  let o = DIBOA[k];
  if (nundef(o)) { console.log('missing popup item: ' + k); return; }
  if (k == 'bw') {
    if (!is_bw_loggedin()) {
      assertion(S.bw_state == 'loggedout' || S.bw_state == 'expired', "bw_state is corrupted!!!!", S.bw_state);
      if (S.bw_state == 'loggedout') { bw_login_popup(); } else { bw_set_new_password_popup(); }
    } else {
      bw_widget_popup();
    }
  } else { console.log('onclick_popup', k); }
}
function onclick_preinno_create() { Session.cur_game = 'gPreinno'; get_create_table({ level_setting: 'min' }, ['mimi', 'leo']); }
function onclick_random() {
  if (uiActivated && !DA.ai_is_moving) ai_move(300);
  else if (!uiActivated) console.log('NOP: ui not activated...');
  else if (DA.ai_is_moving) console.log('NOP: ai is (or was already) moving...');
  else console.log('NOP: unknown...');
}
function onclick_reload() {
  if (isdef(Z)) {
    if (Z.game == 'fritz' && nundef(Z.fen.winners)) {
      console.log(Z);
      Z.fen.players[Z.uplayer].time_left = stop_timer();
      take_turn_fen();
    } else {
      FORCE_REDRAW = true; send_or_sim({ friendly: Z.friendly, uname: Z.uplayer, auto: false }, 'table');
    }
  } else if (U) { onclick_tables(); }
  else { show_users(); }
}
function onclick_reload_after_switching() { DA.pollCounter = 0; DA.reloadColor = rColor(); onclick_reload(); }
function onclick_reload_state() {
  let g = Session;
  let tid = g.cur_tid;
  if (nundef(tid) && is_admin()) get_games();
  else if (nundef(tid)) get_intro();
  else if (is_admin()) { stop_game(); get_play(); }
  else {
    stop_game();
    Session.cur_tid = null;
    to_server({ uname: g.cur_user }, 'newest_table');
  }
}
function onclick_remove_host() {
  let [role, host, game, fen, uplayer, turn, stage] = [Z.role, Z.host, Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
}
function onclick_reset_all() { stop_game(); phpPost({ app: 'simple' }, 'delete_tables'); }
function onclick_reset_db() { reset_db_values(); db_save(); }
function onclick_reset_past() { stopgame(); phpPost({ app: 'simple' }, 'delete_past'); }
function onclick_reset_progressbars() {
  DA.winit = 10;
  let oldfen = isdef(Z.fen) ? jsCopy(Z.fen) : { green: 0, red: 0 };
  let fen = { green: DA.winit, red: DA.winit };
  for (const k in DA.bars) {
    set_new_goal(k, DA.winit);
  }
  phpPost({ friendly: 'feedback', fen: fen }, 'reset');
}
function onclick_reset_tables() { stop_game(); stop_polling(); DA.chain = [get_games]; to_server({}, 'reset_tables'); }
function onclick_reset_user() { reset_game_values_for_user(Session.cur_user); db_save(); }
function onclick_restart() {
  let [game, fen, plorder, host] = [Z.game, Z.fen, Z.plorder, Z.host];
  Z.scoring = {};
  if (nundef(fen.original_players)) fen.original_players = fen.players;
  let playernames = [host].concat(get_keys(fen.original_players).filter(x => x != host));
  let playmodes = playernames.map(x => fen.original_players[x].playmode);
  let strategies = playernames.map(x => fen.original_players[x].strategy);
  let default_options = {}; for (const k in Config.games[game].options) default_options[k] = arrLast(Config.games[game].options[k].split(','));
  addKeys(default_options, Z.options);
  fen = Z.fen = Z.func.setup(playernames, Z.options);
  [Z.plorder, Z.stage, Z.turn, Z.round, Z.step, Z.phase] = [fen.plorder, fen.stage, fen.turn, 1, 1, fen.phase];
  if (DA.TESTSTART1) Z.turn = fen.turn = Z.host;
  let i = 0; playernames.map(x => { let pl = fen.players[x]; pl.name = x; pl.strategy = strategies[i]; pl.playmode = playmodes[i++]; });
  take_turn_fen_clear();
}
function onclick_restart_long() {
  let game = Z.game;
  let playernames = [Z.host].concat(Z.plorder.filter(x => x != Z.host));
  let playermodes = playernames.map(x => Z.fen.players[x].playmode);
  let i = 0; let players = playernames.map(x => ({ name: x, playmode: playermodes[i++] }));
  let options = Z.options;
  stopgame();
  startgame(game, players, options);
}
function onclick_restart_move() { clear_transaction(); onclick_reload(); }
function onclick_resume_game_button() {
  console.assert(is_admin(), 'non admin is creating game!!!!!!!!!!!');
  collect_game_options();
  get_modify_table();
}
function onclick_role(role) {
  mFade(mBy('dRoles'), 1000, null, 'linear');
  show_my_role(role);
}
function onclick_run_tests() {
  stop_game();
  stop_polling();
  shield_on();
  DA.test.iter = 0;
  DA.test.suiteRunning = true;
  if (nundef(DA.test.list)) {
    console.log('taking default DA.test.list');
    DA.test.list = [100, 101];
  }
  test_engine_run_next(DA.test.list);
}
async function onclick_save() {
  DB = await route_path_yaml_dict('http://localhost:3000/save');
  console.log('DB', DB);
}
function onclick_set_test() { Session.cur_game = 'gSet'; get_create_table({ level_setting: 'min', winning_score: 1 }, ['mimi', 'leo']); }
function onclick_settings() { if (Session.cur_menu != 'play') { alert('click on a game icon!'); return; } present_game_options(Session.cur_tid); }
function onclick_settings_test() {
  console.log('settings', settings);
  socket.emit('settings', { settings: settings });
}
function onclick_sim_inno_after_init_mimi_turn() {
  delete_current_table();
  Session.cur_game = 'gPreinno';
  test_sim_inno_after_init_mimi_turn();
  get_create_table({ level_setting: 'min' }, ['mimi', 'leo']);
}
function onclick_sim_inno_init_complete() {
  delete_current_table();
  Session.cur_game = 'gPreinno';
  test_sim_inno_init_complete();
  get_create_table({ level_setting: 'min' }, ['mimi', 'leo']);
}
function onclick_skip() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  if (game == 'spotit') return;
  else if (game == 'bluff' && stage == 1 || game == 'ferro' && stage == 'auto_ack') { onclick_ack(); }
  else if (game == 'aristo') {
    Z.uplayer = Z.turn[0];
    Z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null, breadcrumbs: [], sib: [], command: null };
    copyKeys(jsCopy(Z.fen), Z);
    copyKeys(UI, Z);
    activate_ui(Z);
    Z.func.activate_ui();
    ai_move();
  } else {
    let plskip = Z.turn[0];
    Z.turn = [get_next_player(Z, plskip)];
    Z.uplayer = plskip;
    take_turn_fen();
  }
}
function onclick_spotit1() { Session.cur_game = 'gSpotit'; get_create_table({ level_setting: 'min', winning_score: 1 }, ['mimi', 'leo']); }
function onclick_start_spotit() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  Z.stage = 'move';
  Z.turn = jsCopy(Z.plorder);
  take_turn_fen();
}
function onclick_startgame() {
  console.log('starting the game!');
}
function onclick_startpolling() {
  pollStop();
  Pollmode = 'auto';
  poll();
}
function onclick_status() { query_status(); }
function onclick_status_message(ev) {
  evNoBubble(ev); hide('dMessage');
  if (isdef(DA.after_status_message)) {
    let func = DA.after_status_message;
    DA.after_status_message = null;
    func();
  }
}
function onclick_step() {
  DA.test.step = true;
  DA.test.running = true;
  if (!isEmpty(DA.chain)) { dachainext(1000); return; }
  let testnumber = valf(mBy('intestnumber').value, 110);
  if (!isNumber(testnumber)) testnumber = 110;
  console.log('test for step is', testnumber);
  DA.test.number = testnumber;
  onclick_last_test();
}
function onclick_stop_polling() { stop_polling(); }
function onclick_stoppolling() {
  pollStop();
  Pollmode = 'manual';
}
function onclick_submit_boa_login() {
  let userid = get_boa_userid_input().value;
  let pwd = get_boa_pwd_input().value;
  let TESTSUCCESS = false;
  if (TESTSUCCESS || userid == DIBOA.bw_info.boa.userid && pwd == DIBOA.bw_info.boa.pwd) {
    boaverify_start();
  } else {
    console.log('FAIL!!!!!!! onclick_submit_boa_login', userid, pwd);
  }
}
function onclick_table(tablename) {
  send_or_sim({ friendly: tablename, uname: U.name }, 'table');
}
function onclick_tables() { phpPost({ app: 'simple' }, 'tables'); }
async function onclick_test() {
  let res = await route_path_text('http://localhost:3000/test');
  console.log('res', res)
}
function onclick_test_create_anagram_AI() { Session.cur_game = 'gAnagram'; get_create_table({ winning_score: 2 }, ['mimi', 'bob', 'guest', 'leo']); }
function onclick_test_create_maze_AI() { Session.cur_game = 'gMaze'; get_create_table({ winning_score: 2 }, ['mimi', 'bob', 'guest']); }
function onclick_test_create_spotit_AI() { Session.cur_game = 'gSpotit'; get_create_table({ winning_score: 2 }, ['mimi', 'bob']); }
function onclick_test_create1() { get_create_table(); }
function onclick_test_create2_anagram() { Session.cur_game = 'gAnagram'; get_create_table({ level_setting: 'min', winning_score: 1 }); }
function onclick_test_create2_maze() { Session.cur_game = 'gMaze'; get_create_table({ level_setting: 'min', winning_score: 1 }); }
function onclick_tide_all() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    if (isdef(pl.tides)) { continue; }
    pl.tides = { val: rNumber(8, 10) };
  }
  proceed_to_newcards_selection();
}
function onclick_tithe_all() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    if (isdef(pl.tithes)) { continue; }
    pl.tithes = { val: rNumber(8, 10) };
  }
  proceed_to_newcards_selection();
}
function onclick_toggle_games() {
  if (isVisible('dGames')) { toggle_games_off(); }
  else { show_games(); toggle_games_on(); }
}
function onclick_toggle_polling() { toggle_polling_status(); }
function onclick_toggle_sidebar(ev) {
  evNoBubble(ev);
  toggle_sidebar(); toggle_mini_user_info();
}
function onclick_toggle_tables() {
  if (isVisible('dTables')) { toggle_tables_off(); }
  else { phpPost({ app: 'simple' }, 'tables'); toggle_tables_on(); }
}
function onclick_toggle_users() {
  if (isVisible('dUsers')) { toggle_users_off(); }
  else { phpPost({ app: 'simple' }, 'users'); toggle_users_on(); }
}
function onclick_toobar(name) {
  console.log('clicked', name);
  switch (name) {
    case 'clear': mClear(dTable); DA.edits = []; break;
    case 'magic': break;
    case 'lineup':
      mCenterFlex(dTable);
      DA.edits.map(x => mStyle(x, { position: null, display: 'inline' }));
      break;
    case 'orig': DA.edits.map(x => x.style.position = 'absolute'); break;
  }
}
function onclick_user(uname) {
  U = firstCond(Serverdata.users, x => x.name == uname);
  localStorage.setItem('uname', U.name);
  DA.secretuser = U.name;
  let elem = firstCond(arrChildren('dUsers'), x => x.getAttribute('username') == uname);
  let img = elem.children[0];
  mShrinkTranslate(img, .75, 'dAdminRight', 400, show_username);
  mFadeClear('dUsers', 300);
}
function onclick_user_in_intro(ev) {
  let uname = try_find_username(ev);
  if (uname) { present_non_admin_user(uname); }
}
function onclick_user_login(e) {
  e.preventDefault(); e.cancelBubble = true;
  var username = e.target.getAttribute("username");
  if (e.target.id == "") {
    username = e.target.parentNode.getAttribute("username");
  }
  load_user(username);
  get_tables();
}
function onclick_user_login_new(e) {
  e.preventDefault(); e.cancelBubble = true;
  var username = e.target.getAttribute("username");
  if (e.target.id == "") {
    username = e.target.parentNode.getAttribute("username");
  }
  load_user(username);
  get_user_tables();
}
function onclick_userid() {
  let userid = mBy("enterID-input");
  let pwd = mBy('tlpvt-passcode-input');
  console.log('userid', userid.value, 'pwd', pwd.value);
}
function onclick_ut(func) {
  let [fen, player_names] = func();
  get_create_staged(fen, { level_setting: 'min' }, player_names);
}
function onclick_ut_n(g, n) {
  DA.test.running = true;
  let [fen, player_names] = window[`${g}_ut${n}_create_staged`]();
  get_create_staged(fen, { level_setting: 'min' }, player_names);
}
function onclick_view_buildings() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  let buildings = UI.players[uplayer].buildinglist;
  for (const b of buildings) b.items.map(x => face_up(x));
  TO.buildings = setTimeout(hide_buildings, 5000);
}
function onclick_view_ranking() { if (nundef(Session.cur_table)) { console.log('need table!'); return; } out1(); csv = make_csv_for_rankings(); }
function onClick1(ev, mobj, part) {
  console.log(mobj)
  if (mobj.scaleValue == 2) { mobj.setScale(1); delete mobj.scaleValue; }
  else { mobj.setScale(2); mobj.scaleValue = 2; }
}
function onClickActivate() {
  console.log('on click', T)
  ACTIVATE_UI = true;
  testActivate(T);
}
function onClickActivateLayout() { closeAux(); Socket.emit('settings', { settings: G.settings }); }
function onClickAdd() { testAddObject(T); }
function onClickAdd5Random() {
  closeAux();
  Socket.emit('poolChange', { n: 5 });
}
function onClickAddActions() {
  if (M.boats) {
    return;
  }
  timit.showTime('start ' + getFunctionCallerName());
  presentActions();
  activateActions();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickAddBoard() { addBoard(T); }
function onClickAddDefaultObjects() {
  timit.showTime('start ' + getFunctionCallerName());
  for (const oid in G.table) {
    let mobj = makeDefaultObject(oid, G.table[oid], S.settings.table.defaultArea);
    presentDefault(oid, G.table[oid]);
  }
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickAddDefaultPlayers() {
  timit.showTime('start ' + getFunctionCallerName());
  for (const oid in G.players) {
    let mobj = makeDefaultPlayer(oid, G.playersAugmented[oid], S.settings.player.defaultArea);
    presentDefault(oid, G.playersAugmented[oid], false);
  }
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickAddInteraction() { for (const id in UIS) { addTestInteraction(UIS[id]); } }
function onClickAddLocObject() {
  let o = {
    oid: 'loc2ta',
    obj_type: 'robberta',
    name: 'hallo2',
    loc: 'loc3ta'
  };
  let o2 = {
    oid: 'loc1ta',
    obj_type: 'robberta',
    name: 'hallo1',
    loc: 'loc2ta'
  };
  if (isdef(R.getO('loc2ta'))) o = o2;
  R.addObject(o.oid, o); R.addRForObject(o.oid);
  let success = einhaengen(o.oid, o, R);
  recMeasureOverride(R.tree.uid, R)
  updateOutput(R);
}
function onClickAddRobber() { addRobber(T); }
function onClickAddToPool(ev) {
  let button = ev.target;
  if (ActiveButton == button) {
    if (isdef(DA.selectedPerlen) && !isEmpty(DA.selectedPerlen)) {
      let keys = DA.selectedPerlen.map(x => x.key);
      Socket.emit('poolChange', { keys: keys });
      delete DA.selectedPerlen;
    }
    closeAux();
    return;
  }
  openAux('pick perlen', button);
  let d = mDiv(dAuxContent);
  let items = [];
  for (const k in G.perlenDict) {
    let p = jsCopy(G.perlenDict[k]);
    p.path = mPath(p);
    console.log('path', p.path)
    let ui = createPerle(p, d, 64, 1.3, .4);
    mStyleX(ui, { opacity: 1 });
    iAdd(p, { div: ui });
    items.push(p);
  }
  DA.selectedPerlen = [];
  items.map(x => iDiv(x).onclick = ev => { toggleItemSelection(x, DA.selectedPerlen) });
}
function onClickAllTests() {
  setRSG_SOURCE('test');
  isTraceOn = false;
  runAllTests();
}
function onClickAllTestSeries() {
  iTESTSERIES = 0;
  isTraceOn = false;
  onClickResetTest();
  runAllTestSeries();
}
function onClickAreaSizes() {
  if (nundef(bodyZoom)) bodyZoom = 1.0;
  let zoomlevel = calcScreenSizeNeeded();
  let toplevelDiv = document.body.getRootNode();
  let body = document.body;
  let d = document.getElementById('a_d_header'); //'R_d_root');
  console.log('d', getBounds(d), d)
  console.log('width', d.style.offsetWidth);
  console.log('client', window.clientInformation)
  console.log(toplevelDiv, body)
  console.log(getBounds(body))
  console.log('d rect', d.getBoundingClientRect());
  console.log(toplevelDiv.scrollWidth)
  zoom(zoomlevel / 100);
}
function onClickAvailablePlayer(i) {
  let players = S.gameConfig.players;
  let plChosen = firstCond(players, x => x.index == i);
  joinCandidate = plChosen;
}
function onClickBadgeX(ev) {
  interrupt();
  let item = evToItem(ev);
  setBadgeLevel(item.index);
  userUpdate(['games', G.id, 'startLevel'], item.index);
  auxOpen = false;
  TOMain = setTimeout(G.controller.startGame.bind(G.controller), 100);
}
function onClickBoardInChooseBoard(boardFilename) {
  if (boardFilename == G.settings.boardFilename) return;
  G.settings.boardFilename = boardFilename;
  Socket.emit('settings', { settings: G.settings });
}
function onClickCalibrate() {
  if (isCal) {
    if (auxOpen) { closeAux(); }
    exitCalibrationMode();
  } else {
    if (auxOpen) { closeAux(); enterCalibrationMode('all'); }
    else { enterCalibrationMode(1); }
  }
}
function onClickCatan() {
  GAME = S.settings.game = 'catan';
  PLAYMODE = S.settings.playmode = 'hotseat';
  S.gameConfig = gcs[GAME];
  _startNewGame('starter');
}
function onClickCheat(code) { sendRoute('/cheat/' + code, null); }
function onClickChoice(ev) {
  let id = evToClosestId(ev);
  let b = mBy(id);
  let index = Number(stringAfter(id, '_'));
  Goal.choice = Goal.choices[index];
  Goal.buttonClicked = b;
  G.controller.evaluate.bind(G.controller)();
}
function onClickChooseBoard() {
  openAux('click board to select');
  let boards = G.settings.boardFilenames;
  for (const b of boards) {
    let img = mImg(PERLENPATH_FRONT + 'bretter/' + b, dAuxContent, { cursor: 'pointer', h: 200, margin: 8, 'vertical-align': 'baseline' });
    img.onclick = () => { closeAux(); onClickBoardInChooseBoard(b); }
  }
  let img = mDiv(dAuxContent, { cursor: 'pointer', display: 'inline-block', border: 'black', w: 300, h: 200, margin: 8, box: true });
  img.onclick = () => { closeAux(); onClickBoardInChooseBoard('none'); }
}
function onClickChoosePerlen(ev) {
  let button = ev.target;
  if (ActiveButton == button) {
    if (isdef(DA.selectedPerlen) && !isEmpty(DA.selectedPerlen)) {
      let keys = DA.selectedPerlen.map(x => x.key);
      Socket.emit('poolChange', { keys: keys });
      delete DA.selectedPerlen;
    }
    closeAux();
    return;
  }
  openAux('pick perlen', button);
  let d = mDiv(dAuxContent);
  let items = [];
  for (const k in G.perlenDict) {
    let p = jsCopy(G.perlenDict[k]);
    p.path = mPath(p);
    console.log('path', p.path)
    let ui = createPerle(p, d, 64, 1.3, .4);
    mStyle(ui, { opacity: 1 });
    iAdd(p, { div: ui });
    items.push(p);
  }
  DA.selectedPerlen = [];
  items.map(x => iDiv(x).onclick = ev => { toggleItemSelection(x, DA.selectedPerlen) });
}
function onClickClearAllPerlen() {
  closeAux();
  G.clearBoardUI();
  G.clearPoolUI();
  Socket.emit('clearPool');
}
function onClickClearBoard() {
  closeAux();
  let [plist, fields] = G.clearBoardUI();
  console.log('sending remove all perlen command', plist, fields);
  console.log('===> remove list', plist, fields);
  let data = { iPerlen: plist.map(x => x.index), iFroms: fields.map(x => x.index), username: Username };
  logClientSend('removePerlen', data);
  Socket.emit('removePerlen', data);
}
function onClickClearPerlenpool() {
  closeAux();
  G.clearPoolUI();
  Socket.emit('clearPoolarr');
}
async function onClickClearTable() {
  clearElement('table'); clearUpdateOutput(); T = {};
  mBy('table').style.minWidth = 0; mBy('table').style.minHeight = 0;
  resetUIDs();
}
function onclickCodeInSidebar(ev) {
  let key = isString(ev) ? ev : ev.target.innerHTML;
  let text = CODE.justcode[key];
  let ta = AU.ta; let dParent = null;
  if (nundef(ta)) {
    dParent = valf(dFiddle, dTable, document.body);
    let talist = dTable.getElementsByTagName('textarea');
    if (isEmpty(talist)) ta = mTextarea(null, null, dParent, { w: '100%' });
    else ta = talist[0];
  } else dParent = ta.parentNode;
  ta.value = text;
  let hideal = ta.scrollHeight;
  console.log('ta.scrollheight', hideal)
  let hsidebar = window.innerHeight - 68;
  mStyle(dParent, { hmax: hsidebar });
  let lines = text.split('\n');
  let min = lines.length + 1;
  mStyle(ta, { h: hideal, hmin: 50, hmax: hsidebar - 44 });
  ta.scrollTop = 0;
  let download = false;
  if (download) downloadAsText(text, 'hallo', 'js');
  return text;
}
function onClickCollapse() { collapseAll(); }
function onClickComputer() { }
function onClickConnect(port) { initSocket(port); }
function onClickContact(ev) {
  el = evToClass(ev, 'contact');
  DA.currentContact = el.getAttribute('username');
  onClickMenu('chat');
}
function onClickCreateGame() {
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  S.settings.username = USERNAME;
  S.settings.playMode = PLAYMODE;
  S.settings.game = GAME;
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  switch (S.settings.playMode) {
    case 'multiplayer': restartHost(onHostStarted); break;
    case 'hotseat': _startHotseat(); break;
    case 'solo':
    default: break;
  }
}
function onClickCreateGameCancel() {
  currentPlaymode = PLAYMODE;
  currentGamename = GAME;
  closeGameConfig();
}
function onClickCreateGameLobby() {
  openGameConfig();
}
function onClickCreateGameOk() {
  isPlaying = false;
  disableResumeButton();
  GAME = S.settings.game = currentGamename;
  PLAYMODE = S.settings.playmode = currentPlaymode;
  currentSeed = document.getElementById('c_b_mm_seed').value;
  SEED = S.settings.seed = Number(currentSeed);
  joinedPlayers = [];
  let gi = allGames[GAME];
  S.gameInfo = gi;
  let gc = {};
  gc.numPlayers = currentNumPlayers;
  gc.players = [];
  let countNeedToJoin = 0;
  let countMes = 0;
  let iBots = 0;
  for (let i = 0; i < currentNumPlayers; i++) {
    let pl = {};
    pl.index = i + 1;
    pl.id = gi.player_names[i];
    let selType = valueOfElement(getidType(i + 1));
    pl.playerType = startsWith(selType, 'AI') ? 'AI' : selType;
    pl.agentType = pl.playerType == 'AI' ? stringAfter(selType, ' ') : null;
    pl.username = selType == 'me' ? USERNAME + (countMes > 0 ? countMes : '')
      : selType == 'human' ? '' : 'bot' + iBots;
    if (selType == 'me') countMes += 1;
    else if (selType == 'human') countNeedToJoin += 1;
    else iBots += 1;
    gc.players.push(pl);
  }
  S.gameConfig = gc;
  closeGameConfig();
  if (countNeedToJoin > 0) {
    setMessage('new game set up! waiting for ' + countNeedToJoin + ' players to join!');
    socketEmitMessage(JSON.stringify({ type: 'gc', data: gc }));
  } else {
    _startNewGame('starter');
  }
}
function onClickDeactivate() { ACTIVATE_UI = false; testDeactivate(T); }
function onClickDetection() {
  S.settings.userBehaviors = false;
  S.settings.userStructures = false;
  S.settings.userSettings = false;
  S.settings.boardDetection = S_boardDetection = true;
  S.settings.deckDetection = S_deckDetection = true;
  S.settings.openTab = 'ObjectsTab';
  redrawScreen();
}
function onClickDownloadHistory() {
  let keys = Object.keys(HistoryOfStates);
  console.log('history keys', keys);
  for (const k in HistoryOfStates) {
    let pack = HistoryOfStates[k];
    console.log('state', k, 'freeForm', pack.settings.freeForm, 'board', pack.settings.boardFilename)
  }
  downloadAsYaml(HistoryOfStates, `history_` + Date.now());
}
function onClickExpand() { uncollapseAll(); }
function onClickFilter() {
  console.log('clicked filter!')
}
function onClickFilterAndInfobox(ev, mobj, part) { onClickFilterTuples(ev, mobj, part); onClickPlusControlInfobox(ev, mobj, part); }
function onClickFilterOrInfobox(ev, mobj, part) { if (!ev.ctrlKey) onClickFilterTuples(ev, mobj, part); else openInfobox(ev, mobj, part); }
function onClickFilterTuples(ev, mobj, part) {
  let id = mobj.id;
  if (boatFilters.includes(id)) {
    _removeFilterHighlight(mobj);
    removeInPlace(boatFilters, id);
    let relids = getList(id2uids[id]);
    let boats = relids.filter(x => x[2] == 'a');
    if (isEmpty(boats)) { return; }
    for (const bid of boats) { if (!fi.includes(bid)) { _showBoat(bid); } }
  } else {
    let relids = getList(id2uids[id]);
    let boats = relids.filter(x => x[2] == 'a');
    if (isEmpty(boats)) { return }
    if (boats.length == 1) {
      onClickSelectTuple(null, UIS[boats[0]]);
    } else {
      boatFilters.push(id);
      _addFilterHighlight(mobj);
      for (const bid of IdOwner.a) { if (!boats.includes(bid)) { _hideBoat(bid) } }
    }
  }
}
function onClickFloppy() {
  savedb();
}
function onClickFreezer() { console.log('YEP! onClickFreezer!!!!!!!'); hide('freezer'); startUnit(); }
function onClickFreezer2(ev) {
  clearTable(); mRemoveClass(mBy('freezer2'), 'aniSlowlyAppear'); hide('freezer2'); auxOpen = false;
  startUnit();
}
function onClickGamename(inputElem) {
  updateGamename(inputElem.value.toString());
  updatePlayersForGame();
}
function onClickGamesMenu(text) {
  console.log('clicked on menu: ', text);
  console.log('open menu is ', getVisibleChild('dGames'));
  let id = 'd' + capitalize(text);
  if (id == getVisibleChild('dGames')) { console.log('NOPE!'); return; }
  transitionTo(id);
  window['onClick_' + text]();
}
function onClickGear() {
  openAux();
  hide('dGear');
  hide('dCalibrate');
  Settings.createSettingsUi(dAux);
}
function onClickGetUIS(mobj, part) {
  let id = mobj.id;
}
function onClickGo(ev) {
  if (isVisible('dTemple')) {
    closeAux();
    if (G.controllerType == 'solitaire') GC.startGame(); else GC.activateUi();
  } else {
    let item = isdef(ev) ? evToItemC(ev) : null;
    let gKey = nundef(ev) ? SelectedMenuKey : isString(ev) ? ev : item.id;
    if (gKey != SelectedMenuKey) {
      if (isdef(SelectedMenuKey)) toggleItemSelection(Items[SelectedMenuKey]);
      SelectedMenuKey = gKey;
      let item = Items[SelectedMenuKey];
      toggleItemSelection(item);
    } else {
      closeAux();
      setGame(gKey);
      GC.startGame();
    }
  }
}
function onClickInvalidate() { testEngine.invalidate(); }
function onClickIVPicture(ev) {
  ev.cancelBubble = true;
  let pic = findItemFromEvent(Pictures, ev);
  toggleSelectionOfPicture(pic);
}
function onClickJoinGame() {
  if (S.gameInProgress) {
    alert('CANNOT JOIN! game has already started!!! click create game to start a new game or restart to restart current game');
    return;
  }
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  S.settings.username = USERNAME;
  S.settings.playMode = PLAYMODE;
  S.settings.game = GAME;
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  switch (S.settings.playMode) {
    case 'multiplayer': _startMultiplayer(); break;
    case 'hotseat': _startHotseat(); break;
    case 'solo':
    default: break;
  }
}
function onClickJoinGameCancel() {
  closeJoinConfig();
}
function onClickJoinGameLobby() {
  openJoinConfig();
}
function onClickJoinGameOk() {
  isPlaying = false;
  disableResumeButton();
  if (!joinCandidate) {
    setMessage('you did NOT join the game!')
  } else {
    let countMes = 0;
    for (pl of S.gameConfig.players) {
      if (!isEmpty(pl.username) && startsWith(pl.username, USERNAME)) countMes += 1;
    }
    let uname = USERNAME + (countMes > 0 ? countMes : '');
    joinCandidate.username = uname;
    socketEmitMessage(uname + ' joined as ' + joinCandidate.id);
  }
  closeJoinConfig();
  if (checkGameConfigComplete()) {
    disableJoinButton();
  }
}
function onClickListOfObj(b) {
  console.log('clicked', b.textContent);
}
function onClickLoadStateAndSettings() {
  let prefix = prompt('enter name: ');
  if (prefix in HistoryOfStates) {
    let pack = HistoryOfStates[prefix];
    console.log('loaded state', prefix, 'freeForm', pack.settings.freeForm, 'board', pack.settings.boardFilename)
    Socket.emit('state', pack);
  }
}
function onClickLoadStateAndSettings_dep() {
  let prefix = prompt('enter name: ');
  if (!isEmpty(prefix)) recoverStateAndSettings(prefix);
}
function onClickLobby() {
  lobbyView();
  if (!isReallyMultiplayer) openGameConfig();
}
function onClickLogout() { logout(); }
function onClickMeasure() {
  recMeasureOverride(R.tree.uid, R);
  updateOutput(R);
}
function onClickMenu(text) {
  let subMenu = capitalize(text);
  let id = 'd' + subMenu;
  console.log('menu id clicked:', id);
  if (id == getVisibleChild('dInnerLeft')) { console.log('NOPE!'); return; }
  let delay1 = hideCurrent();
  setTimeout(() => {
    let delay2 = text == 'chat' || text == 'tables' ? closeLeftPane() : openLeftPane();
    setTimeout(() => { showCurrent(id); window['onClickMenu' + subMenu](); }, delay2 + 100);
  }, delay1 + 100);
}
function onClickMenuAccount() { show_account(); }
async function onClickMenuChat() {
  chatStartOrActivate();
}
function onClickMenuContacts() { get_data('contacts'); }
function onClickMenuGames() { show_games(); }
function onClickMenuItem(ev) { onClickGo(ev); }
function onClickMenuTables() { }
function onClickModifyLayout(ev) {
  let button = ev.target;
  if (ActiveButton == button) { onClickActivateLayout(); return; }
  openAux('board settings', button);
  let wWidget = 380;
  let [s, b] = [G.settings, G.clientBoard];
  let styles = { w: wWidget, align: 'center', margin: 6 };
  let inpRows = mEditRange('rows: ', s.rows, 1, 20, 1, dAuxContent, (a) => { setApply('rows', a) }, styles);
  let inpCols = mEditRange('cols: ', s.cols, 1, 20, 1, dAuxContent, (a) => { setApply('cols', a) }, styles);
  let inpXOffset = mEditRange('x-offset: ', s.boardMarginLeft, -100, 100, 1, dAuxContent, (a) => { setApply('boardMarginLeft', a) }, styles);
  let inpYOffset = mEditRange('y-offset: ', s.boardMarginTop, -100, 100, 1, dAuxContent, (a) => { setApply('boardMarginTop', a) }, styles);
  let inpRot = mEditRange('rotation: ', s.boardRotation, 0, 90, 1, dAuxContent, (a) => { setApply('boardRotation', a) }, styles);
  mLinebreak(dAuxContent);
  let inpWidth = mEditRange('center dx: ', s.dxCenter, 10, 200, 1, dAuxContent, (a) => { setApply('dxCenter', a) }, styles);
  let inpHeight = mEditRange('center dy: ', s.dyCenter, 10, 200, 1, dAuxContent, (a) => { setApply('dyCenter', a) }, styles);
  let inpFieldSize = mEditRange('field size: ', s.szField, 10, 200, 1, dAuxContent, (a) => { setApply('szField', a) }, styles);
  mLinebreak(dAuxContent);
  let inpSzPerle = mEditRange('perle %: ', s.szPerle, 50, 125, 1, dAuxContent, (a) => { setApply('szPerle', a) }, styles);
  let inpszPoolPerle = mEditRange('pool perle: ', s.szPoolPerle, 40, 140, 1, dAuxContent, (a) => { setApply('szPoolPerle', a) }, styles);
  let inpDimming = mEditRange('dimming %: ', s.dimming, 0, 100, 1, dAuxContent, (a) => { setApply('dimming', a) }, styles);
  mLinebreak(dAuxContent);
  let inpFieldColor = mColorPickerControl('field color: ', s.fieldColor, b.img, dAuxContent, (a) => { setApply('fieldColor', a) }, styles);
  console.log('basecolor', s.baseColor);
  let inpBaseColor = mColorPickerControl('background: ', s.baseColor, b.img, dAuxContent, (a) => { setApply('baseColor', a) }, styles);
  let inpFullCover = mCheckbox('complete rows: ', s.boardLayout == 'hex1' ? false : true, dAuxContent,
    (a) => {
      setApply('boardLayout', a ? 'hex' : 'hex1');
    }, styles);
  let inpfreeForm = mCheckbox('free drop: ', s.freeForm ? true : false, dAuxContent, (a) => { setApply('freeForm', a == 1 ? true : false) }, styles);
}
function onClickMusic() {
  toggleSound('mozart');
  if (isPlaying()) { hide0('bPlay'); show0('bPause'); } else { hide0('bPause'); show0('bPlay'); }
}
function onClickNewColors() {
  iTHEME = (iTHEME + 1) % THEMES.length;
  let color = THEMES[iTHEME];
  document.body.style.backgroundColor = color;
  let fg = colorIdealText(color)
  document.body.style.color = fg;
}
function onClickNextButton() { startRound(); }
function onClickNextExample() { }
function onClickNextGame() { setNextGame(); GC.startGame(); }
function onClickNextPlayerReady() {
  if (WAITINGFORPLAYER !== null) {
    let user = getUsernameForPlayer(WAITINGFORPLAYER);
    WAITINGFORPLAYER = null;
    sendStatus(user, [d => { hide('freezer'); gameStep(d) }]);
  }
}
async function onClickNextTest() {
  setRSG_SOURCE('main');
  await testEngine.loadNextTestCase();
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
}
function onClickNextTestOfSeries() {
  setRSG_SOURCE('test');
  nextTestOfSeries(false);
}
function onClickPaletteButton() {
  alert('FUNCTION DISABLED!')
  return;
  IsCanvasActive = !IsCanvasActive;
  let canvas = mBy('sheet')
  if (IsCanvasActive) {
    canvas.style.userSelect = 'auto';
    console.log(G.clientBoard)
    let r = getRect(G.clientBoard.dOuter); r.left = r.x; r.top = r.y;
    console.log('rectBoard', r);
    mStyleX(canvas, r);
    halloIchZeichneJetzt();
  } else {
    canvas.style.userSelect = 'none';
    canvas.onmousedown = null;
    canvas.onmousemove = null;
    canvas.onmouseup = null;
  }
}
function onClickPass() { }
function onClickPerlenPool(ev) {
  let button = ev.target;
  if (ActiveButton == button) { doPerlenPoolChanges(); return; }
  openAux('perlen pool', button);
  let wWidget = 380;
  let styles = { w: wWidget, align: 'center', margin: 6 };
  let defOptions = { nAdd: 5, nRemove: 5, clearBoard: false, justRandom: true };
  if (nundef(G.perlenOptions)) G.perlenOptions = {};
  let s = G.perlenOptions;
  copyKeys(defOptions, s);
  let dp = mBy('dAuxContent');
  let inpAddRandom = mEditRange('add: ', s.nAdd, 1, 20, 1, dp, (a) => { s.nAdd = a; }, styles);
  let inpRemove = mEditRange('remove: ', s.nRemove, 1, 20, 1, dp, (a) => { s.nRemove = a; }, styles);
  let inpClearBoard = mCheckbox('clear board: ', s.clearBoard, dp, (a) => { s.clearBoard = a; }, styles);
  let inpClearPool = mCheckbox('clear pool: ', s.clearPool, dp, (a) => { s.clearPool = a; }, styles);
  let inpOnlyRandom = mCheckbox('just random: ', s.justRandom, dp, (a) => { s.justRandom = a; }, styles);
}
function onClickPlain() {
  S.settings.userBehaviors = false;
  S.settings.userStructures = false;
  S.settings.userSettings = false;
  S.settings.boardDetection = S_boardDetection = false;
  S.settings.deckDetection = S_deckDetection = false;
  S.settings.openTab = 'ObjectsTab';
  redrawScreen();
}
function onClickPlay() {
  S.settings.username = USERNAME;
  S.settings.playMode = PLAYMODE;
  S.settings.game = GAME;
  console.log(S.settings.username, S.settings.playMode, S.settings.game);
  switch (S.settings.playMode) {
    case 'multiplayer': whichGame(onWhichGame);
      break;
    case 'hotseat': _startHotseat();
      break;
    case 'solo':
    default:
      break;
  }
}
function onClickPlayerPresence(n) {
  isOptional = (n > numPlayersMin) && (n <= numPlayersMax);
  if (!isOptional) return;
  let el = getPlayerRadio(n);
  let isActive = isPlayerChecked(n);
  if (isActive) checkPlayer(n); else uncheckPlayer(n);
  if (isActive) for (let i = numPlayersMin + 1; i < n; i++) { if (!isPlayerChecked(i)) checkPlayer(i); }
  else for (let i = n + 1; i <= numPlayersMax; i++) { if (isPlayerChecked(i)) uncheckPlayer(i); }
  let cnt = 0;
  for (let i = 1; i <= numPlayersMax; i++) { if (isPlayerChecked(i)) cnt += 1; }
  currentNumPlayers = cnt;
}
function onClickPlaymode(mode) {
  updatePlaymode(mode);
  updatePlayersForMode();
}
function onClickPlusControlInfobox(ev, mobj, part) { if (ev.ctrlKey) { openInfobox(ev, mobj, part); } }
function onClickPollStatus() {
  sendStatus(USERNAME, [gameStep]);
}
function onClickPrefabGallery() {
  openAux('choose board + layout');
  let standards = DB.standardSettings;
  let boardExamples = {};
  for (const stdName in standards) {
    let std = standards[stdName];
    let d = mDiv(dAuxContent, { margin: 10, cursor: 'pointer' });
    addKeys(G.settings, std);
    let b = applyStandard(d, std, 200, 100);
    boardExamples[stdName] = {
      key: stdName,
      board: b,
      settings: std,
      dParent: d,
    }
    d.onclick = () => {
      DA.lastPrefabName = stdName;
      copyKeys(std, G.settings);
      Socket.emit('settings', { settings: G.settings });
      closeAux();
    }
  }
}
async function onClickPrevTest() {
  setRSG_SOURCE('main');
  await testEngine.loadPrevTestCase();
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
}
function onClickPrevTestOfSeries() {
  setRSG_SOURCE('test');
  iTEST -= 2; if (iTEST < 0) iTEST = 0;
  nextTestOfSeries();
}
function onClickPushScenario(cheatCode, actionCode) {
  scenarioQ.push(() => sendRoute('/cheat/' + cheatCode, () => onClickRunToAction(actionCode)));
  scenarioQ.push(() => onClickSelectTuple(null, strategicBoat([actionCode])));
  if (!scenarioRunning) { scenarioRunning = true; onClickStep(); }
}
function onClickRecovery() { recoverStateAndSettings(); }
function onClickRecpoint() { saveStateAndSettings(); }
async function onClickReloadAll() {
  vidCache.invalidate('testCards', 'allGames', 'userSpec', 'serverData', 'userCode');
  _startSession();
}
async function onClickReloadSpec() {
  await loadSpecAndCode();
  presentSpecAndCode();
  redrawScreen();
}
function onClickRemoteConnection() {
  if (isdef(DA.remoteSocket)) DA.remoteSocket.disconnect();
  let socket = DA.remoteSocket = io('https://simplesimpleserver.herokuapp.com');
  socket.on('fromServer', x => console.log('msg from remote:', x.msg));
  socket.on('ping', x => console.log('got pinged from remote!'));
  socket.emit('ping');
}
function onClickRemove() { testRemoveObject(T); }
function onClickRemove5Random() {
  closeAux();
  Socket.emit('removeRandom', { n: 5 });
}
function onClickRemoveActions() {
  timit.showTime('start ' + getFunctionCallerName());
  deleteActions();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickRemoveBoard() { removeBoard(T); }
function onClickRemoveDefaultObjects() {
  timit.showTime('start ' + getFunctionCallerName());
  deleteDefaultObjects();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickRemoveDefaultPlayers() {
  timit.showTime('start ' + getFunctionCallerName());
  deleteDefaultPlayers();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickRemoveInteraction() {
  timit.showTime('start ' + getFunctionCallerName());
  for (const id in UIS) UIS[id].removeEvents();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickRemoveRobber() { removeRobber(T); }
async function onClickRepeatTest() {
  setRSG_SOURCE('main');
  await testEngine.repeatTestCase();
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
}
function onClickRepeatTestOfSeries() {
  setRSG_SOURCE('test');
  iTEST -= 1; if (iTEST < 0) iTEST = 0;
  nextTestOfSeries(false);
}
function onClickResetAll() {
  Socket.emit('reset');
}
async function onClickResetLocal() {
  _startSession(true);
}
function onClickResetTest() {
  setRSG_SOURCE('test');
  iTEST = 0;
}
function onClickResizeBoard() {
  let nuiBoard = R.uiNodes['_2'];
  nuiBoard.adirty = true;
  lookupSetOverride(nuiBoard, ['resizeInfo', 'fields'], 180);
  recMeasureOverride(R.tree.uid, R);
}
function onClickRestart() {
  unfreezeUI();
  _startRestartSame();
}
function onClickResumeGameLobby() {
  closeGameConfig();
  gameView();
}
function onClickRetrieveColor() {
  let color = localStorage.getItem('background');
  console.log('retrieved baseColor', color);
  G.settings.baseColor = color;
  Socket.emit('settings', { settings: G.settings });
}
function onClickRetrieveLastState() {
  let lastState = G.lastStateman.getLastStateSaved();
  let s = lastState.settings;
  console.log('retrieve baseColor', s.baseColor);
  Socket.emit('initLastState', { lastState: lastState });
  return;
  let elem = createElementFromHTML(`
    <form action="/lastState" method="post" enctype="multipart/form-data">
    <input type="file" name="lastState" placeholder="Select file" />
    <br />
    <button>Upload</button>
    </form>
  `);
  show(dAux);
  clearElement(dAuxContent);
  mAppend(dAuxContent, elem);
}
function onClickRetrieveSettings() {
  let settings = localStorage.getItem('settings');
  if (isdef(settings)) {
    settings = JSON.parse(settings);
    console.log('retrieved settings (baseColor)', settings.baseColor);
    G.settings = settings;
    Socket.emit('settings', { settings: G.settings });
  } else {
    console.log('no settings in localStorage!');
  }
}
function onClickRetrieveSettings_dep() {
  let settings = localStorage.getItem('settings');
  if (isdef(settings)) {
    settings = JSON.parse(settings);
    console.log('retrieved settings (baseColor)', settings.baseColor);
    G.settings = settings;
    Socket.emit('settings', { settings: G.settings });
  } else {
    console.log('no settings in localStorage!');
  }
}
function onClickRetrieveState() {
  let state = localStorage.getItem('state');
  let randomIndices = localStorage.getItem('randomIndices');
  if (isdef(state) && isdef(randomIndices)) {
    state = JSON.parse(state);
    randomIndices = JSON.parse(randomIndices);
    console.log('retrieved state (boardArr)', state.boardArr.filter(x => x !== null));
    Socket.emit('state', { state: state, randomIndices: randomIndices });
  } else {
    console.log('no state/randomIndices in localStorage!');
  }
}
async function onClickRun() {
  setRSG_SOURCE('main');
  let indexFrom = firstNumber(mBy('iTestCaseFrom').value);
  localStorage.setItem('iTestCaseFrom', indexFrom);
  let indexTo = firstNumber(mBy('iTestCaseTo').value);
  localStorage.setItem('iTestCaseTo', indexTo);
  verifySequence(indexFrom, indexTo, false);
}
async function onClickRunAll() {
  setRSG_SOURCE('main');
  STOP = false;
  isTraceOn = false;
  let sel = mBy('selSeries');
  let listSeries = [];
  for (const ch of sel.children) {
    if (ch.value != 'none') listSeries.push(DIR_TESTS + '/' + ch.value);
  }
  let imax = await testEngine.loadSeries(listSeries[0]);
  show('btnStop');
  await runNextSeries(listSeries, listSeries[0], 0, imax);
}
function onClickRunButton(b) { b.innerHTML = 'Stop'; mStyleX(bRunStop, { bg: 'red' }); StepByStepMode = false; startRound(); }
function onClickRunStopButton(b) { if (StepByStepMode) { onClickRunButton(b); } else { onClickStopButton(b); } }
function onClickRunToAction(keyword) {
  S_autoplayFunction = (_G) => {
    for (const mobj of getBoats()) {
      for (const ti of mobj.o.tuple) {
        if (ti.val.toString().includes(keyword)) {
          setAutoplayFunctionForMode();
          return false;
        }
      }
    }
    return true;
  }
  onClickStep(G);
}
function onClickRunToEnd() {
  S_autoplayFunction = () => true;
  onClickStep(G);
}
function onClickRunToNextPhase() {
  let phase = G.phase;
  S_autoplayFunction = (_G) => _G.phase == phase;
  onClickStep(G);
}
function onClickRunToNextPlayer() {
  let pl = G.player;
  S_autoplayFunction = (_G) => _G.player == pl;
  onClickStep(G);
}
function onClickRunToNextTurn() {
  let pl = G.player;
  S_autoplayFunction = (_G) => {
    if (_G.player != pl) {
      S_autoplayFunction = (_G1, _) => _G1.player != pl;
    };
    return true;
  };
  onClickStep(G);
}
function onClickRunToPlayerChange(player) {
  STOP = false;
  showStop();
  execOptions.skipCond = () => H.player == player;
  decider.onClickStep(H);
}
function onClickSave() { testEngine.saveSolution(T); }
function onClickSaveAsPrefab() {
  let prefabName = prompt('enter name: ', DA.lastPrefabName);
  Socket.emit('prefab', { name: prefabName, settings: G.settings });
  closeAux();
}
function onClickSaveColor() {
  localStorage.setItem('background', G.settings.baseColor);
  console.log('saved baseColor', G.settings.baseColor);
}
function onClickSaveLastState() {
  let lastStateSaved = G.lastStateman.save(G, true);
  let s = lastStateSaved.settings;
  console.log('save baseColor', s.baseColor);
}
function onClickSaveSettings() {
  localStorage.setItem('settings', JSON.stringify(G.settings));
  console.log('saved settings (baseColor)', G.settings.baseColor);
}
function onClickSaveState() {
  let st = G.state;
  let state = { boardArr: st.boardArr, poolArr: st.poolArr, pool: {} };
  for (const k in st.pool) {
    let oNew = state.pool[k] = {};
    copyKeys(st.pool[k], oNew, {}, ['index', 'key']);
  }
  localStorage.setItem('state', JSON.stringify(state));
  localStorage.setItem('randomIndices', JSON.stringify(G.randomIndices));
  console.log('saved state (boardArr)', state.boardArr.filter(x => x !== null));
  console.log('saved state (pool)', Object.keys(state.pool));
}
function onClickSaveStateAndSettings() {
  let prefix = prompt('enter name: ');
  addStateToHistory(prefix);
}
function onClickSaveStateAndSettings_dep() {
  let prefix = prompt('enter name: ');
  if (!isEmpty(prefix)) saveStateAndSettings(prefix);
}
function onClickSaveToHistory() {
  console.log('save to history!');
  let l = G.lastStateman.lastState;
  downloadAsYaml(l, 'lastState');
}
function onClickScenario() {
  scenarioQ = [];
  for (let i = 0; i < 1; i++) {
    scenarioQ.push(cheatDevcard);
    scenarioQ.push(selectBuyDeckcard);
  }
  if (!scenarioRunning) { scenarioRunning = true; onClickRunToNextPhase(); }
  console.log('...scenario', scenario)
}
function onClickSelectTuple(ev, mobj, part) {
  if (choiceCompleted) return;
  choiceCompleted = true;
  iTuple = mobj.o.iTuple;
  freezeUI();
  stopAllHighlighting();
  sendAction(mobj.o, [gameStep]);
}
function onClickShield(ev) {
  ev.stopPropagation();
  console.log('wait...?');
  hideShield();
}
function onClickShowSavedColor() {
  let color = localStorage.getItem('background');
  console.log('saved background is', color);
}
function onClickShowSavedSettings() {
  let settings = localStorage.getItem('settings');
  if (isdef(settings)) {
    settings = JSON.parse(settings);
    console.log('saved settings (baseColor)', settings.baseColor);
  } else {
    console.log('no settings in localStorage!');
  }
}
function onClickShowSavedState() {
  let state = localStorage.getItem('state');
  let randomIndices = localStorage.getItem('randomIndices');
  if (isdef(state) && isdef(randomIndices)) {
    state = JSON.parse(state);
    randomIndices = JSON.parse(randomIndices);
    console.log('retrieved state (boardArr)', state.boardArr.filter(x => x !== null));
  } else {
    console.log('no state/randomIndices in localStorage!');
  }
}
function onClickSmallerBoard() {
  let nuiBoard = R.uiNodes['_2'];
  nuiBoard.adirty = true;
  lookupSetOverride(nuiBoard, ['resizeInfo', 'fields'], 32);
  recMeasureOverride(R.tree.uid, R);
}
function onClickSpec() {
  S.settings.userBehaviors = false;
  S.settings.userStructures = true;
  S.settings.userSettings = true;
  S.settings.boardDetection = S_boardDetection = true;
  S.settings.deckDetection = S_deckDetection = true;
  S.settings.openTab = 'SpecTab';
  redrawScreen();
}
function onClickSpecAndCode() {
  S.settings.userBehaviors = true;
  S.settings.userStructures = true;
  S.settings.userSettings = true;
  S.settings.boardDetection = S_boardDetection = true;
  S.settings.deckDetection = S_deckDetection = true;
  S.settings.openTab = 'CodeTab';
  redrawScreen();
}
function onClickStartButton() { startGame(); }
function onClickStartGame() {
  _sendRoute('/begin/1', d6 => {
    timit.showTime('sending status');
    _sendRoute('/status/' + USERNAME, d7 => {
      let data = JSON.parse(d7);
      processData(data);
      specAndDOM([gameStep]);
    });
  });
}
function onClickStep() {
  if (!this.choiceCompleted) {
    let mobj = getNextStartBoat();
    if (nundef(mobj)) mobj = getBoatWith(['demand', 'offer'], false);
    if (nundef(mobj)) mobj = getBoatWith(['buy'], true);
    if (nundef(mobj)) mobj = getBoatWith(['pass'], true);
    if (nundef(mobj)) mobj = getBoatWith(['demand', 'offer'], false);
    if (nundef(mobj)) mobj = getRandomBoat();
    onClickSelectTuple(null, mobj);
  }
}
function onClickSteps() {
  STOP = false;
  showStop();
  let n = document.getElementById('inSteps').value;
  stepCounter = Number(n) + 1;
  console.log('steps:', stepCounter - 1);
  execOptions.skipCond = () => {
    if (stepCounter > 1) stepCounter -= 1;
    return stepCounter > 1;
  };
  decider.onClickStep(H);
}
function onClickStop() {
  setAutoplayFunctionForMode(PLAYMODE);
  unfreezeUI();
}
function onClickStopButton(b) { b.innerHTML = 'Run'; mStyleX(bRunStop, { bg: 'green' }); StepByStepMode = true; }
function onClickSubmitImageChange() { sendHtml('imgPreview', Username); DA.imageChanged = false; }
function onClickSubmitUsernameChange(newUsername) { window.location = "index.php?user=" + newUsername; }
function onClickTemple() {
  openAux();
  hide('dTemple');
  createMenuUi(dAux);
}
function onClickTempleLobby() {
  START_IN_MENU = true;
  initGameScreen();
}
function onclickTest(x) {
  console.log('TEST!', x)
}
function onClickToggle(b, key) {
  let content = b.textContent;
  let isOn = (content[0] == '-');
  if (isOn) {
    window['S_' + key] = false;
    b.textContent = '+' + content.substring(1);
  } else {
    window['S_' + key] = true;
    b.textContent = '-' + content.substring(1);
  }
}
function onClickToggleButton(button, handlerList) {
  let current = button.textContent;
  let idx = -1;
  let i = 0;
  for (const item of handlerList) {
    if (item[0] == current) {
      idx = i; break;
    }
    i += 1;
  }
  if (idx >= 0) {
    let idxNew = (idx + 1) % handlerList.length;
    button.textContent = handlerList[idxNew][0];
    handlerList[idxNew][1]();
  }
}
function onClickToggleInteractivity(desc) {
  let d = mBy('div' + desc);
  if (isVisible(d)) { hideMenu(desc); } else { showMenu(desc); }
}
function onClickToolbarButton() {
  if (isVisible('sidebar')) {
    hide('sidebar');
    mStyleX(dTable, { w: 'calc( 100% - 120 )' });
  } else {
    show('sidebar');
    mStyleX(dTable, { w: '100%' });
  }
}
function onClickTop() {
  mBy('sidebar').scrollTo(0, 0);
  mBy('pageContent').scrollTo(0, 0);
}
function onClickTTT() {
  GAME = S.settings.game = 'ttt';
  PLAYMODE = S.settings.playmode = 'hotseat';
  S.gameConfig = gcs[GAME];
  _startNewGame('starter');
}
function onClickUpdateOutput(elem) {
  switch (elem.id) {
    case 'contSpec': if (LEAVE_SPEC_OPEN) SHOW_SPEC = true; else SHOW_SPEC = !SHOW_SPEC; break;
    case 'contMixinSpec': SHOW_MIXINSPEC = !SHOW_MIXINSPEC; break;
    case 'contLastSpec': SHOW_LASTSPEC = !SHOW_LASTSPEC; break;
    case 'contUiTree': SHOW_UITREE = !SHOW_UITREE; break;
    case 'contRTree': SHOW_RTREE = !SHOW_RTREE; break;
    case 'contOidNodes': SHOW_OIDNODES = !SHOW_OIDNODES; break;
    case 'contDicts': SHOW_DICTIONARIES = !SHOW_DICTIONARIES; break;
    case 'contRefsIds': SHOW_IDS_REFS = !SHOW_IDS_REFS; break;
  }
  updateOutput(R);
}
function onClickUploadBoard(ev) {
  openAux('upload board image');
  let form1 = new FileUploadForm(dAuxContent, 'Upload Board Image', 'bretter',
    filename => {
      if (!filename) console.log('cancel!');
      else console.log('file ' + filename + ' uploaded successfully!');
      closeAux();
    });
}
function onClickUploadPerlen() {
  openAux('upload perlen images');
  let form1 = new FileUploadForm(dAuxContent, 'Upload Perlen Images', 'perlen',
    filename => {
      if (!filename) console.log('cancel!')
      else console.log('file ' + filename + ' uploaded successfully!');
      closeAux();
    });
}
function onClickUseSettings() {
  S.settings.userBehaviors = false;
  S.settings.userStructures = false;
  S.settings.userSettings = true;
  S.settings.boardDetection = S_boardDetection = true;
  S.settings.deckDetection = S_deckDetection = true;
  S.settings.openTab = 'SettingsTab';
  redrawScreen();
}
function onClickVerify() { testEngine.verify(T); }
async function onClickVerifySoFar() { isTraceOn = false; verifySequence(0, testEngine.index, true); }
function onClickWordInput(ev) {
  return;
  if (!canAct()) return;
  ev.cancelBubble = true;
  let id = evToClosestId(ev);
  let iWord = Number(stringAfter(id, '_'));
  let g = Goal.words[iWord];
  if (nundef(g.hasBlanks) || !g.hasBlanks) return;
  deactivateFocusGroup();
  activateFocusGroup(g.iWord);
}
function onDraggingCloneAround(ev) {
  console.log('YES!')
  if (DragElem === null) return;
  console.log('ev', ev);
  let mx = ev.clientX;
  let my = ev.clientY;
  let dx = mx - DragElem.drag_info.offsetX;
  let dy = my - DragElem.drag_info.offsetY;
  mStyle(DragElem, { left: dx, top: dy });
}
function onDragLetter(ev) { console.log('YES!', ev.clientX, ev.clientY); }
function onDragStartOnLetter1(ev) {
  if (!canAct()) return;
  ev.preventDefault();
  let id = evToClosestId(ev);
  let source = mBy(id);
  if (isLetterElement(source)) {
    var clone = DragElem = source.cloneNode(true);
    clone.id = DragElem.id + '_' + clone;
    DragSource = source;
    mAppend(document.body, clone);
    mClass(clone, 'letter')
    mClass(clone, 'dragelem');
    mStyle(clone, { left: ev.clientX - ev.offsetX, top: ev.clientY - ev.offsetY });
    clone.drag_info = { offsetX: ev.offsetX, offsetY: ev.offsetY };
    clone.setAttribute('draggable', true);
    clone.ondrag = onDraggingCloneAround;
    document.body.ondragend = onReleaseLetter;
  }
}
function onDropLetter(ev) {
  let els = allElementsFromPoint(ev.clientX, ev.clientY);
  let inputs = DropZones;
  for (const inp of inputs) {
    if (els.includes(inp)) {
      inp.innerHTML = DragElem.innerHTML;
      if (startsWith(DragElem.id, 'input')) DragSource.innerHTML = '_';
      let w = buildWordFromLetters(inp.parentNode);
      if (!w.includes('_')) GC.evaluate(w, Goal.label.toUpperCase());
    }
  }
  DragElem.remove();
  DragElem = DragSource = null;
  document.body.ondrag = document.body.ondragend = null;
}
function one_value_cell_constraint(board) {
  updated = false
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (board[r][c] == 0) {
        updated = complete_cell(board, r, c) || updated
      }
    }
  }
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (Array.isArray(board[r][c])) {
        let possibilities = board[r][c]
        updated = appears_once_only(board, possibilities, get_row(board, r), r, c) ||
          appears_once_only(board, possibilities, get_column(board, c), r, c) ||
          appears_once_only(board, possibilities, get_square(board, square_coordinates[r][c]), r, c) || updated
      }
    }
  }
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (Array.isArray(board[r][c])) {
        board[r][c] = 0
      }
    }
  }
  return updated
}
function oneCircleCenters(rows, cols, wCell, hCell) {
  let [w, h] = [cols * wCell, rows * hCell];
  let cx = w / 2;
  let cy = h / 2;
  let centers = [{ x: cx, y: cy }];
  let n = 8;
  let radx = cx - wCell / 2;
  let rady = cy - hCell / 2;
  let peri = Math.min(radx, rady) * 2 * Math.PI;
  n = Math.floor(peri / Math.min(wCell, hCell));
  while (n > 4 && n % 4 != 0 && n % 6 != 0) n -= 1;
  centers = getEllipsePoints(radx, rady, n)
  centers = centers.map(pt => ({ x: pt.X + cx, y: pt.Y + cy }));
  return [centers, wCell * cols, hCell * rows];
}
function onEnterPerle(perle) {
  if (IsControlKeyDown) {
    iMagnify(perle);
  }
}
function oneWordKeys(keys) { return keys.filter(x => !x.includes(' ')); }
function onExistingPlayers(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  availablePlayers(onAvailablePlayers);
}
function onExitPerle() { if (IsControlKeyDown) iMagnifyCancel(); }
function onGameChosen(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  whichGame(onGameInfo);
}
function onGameInfo(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  S.gameInfo = d;
  let currentGame = S.gameInfo.name.toLowerCase();
  availablePlayers(onAvailablePlayers);
}
function onHostStarted(d) {
  pageHeaderClearPlayers();
  prelude(getFunctionCallerName(), d);
  if (isError(d)) throw 'CANNOT RESTART HOST!!!!!!!!!';
  d = d.response;
  S.plAddedByMe = {};
  selectGame(onGameChosen);
}
function onkeydownHandler(ev) {
  if (nundef(DA.keydown)) DA.keydown = {}; for (const k in DA.keydown) { DA.keydown[k](ev); }
}
function onkeyupHandler(ev) {
  if (nundef(DA.keyup)) DA.keyup = {};
  for (const k in DA.keyup) {
    DA.keyup[k](ev);
  }
}
function onKeyWordInput(ev) {
  let charEntered = ev.key.toString();
  if (!isAlphaNum(charEntered)) return;
  let ch = charEntered.toUpperCase();
  Selected = { lastLetterEntered: ch };
  let cands = Goal.blankChars;
  if (Goal.iFocus) {
    let word = Goal.words[Goal.iFocus];
    if (word.hasBlanks) cands = word.charInputs.filter(x => x.isBlank);
    else deactivateFocusGroup();
  }
  console.assert(!isEmpty(cands));
  let isLastOfGroup = (Goal.iFocus != null) && cands.length == 1;
  let isVeryLast = Goal.blankChars.length == 1;
  let target = firstCond(cands, x => x.letter == ch);
  let isMatch = target != null;
  if (!isMatch) target = cands[0];
  fillCharInput(target, ch);
  return { target: target, isMatch: isMatch, isLastOfGroup: isLastOfGroup, isVeryLast: isVeryLast, ch: ch };
}
function onLoginSubmitted(e) {
  e.preventDefault();
  let name = getInputValue('login');
  if (isEmpty(name)) name = chooseRandom(names);
  login(name);
}
function onMessageReceived(d) { if (!USE_SOCKETIO) return; processMessage(d); }
function onMouseDownOnLetter(ev) {
  if (!canAct()) return;
  ev.preventDefault();
  let id = evToClosestId(ev);
  let source = mBy(id);
  if (isLetterElement(source)) {
    var clone = DragElem = source.cloneNode(true);
    clone.id = DragElem.id + '_' + clone;
    DragSource = source;
    mAppend(document.body, clone);
    mClass(clone, 'letter')
    mClass(clone, 'dragelem');
    mStyleX(clone, { left: ev.clientX - ev.offsetX, top: ev.clientY - ev.offsetY });
    clone.drag = { offsetX: ev.offsetX, offsetY: ev.offsetY };
    document.body.onmousemove = onMovingCloneAround;
    document.body.onmouseup = onReleaseLetter;
  }
}
function onMovingCloneAround(ev) {
  if (DragElem === null) return;
  let mx = ev.clientX;
  let my = ev.clientY;
  let dx = mx - DragElem.drag.offsetX;
  let dy = my - DragElem.drag.offsetY;
  mStyle(DragElem, { left: dx, top: dy });
}
function onpagedeactivated(handler) {
  document.addEventListener('visibilitychange',
    () => {
      console.log('visibilityState', document.visibilityState);
      if (document.visibilityState !== 'visible') handler();
    });
}
function onPlayerAdded(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  let nap = S.availablePlayers.length - 1;
  let nMax = S.gameInfo.player_names.length;
  let nMin = arrMin(S.gameInfo.num_players);
  let nRegistered = nMax - nap;
  let mustBegin = (nap == 0);
  let canBegin = nRegistered >= nMin;
  if (canBegin) tryBegin(onBeginRequest);
  else enterWaitingLoop();
}
function onPlayerChange() {
  if (!G.playerChanged) return;
  let pid = G.player;
  let o = G.playersAugmented[pid];
  let ms = getVisual(pid);
  let msDef = getDefVisual(pid);
  let msHeader = getPageHeaderDivForPlayer(pid);
  msHeader.classList.add('gamePlayer')
  if (G.previousPlayer) {
    let msHeaderPrevious = getPageHeaderDivForPlayer(G.previousPlayer);
    msHeaderPrevious.classList.remove('gamePlayer');
  }
  if (ms) {
  }
  if (msDef) {
    let msParentId = msDef.parentId;
    let msParent = UIS[msParentId];
    var target = msDef.elem;
    target.parentNode.scrollTop = target.offsetTop;
  }
}
function onReleaseClone(ev) {
  let els = allElementsFromPoint(ev.clientX, ev.clientY);
  let source = DDInfo.source;
  let dSource = iDiv(source);
  let dropHandler = DDInfo.dropHandler;
  for (const target of DDInfo.targets) {
    let dTarget = iDiv(target);
    if (els.includes(dTarget)) {
      if (isdef(dropHandler)) {
        let cDrop = { x: ev.clientX, y: ev.clientY };
        let rTarget = getRect(dTarget);
        let cTarget = { x: rTarget.x + rTarget.w / 2, y: rTarget.y + rTarget.h / 2 };
        let [dx, dy] = [cDrop.x - cTarget.x, cDrop.y - cTarget.y];
        let [ddx, ddy] = [DragElem.drag.offsetX, DragElem.drag.offsetY];
        dropHandler(source, target, DragElem.isCopy, DragElem.clearTarget, dx, dy, ev, DragElem);
      }
      break;
    }
  }
  DragElem.remove();
  DragElem = null;
  document.body.onmousemove = document.body.onmouseup = null;
}
function onReleaseLetter(ev) {
  let els = allElementsFromPoint(ev.clientX, ev.clientY);
  let inputs = DropZones;
  for (const inp of inputs) {
    if (els.includes(inp)) {
      inp.innerHTML = DragElem.innerHTML;
      if (startsWith(DragElem.id, 'input')) DragSource.innerHTML = '_';
      let w = buildWordFromLetters(inp.parentNode);
      if (!w.includes('_')) GC.evaluate(w, Goal.label.toUpperCase());
    }
  }
  DragElem.remove();
  DragElem = DragSource = null;
  document.body.onmousemove = document.body.onmouseup = null;
}
function onselect_action(ev, r, action, uname) { let item = get_selected_ui_item(ev); select_action(r, action, uname, item); }
async function onTestSeriesChanged() {
  let series = mBy('selSeries').value;
  if (series == 'none') return;
  series = DIR_TESTS + '/' + series;
  console.log('series', series)
  await testEngine.loadSeries(series);
  onClickClearTable();
  onClickRepeatTest();
}
function onWhichGame(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  S.gameInfo = d;
  let currentGame = S.gameInfo.name.toLowerCase();
  if (currentGame == GAME) existingPlayers(onExistingPlayers);
  else restartHost(onHostStarted);
}
function open_game(uname, game, fen) {
  U = {};
  copyKeys(DB.users[uname], U);
  U.session = {};
  G = new (classByName(capitalize(game) + 'Multi'))(game, DB.games[game]);
  Settings = new SettingsClass(G, dAux);
  if (nundef(U.games[game])) {
    if (G.controllerType == 'solitaire') { U.games[game] = { nTotal: 0, nCorrect: 0, nCorrect1: 0, startlevel: 0 }; }
    else U.games[game] = {};
  }
  if (isdef(G.maxlevel)) G.level = Math.min(getUserStartLevel(game), G.maxlevel);
  if (G.id != 'gAristo') Settings.updateGameValues(U, G);
  showGameTitle();
  return G;
}
function open_game_options(gamename) { present_game_options(gamename); }
function open_game_ui() {
  clear_table_all();
  let hmin = firstNumber(getCssVar('--inner_left_panel_height'));
  mBy("inner_left_panel").innerHTML = `<div style='min-height:${hmin}px'>
  <div id="md" style="display: flex;min-height:${hmin}px">
    <div id="dLeftSide" style="align-self: stretch;min-height:${hmin}px"></div>
    <div id="dRightSide" style='min-height:${hmin}px'>
      <div id="table" class="flexWrap"></div>
    </div>
  </div></div>`;
  initTable();
  badges_off();
}
function open_invisible_input(ev) {
  if (ev.target.id != 'dTable') return;
  let [x, y] = [ev.offsetX, ev.offsetY];
  y = toModulo(y - 10, 20, 0, mStyleGet(dTable, 'h') - 47);
  x = toModulo(x, 50);
  add_edit(x, y);
}
function open_mini_user_info() {
  setTimeout(() => {
    mBy('user_info_mini').style.display = 'flex';
  }, 500);
}
function open_player_editor(ev) {
  console.log('ev', ev)
  let id = evToId(ev);
  console.log('open player editor for player ', id);
  let uname = id.substring(4);
  let game = Session.cur_game;
  console.log('player is', uname);
  let res = prompt(`enter [level lang] for player ${uname}: `);
  console.log('user entered', res);
  if (nundef(res) || isEmpty(res)) return;
  let parts = splitAtAnyOf(res, ' ,');
  let level = 'none', lang = 'none';
  if (parts.length >= 1) { level = set_startlevel(uname, game, Number(parts[0])); }
  if (parts.length >= 2) { lang = set_preferred_lang(uname, parts[1]); }
  console.log('selected language', lang, 'and level', level);
  console.log('should save DB', DB.users[uname]);
  if (isdef(DB.users[uname])) db_save();
  populate_players(Session.game_options.players);
}
function open_prompt() {
  console.assert(!uiActivated, 'open_prompt with uiActivated ON !!!!!!!!!!!!!!!!!!!!!!!!!!');
  let game = Session.cur_game;
  let uname = Session.cur_user;
  let g = Session;
  let next = lookup(DB.games, [game]); if (next) copyKeys(next, g);
  next = lookup(DB.users, [uname, 'games', game]); if (next) copyKeys(next, g);
  let level = g.level = valf(g.startlevel, g.def_startlevel);
  lookupSet(DB.users, [uname, 'games', game, 'startlevel'], level);
  next = lookup(DB.games, [game, 'levels']);
  if (next) copyKeys(next[level], g);
  g.maxlevel = valf(get_keys(next).length, 0) - 1;
  g.color = getColorDictColor(g.color);
  for (const k in g.options) {
    g[k] = get_game_option(g, k); 
    console.log('g.' + k, g[k]);
  }
  delete g.levels;
  clearTable(); set_background_color(g.color);
  QContextCounter += 1;
  show_game_name(g.friendly);
  show_title(g.table.friendly);
  show_level(g.level, g.maxlevel);
  if (Session.is_badges) setBadgeLevel(g.level);
  g.startTime = get_timestamp();
  mLinebreak(dTable, 15);
  let items = g.items = spotit_deal(g.num_cards, g.rows, g.cols, g.vocab, g.lang, g.min_scale, g.max_scale);
  Selected = null;
  uiActivated = true;
}
function open_sidebar() {
  DA.left_panel = 'open';
  mBy('left_panel').style.flex = 1;
}
function open_table_dep(tid) {
  let t = DB.tables[tid];
  Session.cur_tid = tid;
  makemove();
}
function openAux(title, button) {
  resetActiveButton();
  show(dAux);
  clearElement(dAuxContent);
  dAuxTitle.innerHTML = title;
  if (isdef(button)) setActiveButton(button);
}
function openCity(evt, cityName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName('tabcontent');
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = 'none';
  }
  tablinks = document.getElementsByClassName('tablinks');
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(' active', '');
  }
  document.getElementById(cityName).style.display = 'block';
  evt.currentTarget.className += ' active';
}
function openGameConfig() {
  ensureAllGames([proceedToConfig]);
}
function openInfobox(ev, mobj, part) {
  let oid = getOidForMainId(mobj.id);
  if (!oid) return;
  let id = makeIdInfobox(oid);
  let ibox = UIS[id];
  if (ibox) {
    let elem = ibox.elem;
    if (isVisible(elem)) {
      hide(elem);
    } else {
      show(elem);
    }
  } else {
    let msInfobox = makeInfobox(mobj.id, oid, G.table[oid]);
    let area = UIS['a_d_game'];
    let pos = calcMainVisualPosCenterInGameArea(mobj)
    msInfobox.setPos(pos.x, pos.y);
  }
}
function openInfoboxesForBoatOids(boat) {
  let oids = boat.o.oids;
  let mainIds = oids.map(x => getMainId(x));
  for (const id of mainIds) {
    let ms = UIS[id];
    openInfobox(null, ms);
  }
}
function openJoinConfig() {
  hideEventList();
  showJoinConfig();
  setMessage('Join the game!');
  hide('bJoinGame');
  hide('bCreateGame');
  show('bLobbyJoinOk');
  show('bLobbyJoinCancel');
  show('bResumeGame');
  populateJoinList();
  joinCandidate = null;
}
function openLeftPane() {
  if (paneOpen) return 0;
  let right = mBy('dInnerRight');
  mStyle(right, { flex: 0 });
  paneOpen = true;
  return DELAY_PANE;
}
function openLogin() {
  show(dLogin); hide(dLobby); hide(dGameScreen);
  loginBtn.onclick = e => {
    e.preventDefault();
    if (!usernameInput.value) { return console.log('Must supply a username'); }
    let username = usernameInput.value;
    username = username.toLowerCase();
    localStorage.setItem('username', username);
    establishUsername(username);
  };
  document.body.style.opacity = 1;
}
function openSettings() { show(dSettings); pauseUI(); }
function openSocket() {
  if (!USE_SOCKETIO) return;
  if (socket != null) { socket.open(); return; }
  socket = io.connect(SERVER_URL);
  socket.on('connect', () => { socket.emit('message', 'User ' + clientData.name + ' has connected!'); });
  socket.on('message', onMessageReceived);
  socket.on('chat', onChatReceived);
}
function openTab(button) {
  var i, tabcontent, tablinks;
  let selected = button.textContent + 'Tab';
  tabcontent = document.getElementsByClassName('tabcontent');
  for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = 'none'; }
  tablinks = document.getElementsByClassName('tablinks');
  for (i = 0; i < tablinks.length; i++) { tablinks[i].className = tablinks[i].className.replace(' active', ''); }
  document.getElementById(selected).style.display = 'block';
  button.className += ' active';
}
function openTabTesting(cityName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName('tabcontent');
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = 'none';
  }
  tablinks = document.getElementsByClassName('tablinks');
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(' active', '');
  }
  document.getElementById('a_d_' + cityName).style.display = 'block';
  document.getElementById('c_b_' + cityName).className += ' active';
}
function openToolbar() {
  let d = mBy('dLeiste');
  show(d);
  mStyleX(d, { w: 100 });
  Toolbar = new ToolbarClass(d);
}
function optionsFor(me) {
  Options = {};
  Options.play = { f: () => { playsCard(me, me.hand.topCard(), me.hand, T.trick, true); evaluate(); } };
  setTimeout(Options.play.f, 2000);
}
function orderByLuminance(rgbValues) {
  const calculateLuminance = (p) => {
    return 0.2126 * p.r + 0.7152 * p.g + 0.0722 * p.b;
  };
  return rgbValues.sort((p1, p2) => {
    return calculateLuminance(p2) - calculateLuminance(p1);
  });
}
function orderFromTo(lst, fromOrder, toOrder) {
  let res = [];
  for (let i = 0; i < lst.length; i++) {
    res.push(lst[fromOrder.indexOf(toOrder[i])]);
  }
  testHelpers(res);
  return res;
}
function ordinal_suffix_of(i) {
  var j = i % 10,
    k = i % 100;
  if (j == 1 && k != 11) {
    return i + "st";
  }
  if (j == 2 && k != 12) {
    return i + "nd";
  }
  if (j == 3 && k != 13) {
    return i + "rd";
  }
  return i + "th";
}
function oscillate_between(x, min, max, step) {
  x += step;
  if (x <= min || x >= max) step = -step;
  return [x, step];
}
function oscillator(item) {
  let [astep, a, bstep, b, basefunc] = [item.astep, item.a, item.bstep, item.b, item.basefunc];
  [a, astep] = oscillate_between(a, 0, 5, astep);
  [b, bstep] = oscillate_between(b, 0, 5, bstep);
  [item.astep, item.a, item.bstep, item.b] = [astep, a, bstep, b];
  item.func = x => b * basefunc(a * x);
  return true;
}
function otree2cur_players(otree) {
  Session.cur_players = {};
  for (const uname of otree.plorder) {
    Session.cur_players[uname] = otree[uname];
  }
  return Session.cur_players;
}
function ouparams() {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    console.log(n.uid + ':', n.params);
  }
}
function oupos() {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    console.log(n.uid + ':position', n.params.position, 'size', n.size, 'pos', n.pos);
  }
}
function out1() {
  let game = Session.cur_game;
  let msg = 'stats:score wins total\n';
  for (const x in Session.cur_players) {
    let pl = Session.cur_players[x];
    let info = DB.users[x].games[game];
    msg += `${x}: ${pl.score} ${info.wins} ${info.total}\n`;
  }
  console.log(msg);
}
function output_arr_short(arr) {
  console.log('output_arr_short', getFunctionsNameThatCalledThisFunction());
  console.log('deck top 3', jsCopy(arrTake(arr, 3))); console.log('deck bottom 3', jsCopy(arrTakeLast(arr, 3)));
}
function output_error(msg) { dError.innerHTML = msg; }
function output_loose_and_journeys(fen) {
  for (const j of fen.journeys) { console.log('journey', j.join(', ')); }
  for (const plname in fen.players) { console.log('loosecards', plname, fen.players[plname].loosecards.join(', ')); }
}
function output_scores() {
  let fen = Z.fen;
  for (const plname in fen.players) {
    let pl = fen.players[plname];
  }
}
function outputCombatData(title, data, H) {
  let c = data.temp.combat;
  let sCombat = c == undefined ? 'undef' : c.stage + ', battles: ' + Object.keys(c.battles).toString();
  let sBattle = c == undefined || c.battle == undefined ? 'undef' : c.battle.stage + ', loc: ' + c.battle.tilename;
}
function outputContent(content) {
  if (content.type == 'list') {
    console.log('list of', content.elType, content.content);
  } else {
    console.log('content', content);
  }
}
function outputPlayerUnits(pl, H) {
  let dObjects = dict2list(H.objects, 'id');
  dObjects = dObjects.filter(x => x.obj_type == 'unit');
  let unitsPlayer = dObjects.filter(x => getUnitOwner(x.nationality) == pl);
  sortBy(unitsPlayer, 'tile');
  console.log(pl);
  for (const u of unitsPlayer) {
    console.log(u.type, u.type == 'Fleet' || u.type == 'Tank' ? '\t\t' : '\t', u.cv, '\t', u.tile, u.id);
  }
}
function outputUpdatedScenario(decider, player = false) {
  sc = decider.scenario;
  reqs = '';
  if (decider.decisionMode == 'scenario') {
    for (const pl of ['Axis', 'West', 'USSR']) {
      if (pl in decider.scenario.items) {
        if (player && player != pl) continue;
        reqs += pl + '\n';
        for (const x of decider.scenario.items[pl]) {
          reqs += '  goal=(' + x.goalTile + ',' + x.goalCv + ') ' + x.type + ' ' + x.id;
          if (x.unit) reqs += ' ' + x.unit.tile + ' ' + x.unit.cv;
          reqs += '\n';
        }
      }
      if (pl in decider.scenario.diplItemsTodo) {
        reqs += pl + '\n';
        for (const nat in decider.scenario.diplItemsTodo[pl]) {
          let ist = lookup(decider.scenario.diplItems, [pl, nat]);
          ist = ist ? ist : 0;
          reqs += '  ' + nat + ': ' + decider.scenario.diplItemsTodo[pl][nat] + ' (is ' + ist + ')';
          reqs += '\n';
        }
      }
    }
    if (!empty(decider.scenario.satellites)) {
      reqs += '\nsatellites:\n';
      for (const n in decider.scenario.satellites) {
        reqs += '  ' + n + ': ' + decider.scenario.satellites[n] + '\n';
      }
    }
    reqs += 'done: ' + decider.scenario.done;
    unitTestScenario(reqs);
  }
}
function outype() {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    console.log(n.uid + ':', n.type);
  }
}
function overwriteMerge(destinationArray, sourceArray, options) { return sourceArray }

//#endregion

function pack_table(o) {
  for (const k of ['players', 'fen', 'state', 'player_status', 'options', 'scoring', 'notes', 'turn']) {
    let val = o[k];
    if (isdef(val)) o[k] = JSON.stringify(val);
  }
  return JSON.stringify({ table: o, playerdata: JSON.stringify(o.playerdata) });
}
function packageState() {
  let st = G.state;
  let state = { boardArr: st.boardArr, poolArr: st.poolArr, pool: {} };
  for (const k in st.pool) {
    let oNew = state.pool[k] = {};
    copyKeys(st.pool[k], oNew, {}, ['index', 'key']);
  }
  let pack = { settings: jsCopy(G.settings), state: state, randomIndices: jsCopy(G.randomIndices) };
  return pack;
}
function padSep(sep, n, args) {
  s = '';
  for (var i = 2; i < arguments.length; i++) {
    s += arguments[i].toString().padStart(n, '0') + sep;
  }
  return s.substring(0, s.length - 1);
}
function pageHeaderAddPlayer(username, playerId, color, asMe = false) {
  let divPlayerNames = document.getElementById('a_d_divPlayerNames');
  divPlayerNames.insertAdjacentHTML('beforeend', pageHeaderGetPlayerHtml(username, playerId, color, asMe));
}
function pageHeaderClearAll() {
  pageHeaderClearPlayers();
  pageHeaderClearGame();
}
function pageHeaderClearGame() {
  UIS['a_d_divGamename'].clear();
}
function pageHeaderClearPlayers() {
  UIS['a_d_divPlayerNames'].clear({ innerHTML: '<div style="float:left">Players:&nbsp;</div>' });
}
function pageHeaderGetPlayerHtml(username, playerId, color, asMe) {
  let spl = `<div id='c_c_${username}' class='playerHeader'><div>${username}</div><div style='color:${color}'>${playerId}</div></div>`
  return spl;
}
function pageHeaderInit() { pageHeaderSetGame(); pageHeaderSetPlayers(); }
function pageHeaderSetGame() {
  let divGamename = document.getElementById('a_d_divGamename');
  divGamename.innerHTML = `<div style='float:right;margin:14px'><b>${allGames[GAME].name}</b><br>(${PLAYMODE})</div>`;
}
function pageHeaderSetPlayers() {
  let divPlayerNames = document.getElementById('a_d_divPlayerNames');
  let s = '<div style="float:left">Players:&nbsp;</div>';
  for (const pid in G.playersAugmented) {
    let pl = G.playersAugmented[pid];
    spl = pageHeaderGetPlayerHtml(pl.username, pid, pl.color, pl.isMe);
    s += spl;
  }
  divPlayerNames.innerHTML = s;
}
function pageHeaderUpdatePlayer(plid) {
  let mk;
  for (const pl in playerConfig[GAME].players) {
    mk = getPageHeaderDivForPlayer(pl);
    mk.classList.remove('gamePlayer');
  }
  mk = getPageHeaderDivForPlayer(plid);
  mk.classList.add('gamePlayer');
}
function pageLayout33() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto', display: 'flex', 'flex-flow': 'row wrap' });
  let dLeft = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
  let dRight = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dRight', 'right');
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  return {
    dHeader: dHeader,
    dLeft: dLeft,
    dRight: dRight,
    dMiddle: dMiddle,
    dFooter, dFooter
  }
}
function paint(dParent, r, color = 'random') {
  let d = mDiv(dParent, { position: 'absolute', left: r.x, top: r.y, w: r.w, h: r.h, bg: color });
  return d;
}
function paint_game(state) {
  let [wgreen, wred] = [state.green.pos, state.red.pos];
  dgreen.style.width = wgreen + '%';
  dred.style.width = wred + '%';
}
function paletteFromColor(c, a = 1) {
  if (Array.isArray(c)) return paletteFromRGBArray(c);
  let hsl = standardizeToHsl(c);
  let pal = gen_palette(hsl.h, 1, hsl.s * 100, a);
  return pal;
}
function paletteFromRGBArray(arr) {
  let hsl = rgbToHsl(arr[0], arr[1], arr[2]);
  let hue1 = hsl[0] * 360;
  sat = Math.round(hsl[1] * 100);
  let hsv = rgbToHsv(arr[0], arr[1], arr[2]);
  let hue2 = hsv.h;
  let hue = hue1;
  let result = gen_palette(hue, 1, sat);
  return result;
}
function panel(areaName, oSpec, oid, o) {
  let [num, or, split, bg, fg, id, panels, parent] = getParams(areaName, oSpec, oid);
  if (num > 0) {
    parent.style.display = 'grid';
    clearElement(parent);
    for (let i = 0; i < num; i++) {
      let d = mDiv100(parent);
      d.id = getUID();
      if (panels.length > i) {
        if (oid) dynamicArea(d.id, panels[i], oid, o); else staticArea(d.id, panels[i]);
      }
    }
    if (or == 'rows') {
      console.log('====', split * 100);
      parent.style.gridTemplateColumns = `${split * 100}% 1fr`;
    }
  }
  return parent;
}
function Panel() {
  var self = this;
  this.div = document.getElementById("dTable");
  this.receptors = new Array();
  this.numbers = new Array();
  this.drags = new Array();
  this.dragX = 0;
  this.dragY = 0;
  this.start = function () {
    self.createNumbers(5);
  }
  this.createReceptors = function (num) {
    var w = 100;
    var h = 30;
    for (i = 0; i < num; i++) {
      self.createReceptor("r" + String(i), 64 * i, 120, w, h);
    }
  }
  this.createReceptor = function (id, l, t, w, h) {
    var div = createDroppable(id, "receptorclass", l, t, w, h);
    var receptor = new Receptor(div, self);
    self.receptors.push(receptor);
    self.div.appendChild(div);
    return (receptor);
  }
  this.createNumbers = function (num) {
    var w = 100;
    var offset = 10;
    for (i = 0; i < num; i++) {
      var randomnumber = Math.floor(Math.random() * 11)
      self.createNumber("n" + String(i), randomnumber, (w + offset) * i, 0, w);
    }
  }
  this.createNumber = function (id, n, l, t, w) {
    var div = createDraggable(id, "numberclass", l, t, w, String(n));
    var number = new Number(div, self, n);
    self.numbers.push(number);
    self.div.appendChild(div);
    return (number);
  }
}
function panelLayout(n, R) {
  let params = n.params;
  let num = n.children.length;
  let or = params.orientation ? params.orientation : DEF_ORIENTATION;
  mFlex(n.ui, or);
  let split = params.split ? params.split : DEF_SPLIT;
  if (split == 'min') {
    let b = getBounds(n.ui, true);
    return { w: b.width, h: b.height };
  }
  let reverseSplit = false;
  if (split == 'equal') split = (1 / num);
  else if (isNumber(split)) reverseSplit = true;
  for (let i = 0; i < num; i++) {
    let d = R.uiNodes[n.children[i]].ui;
    mFlexChildSplit(d, split);
    if (reverseSplit) { split = 1 - split; }
  }
  let b = getBounds(n.ui, true);
  return { w: b.width, h: b.height };
}
function param_present_contacts(obj, dParent, onclick_func_name) {
  let others = sync_users(obj.users);
  Session.others = others.map(x => x.name);
  let msgs = valf(obj.msgs, {});
  let mydata = `
  <style>
    @keyframes appear{
      0%{opacity:0;transform: translateY(50px)}
      100%{opacity:1;transform: translateY(0px)}
     }
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div style="text-align: center; animation: appear 1s ease both">
  `;
  let mydata_list = '';
  for (const r of others) {
    row = r;
    let image = get_image_path(row);
    let mydata_element = `
        <div class='contact' style='position:relative;text-align:center;margin-bottom:18px;' username='${row.name}' 
          onclick='${onclick_func_name}(event)'>
          <img src='${image}' draggable='true' ondragstart='drag(event)' class='img_person sz100' style='margin:0;'/>
          <br>${row.name}`;
    if (isdef(msgs[row.username])) {
      mydata_element += `<div style='width:20px;height:20px;border-radius:50%;background-color:orange;color:white;position:absolute;left:0px;top:0px;'>` + msgs[row.username] + "</div>";
    }
    mydata_element += "</div>";
    mydata_list += mydata_element;
  }
  mydata += mydata_list;
  dParent.innerHTML = mydata;
}
function paramsToCss(params) {
  let res = { css: {}, std: {}, typ: {} };
  for (const k in params) {
    if (k == 'font') {
      let f = getFontString(params.font);
      if (f) res.css.font = f;
    }
    let rsgParam = PARAMRSG_T[k];
    if (isdef(rsgParam)) if (rsgParam) res.typ[k] = params[k]; else res.std[k] = params[k];
    else {
      let name = PARAMCSS[k];
      if (isdef(name)) {
        res.css[name] = params[k];
      } else {
        res.css[k] = params[k];
      }
    }
  }
  return res;
}
function parentHasChannelForThisOid(n, oid) {
  let channels = n.channels;
  if (nundef(channels)) return true;
}
function parentHasThisChildAlready(uidParent, oid) {
  let n = R.rNodes[uidParent];
  if (nundef(n.children)) return false;
  let hasThisChild = false;
  for (const chuid of n.children) {
    if (R.rNodes[chuid].oid == oid) { hasThisChild = true; break; }
  }
  return hasThisChild;
}
function parse_fen(fen) {
  let parts = fen.split(':');
  let opt = parts[0];
  let glob = parts.length > 1 ? parts[1] : null;
  let pls = [];
  for (let i = 2; i < parts.length; i++) {
    pls.push(parts[i]);
  }
  return { opt: opt, glob: glob, pls: pls };
}
function parse_table(t) {
  set_start_data_from_fen(t.fen, S.game);
  if (isString(t.options)) t.options = JSON.parse(t.options);
  S.players = t.players.map(x => ({ name: x, color: getColorDictColor(DB.users[x].color), imgPath: `../base/assets/images/${x}.jpg`, score: 0 }));
  S.players_by_name = arr_to_dict_by(S.players, 'name');
  S.game = t.game;
  S.tid = t.id;
  S.table = t;
}
function parse_table_and_players(obj) {
  console.log('parse_table', obj.table);
  parse_table(obj.table);
  for (const pl of S.players) copyKeys(obj.players, pl);
}
function parseCodefile(content, fname, preserveRegionNames = true, info = {}, superdi = {}) {
  let defaultRegions = { cla: 'classes', func: 'funcs' };
  let lines = content.split('\r\n');
  let parsing = false, code, type, key, regionName, regionOrig;
  let firstletters = [], firstWords = [], iline = 0;
  for (const line of lines) {
    let l = line; iline += 1;
    if (!l.includes("'//") && !l.includes("//'") && !l.includes("http")) {
      l = replaceAllFast(line, '://', '://');
      l = replaceAllFast(l, '//#', '@@#');
      l = stringBefore(l, '//');
      l = replaceAllFast(l, '@@#', '//#');
      l = replaceAllFast(l, '://', '://');
    }
    if (isEmptyOrWhiteSpace(l.trim())) continue;
    if (parsing) {
      let l1 = replaceAllSpecialChars(l, '\t', '  ');
      let ch = l1[0];
      if (' }]'.includes(ch)) code += l1 + '\r\n';
      if (ch != ' ') {
        parsing = false;
        if (nundef(regionName)) { regionName = regionOrig = valf(defaultRegions[type], type); }
        let regKey = preserveRegionNames ? regionOrig : `${regionName} (${fname})`;
        let sig;
        if (type == 'cla') {
          sig = `class ${key}{}`;
        } else if (type == 'func') {
          let firstline = stringBefore(code, '\r\n');
          if (firstline.includes(') {')) sig = stringBefore(firstline, ') {') + ')';
          else if (firstline.includes('){')) sig = stringBefore(firstline, '){') + ')';
          else sig = `function ${key}()`;
          sig += '{}';
        } else { sig = `${type} ${key}`; }
        let o = { name: key, code: code, sig: sig, region: regKey, filename: fname, type: type };
        addKeys(info, o);
        type = checkKey(superdi, key, type);
        if (type) lookupSetOverride(superdi, [type, key], o);
        addOnelineVars(superdi, o);
        addIf(firstletters, l[0]);
      }
    } else {
      let w = l[0] != '/' ? firstWord(l) : l.substring(0, 3);
      addIf(firstWords, w);
    }
    if (parsing) continue;
    if (startsWith(l, '//#region')) {
      regionOrig = stringAfter(l, 'region').trim();
      regionName = firstWordAfter(l, 'region', true);
    } else if (startsWith(l, 'var')) {
      key = firstWordAfter(l, 'var', true);
      parsing = true;
      code = l + '\r\n';
      type = 'var';
    } else if (startsWith(l, 'const')) {
      key = firstWordAfter(l, 'const', true);
      parsing = true;
      code = l + '\r\n';
      type = 'const';
    } else if (startsWith(l, 'class')) {
      key = firstWordAfter(l, 'class', true);
      parsing = true;
      code = l + '\r\n';
      type = 'cla';
    } else if (startsWith(l, 'async') || startsWith(l, 'function')) {
      key = stringBefore(stringAfter(l, 'function').trim(), '(');
      parsing = true;
      code = l + '\r\n';
      type = 'func';
    }
  }
  return superdi;
}
async function parseCodeFile(f, byKey, ckeys, idx) {
  let chunk = '', kw = null, blocktype = null, region = null;
  let txt = await route_path_text(f);
  let fname = stringAfterLast(f, '/'); fname = stringBefore(fname, '.');
  let lines = txt.split('\n');
  for (const line of lines) {
    let [w, type] = _getLineStart(line);
    if (line.trim() == '`;' && kw) { chunk += line + '\n'; continue; }
    if (type == 'WTF') { continue; }
    else if (type == 'empty') { continue; }
    else if (type == 'in_process') {
      if (line.trim().startsWith('//')) continue; // #region') || line.includes('//#endregion')) continue;
      if (kw) { chunk += line + '\n'; }
    }
    else if (type == 'REGION') { if (w == type) region = stringAfter(line, '//#region ').trim(); }
    else if (type == 'block') {
      if (kw) addCodeBlock(f, byKey, ckeys, kw, chunk, fname, region, blocktype, idx++);
      kw = w == 'async' ? stringAfter(line, 'function ') : stringAfter(line, ' '); kw = firstWord(kw, true);
      let blocktypes = { function: 'func', class: 'cla', async: 'func', var: 'var', const: 'const' };
      blocktype = blocktypes[w];
      chunk = line + '\n';
    } else { console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'); break; }
  }
  if (kw) addCodeBlock(f, byKey, ckeys, kw, chunk, fname, region, blocktype, idx++);
  return idx;
}
function parseCodefile1(content, fname, preserveRegionNames = true, info = {}, superdi = {}) {
  let lines = content.split('\r\n');
  let parsing = false;
  let code, type, key, star, sig;
  let multicomment = false;
  let iline = 0;
  for (const line of lines) {
    iline++;
    let l = removeCommentsFromLine(line); if (isEmptyOrWhiteSpace(l.trim())) continue;
    if (l.trim().startsWith('/*')) multicomment = true;
    if (multicomment) {
      if (l.trim().endsWith('*/')) multicomment = false;
      continue;
    }
    if (parsing) {
      let l1 = replaceAllSpecialChars(l, '\t', '  ');
      let ch = l1[0];
      if (' }]'.includes(ch)) code += l1 + '\r\n';
      if (ch != ' ') {
        parsing = false;
        let o = { name: key, code: code, sig: sig, region: type, filename: fname, type: type };
        addKeys(info, o);
        if (o.type == 'var' && o.fname == 'chess.js' && o.name.startsWith('brd_')) { lookupSet(superdi, ['chessvar', o.name], true); }
        if (type == 'var') addOnelineVars(superdi, o);
        lookupSetOverride(superdi, [type, key], o);
      }
    }
    if (startsWith(l, 'async') || startsWith(l, 'function')) {
      key = stringBefore(stringAfter(l, 'function').trim(), '(');
      if (key.startsWith('*')) { star = true; key = stringAfter(key, '*').trim(); } else star = false;
      parsing = true;
      code = l + '\r\n';
      type = 'func';
      sig = getFunctionSignature(l, key);
    } else if (startsWith(l, 'class')) {
      key = firstWordAfter(l, 'class', true);
      parsing = true;
      code = l + '\r\n';
      type = 'cla';
      sig = `class ${key}{}`;
    } else if (startsWith(l, 'const')) {
      key = firstWordAfter(l, 'const', true);
      parsing = true;
      code = l + '\r\n';
      type = 'const';
      sig = `const ${key};`;
    } else if (startsWith(l, 'var')) {
      key = firstWordAfter(l, 'var', true);
      parsing = true;
      code = l + '\r\n';
      type = 'var';
      sig = `var ${key};`;
    }
  }
  return superdi;
}
function parseComplexStyleProperty(str) {
  var regex = /(\w+)\((.+?)\)/g,
    transform = {},
    match;
  while (match = regex.exec(str))
    transform[match[1]] = match[2];
  return transform;
}
function parseDictionaryName(s) {
  if (nundef(s)) return null;
  let o_keys = s.split('.');
  if (isEmpty(o_keys)) return null;
  odict = window[o_keys[0]];
  if (!odict || typeof odict != 'object') return null;
  if (o_keys.length > 1) odict = lookup(odict, o_keys.slice(1));
  return odict;
}
function parseDynamicSpec() {
  let sp = jsCopy(SPEC.dynamicSpec);
  geht(sp);
  dynSpec = sp;
  let pool = POOLS.augData;
  for (const oid in pool) {
    let o = pool[oid];
    let info = INFO[oid];
    if (nundef(info) || nundef(info.loc)) {
      continue;
    }
    let loc = info.loc;
    let areaName = getDynId(info.loc, oid);
    if (!AREAS[areaName]) {
      let uiNode = AREAS[loc];
      let group = info.pool;
      prepParentForChildren(loc, group.length);
      for (const oid of group) {
        addPanel(loc, oid);
      }
    }
  }
  for (const oid in pool) {
    let o = pool[oid];
    let info = INFO[oid];
    if (nundef(info) || nundef(info.loc)) continue;
    let loc = info.loc;
    let areaName = getDynId(info.loc, oid);
    console.log(areaName)
    dynamicArea(areaName, info, oid, o);
    let propName = info.type == 'panel' ? 'panels'
      : info.type == 'list' ? 'elm' : 'data';
    let oEinhaengen = AREAS[areaName];
    if (nundef(oEinhaengen[propName])) oEinhaengen[propName] = [];
    oEinhaengen[propName].push(info);
    console.log(oid, info);
    for (const k in info) {
      let parts = k.split('.');
      let s = parts[0];
      let n = parts.length;
      if (n == 1 && k != 'elm' && k != 'data') continue;
      let leaf = parsePath(parts, info[k], info);
    }
    console.log(info)
    continue;
  }
  return;
  for (const k in sp) {
    let node = sp[k];
    let loc = node.loc;
    if (loc && AREAS[loc]) {
      if (k == 'all_opps') {
        console.log('habe area fuer', k);
      }
      let nParent = AREAS[loc];
      let nChild = node;
      if (nChild.panels) {
        let hybrid = {};
        let num = nChild.pool.length;
        let params = nParent.params;
        params.num = num;
        nParent.panels = nChild.panels;
        hybrid.params = params;
        let panels = nChild.panels;
        if (k == 'opp_info') {
        }
        for (const oid of nChild.pool) {
          let o = pool[oid];
          let otherKeys = o.RSG;
          if (k == 'opp_info') {
          }
          for (const k2 of otherKeys) {
            panel
          }
        }
      }
    }
  }
}
function parseDynamicSpec1() {
  let sp = jsCopy(SPEC.dynamicSpec);
  POOLS.augData = makeDefaultPool(sData);
  annotate(sp);
  dynSpec = sp;
  let pool = POOLS.augData;
  for (const k in sp) {
    let node = sp[k];
    if (node.loc) {
      let group = node.pool;
      if (isEmpty(group)) continue;
      let loc = node.loc;
      let uiNode = AREAS[loc];
      prepParentForChildren(loc, group.length);
      for (const oid of group) {
        addPanel(loc, oid);
      }
    }
  }
  for (const oid in pool) {
    let o = pool[oid];
    if (nundef(o.RSG)) continue;
    let merged = mergeDynSetNodes(o);
    if (oid == 'Player2') {
    }
    if (!merged.type || !PROTO[merged.type]) continue;
    let info = jsCopy(PROTO[merged.type]);
    if (oid == 'Player2') {
    }
    let areaName = getDynId(merged.loc, oid);
    dynamicArea(areaName, info, oid, o);
    let propName = info.type == 'panel' ? 'panels'
      : info.type == 'list' ? 'elm' : 'data';
    let oEinhaengen = AREAS[areaName];
    if (nundef(oEinhaengen[propName])) oEinhaengen[propName] = [];
    oEinhaengen[propName].push(info);
  }
}
function ParseFen(fen) {
  var rank = RANKS.RANK_8;
  var file = FILES.FILE_A;
  var piece = 0;
  var count = 0;
  var i = 0;
  var sq64 = 0;
  var sq120 = 0;
  var fenCnt = 0;
  ResetBoard();
  while ((rank >= RANKS.RANK_1) && fenCnt < fen.length) {
    count = 1;
    switch (fen[fenCnt]) {
      case 'p': piece = PIECES.bP; break;
      case 'r': piece = PIECES.bR; break;
      case 'n': piece = PIECES.bN; break;
      case 'b': piece = PIECES.bB; break;
      case 'k': piece = PIECES.bK; break;
      case 'q': piece = PIECES.bQ; break;
      case 'P': piece = PIECES.wP; break;
      case 'R': piece = PIECES.wR; break;
      case 'N': piece = PIECES.wN; break;
      case 'B': piece = PIECES.wB; break;
      case 'K': piece = PIECES.wK; break;
      case 'Q': piece = PIECES.wQ; break;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
        piece = PIECES.EMPTY;
        count = fen[fenCnt].charCodeAt() - '0'.charCodeAt();
        break;
      case '/':
      case ' ':
        rank--;
        file = FILES.FILE_A;
        fenCnt++;
        continue;
      default:
        printf("FEN error \n");
        return;
    }
    for (i = 0; i < count; i++) {
      sq64 = rank * 8 + file;
      sq120 = SQ120(sq64);
      if (piece != PIECES.EMPTY) {
        brd_pieces[sq120] = piece;
      }
      file++;
    }
    fenCnt++;
  }
  brd_side = (fen[fenCnt] == 'w') ? COLOURS.WHITE : COLOURS.BLACK;
  fenCnt += 2;
  for (i = 0; i < 4; i++) {
    if (fen[fenCnt] == ' ') {
      break;
    }
    switch (fen[fenCnt]) {
      case 'K': brd_castlePerm |= CASTLEBIT.WKCA; break;
      case 'Q': brd_castlePerm |= CASTLEBIT.WQCA; break;
      case 'k': brd_castlePerm |= CASTLEBIT.BKCA; break;
      case 'q': brd_castlePerm |= CASTLEBIT.BQCA; break;
      default: break;
    }
    fenCnt++;
  }
  fenCnt++;
  if (fen[fenCnt] != '-') {
    file = fen[fenCnt].charCodeAt() - 'a'.charCodeAt();
    rank = fen[fenCnt + 1].charCodeAt() - '1'.charCodeAt();
    console.log("fen[fenCnt]:" + fen[fenCnt] + " File:" + file + " Rank:" + rank);
    brd_enPas = FR2SQ(file, rank);
  }
  brd_posKey = GeneratePosKey();
  UpdateListsMaterial();
}
function parseHand(keys, deck) {
  let h1 = keys.map(x => Card52._fromKey(x));
  if (isdef(deck)) h1.map(x => deck.remove(x));
  return h1;
}
function ParseMove(from, to) {
  GenerateMoves();
  var Move = NOMOVE;
  var PromPce = PIECES.EMPTY;
  var found = BOOL.FALSE;
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    Move = brd_moveList[index];
    if (FROMSQ(Move) == from && TOSQ(Move) == to) {
      PromPce = PROMOTED(Move);
      if (PromPce != PIECES.EMPTY) {
        if ((PromPce == PIECES.wQ && brd_side == COLOURS.WHITE) || (PromPce == PIECES.bQ && brd_side == COLOURS.BLACK)) {
          found = BOOL.TRUE;
          break;
        }
        continue;
      }
      found = BOOL.TRUE;
      break;
    }
  }
  if (found != BOOL.FALSE) {
    if (MakeMove(Move) == BOOL.FALSE) {
      return NOMOVE;
    }
    TakeMove();
    return Move;
  }
  return NOMOVE;
}
function parsePath(legs, prop, info) {
  let oInfo = info;
  if (isString(prop)) prop = prop.slice(1);
  if (!isEmpty(legs[0])) {
    let len = legs.length - 1;
    let lastLeg = legs[len];
    let restLegs = legs.slice(0, len);
    for (const leg of restLegs) {
      if (oInfo[leg]) oInfo = oInfo[leg];
      else {
        console.log('cannot parse', leg, oInfo);
      }
    }
    if (!info.settings) info.settings = {};
    let k = legs.join('_');
    info.settings[k] = [oInfo];
    info.settings[k].push(lastLeg);
    if (isString(prop)) info.settings[k].push(getObject(info.oid)[prop]);
  }
}
function parsePropertyPath(odict, s) {
  if (isEmpty(s)) return odict;
  let o_keys = s.split('.');
  return lookup(odict, o_keys);
}
function parseRect(elem) {
  let r = elem.getAttribute('rect');
  console.log('elem.rect', r);
  if (nundef(r)) return getRect(elem);
  r = r.split(' ');
  let rect = { w: Number(r[0]), h: Number(r[1]), t: Number(r[2]), l: Number(r[3]), b: Number(r[4]), r: Number(r[5]) };
  return rect;
}
function parseSearchString(s, sAllow = '+-_') { return toWordsX(s, sAllow); }
function parseStaticSpec() {
  for (const k in SPEC.staticSpec) {
    if (k == 'root') continue;
    let oSpec = jsCopy(SPEC.staticSpec[k]);
    if (oSpec.loc) {
      let loc = oSpec.loc;
      if (!oSpec.id) oSpec.id = k;
      staticArea(loc, oSpec);
      let oEinhaengen = AREAS[loc];
      if (nundef(oEinhaengen.panels)) oEinhaengen.panels = [];
      oEinhaengen.panels.push(oSpec);
    } else {
      PROTO[k] = oSpec;
    }
  }
}
function path2fen(fen, path) { let o = lookup(fen, path.split('.')); return o; }
function path2UI(path) {
  let res = lookup(UI, path.split('.'));
  return res;
}
function pauseloop() { clearInterval(DA.interval); }
function pauseSound() {
  _qSound = [];
  if (_loaded && isdef(_sndPlayer)) {
    clearTimeout(TOSound);
    _sndPlayer.onended = null;
    _sndPlayer.onpause = whenSoundPaused;
    _sndPlayer.pause();
  }
}
function pauseUI() { uiPausedStack.push(uiPaused); uiPaused |= uiHaltedMask; }
function PawnsInit() {
  var index = 0;
  for (index = 0; index < 10; ++index) {
    PawnRanksWhite[index] = RANKS.RANK_8;
    PawnRanksBlack[index] = RANKS.RANK_1;
  }
  pce = PIECES.wP;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    if (RanksBrd[sq] < PawnRanksWhite[FilesBrd[sq] + 1]) {
      PawnRanksWhite[FilesBrd[sq] + 1] = RanksBrd[sq];
    }
  }
  pce = PIECES.bP;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    if (RanksBrd[sq] > PawnRanksBlack[FilesBrd[sq] + 1]) {
      PawnRanksBlack[FilesBrd[sq] + 1] = RanksBrd[sq];
    }
  }
}
function payment_complete() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  A.payment = A.items[A.selected[0]];
  let nextstage = Z.stage = ARI.stage[A.command];
  ari_pre_action();
}
function PCEINDEX(pce, pceNum) { return (pce * 10 + pceNum); }
function percentOf(elem, percentW, percentH) {
  if (nundef(percentH)) percentH = percentW;
  if (nundef(percentW)) percentW = percentH = 100;
  let r = getRect(elem);
  return { w: r.w * percentW / 100, h: r.h * percentH / 100 };
}
function percentVh(percent) { return percent * document.documentElement.clientHeight / 100; }
function percentVhIncludingScrollbar(percent) {
  var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
  return (percent * h) / 100;
}
function percentVMax(percent) { return Math.max(percentVh(percent), percentVw(percent)); }
function percentVMaxIncludingScrollbar(percent) {
  return Math.max(percentVhIncludingScrollbar(percent), percentVwIncludingScrollbar(percent));
}
function percentVMin(percent) { return Math.min(percentVh(percent), percentVw(percent)); }
function percentVMinIncludingScrollbar(percent) {
  return Math.min(percentVhIncludingScrollbar(percent), percentVwIncludingScrollbar(percent));
}
function percentVw(percent) { return percent * document.documentElement.clientWidth / 100; }
function percentVwIncludingScrollbar(percent) {
  var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  return (percent * w) / 100;
}
function perform_search() {
  let words = toWords(mBy('iKeywords').value);
  console.log('keywords are', words);
  let res = [], i = 0;
  for (const c of DB.code) {
    for (const w of words) {
      let w1 = w.toLowerCase();
      let kw = c.kw.toLowerCase();
      let code = c.c.toLowerCase();
      if (kw.includes(w1) || code.includes(w1)) {
        res.push(c);
        c.index = i;
        break;
      }
    }
    i++;
  }
  console.log('filtered:', res);
  show_code_list(res);
}
function Perft(depth) {
  MakeNullMove();
  if (brd_posKey != GeneratePosKey()) {
    console.log(printGameLine());
    PrintBoard();
    srch_stop = BOOL.TRUE;
    console.log('Hash Error After Make');
  }
  TakeNullMove();
  if (brd_posKey != GeneratePosKey()) {
    console.log(printGameLine());
    PrintBoard();
    srch_stop = BOOL.TRUE;
    console.log('Hash Error After Take');
  }
  if (depth == 0) {
    perft_leafNodes++;
    return;
  }
  GenerateMoves();
  var index;
  var move;
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    move = brd_moveList[index];
    if (MakeMove(move) == BOOL.FALSE) {
      continue;
    }
    Perft(depth - 1);
    TakeMove();
  }
  return;
}
function PerftTest(depth) {
  PrintBoard();
  console.log("Starting Test To Depth:" + depth);
  perft_leafNodes = 0;
  GenerateMoves();
  var index;
  var move;
  var moveNum = 0;
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    move = brd_moveList[index];
    if (MakeMove(move) == BOOL.FALSE) {
      continue;
    }
    moveNum++;
    var cumnodes = perft_leafNodes;
    Perft(depth - 1);
    TakeMove();
    var oldnodes = perft_leafNodes - cumnodes;
    console.log("move:" + moveNum + " " + PrMove(move) + " " + oldnodes);
  }
  console.log("Test Complete : " + perft_leafNodes + " leaf nodes visited");
  $("#FenOutput").text("Test Complete : " + perft_leafNodes + " leaf nodes visited");
  return;
}
function PHLayout() {
  if (isdef(UI.DRR)) UI.DRR.remove();
  mAppend(UI.dRechts, UI.dHistory);
  Clientdata.historyLayout = 'ph';
}
function phpPost(data, cmd) {
  if (DA.TEST1 === true && cmd == 'table') { cmd = 'table1'; }
  pollStop();
  var o = {};
  o.data = valf(data, {});
  o.cmd = cmd;
  o = JSON.stringify(o);
  if (DA.SIMSIM && (DA.exclusive || ['table', 'startgame', 'gameover', 'tables'].includes(cmd))) {
    sendSIMSIM(o, DA.exclusive);
    FORCE_REDRAW = true;
    if (DA.exclusive) return;
  } else if (DA.simulate) {
    sendSIMSIM(o, true, true);
    FORCE_REDRAW = true;
    return;
  }
  clear_transaction();
  var xml = new XMLHttpRequest();
  loader_on();
  xml.onload = function () {
    if (xml.readyState == 4 || xml.status == 200) {
      loader_off();
      handle_result(xml.responseText, cmd);
    } else { console.log('WTF?????') }
  }
  xml.open("POST", "api.php", true);
  xml.send(o);
}
function phpPostSimulate(o, cmd) {
  FORCE_REDRAW = true;
  if (nundef(o.options) && isdef(Z)) {
    o.turn = Z.turn;
    o.expected = Z.expected;
    o.options = Z.options;
  }
  switch (cmd) {
    case "gameover":
    case "move":
    case "table":
    case "startgame":
      let t = pack_table(o);
      let t1 = JSON.parse(t);
      handle_result(t, cmd); break;
    default: break;
  }
}
function picDiv(size) { return o => pictoDiv(o.key, o.color, size, size); }
function picInfo(key) {
  if (isdef(symbolDict[key])) return symbolDict[key];
  else {
    ensureSymByHex();
    let info = symByHex[key];
    if (isdef(info)) { return info; }
    else {
      let infolist = picSearch({ keywords: key });
      if (infolist.length == 0) return null;
      else return chooseRandom(infolist);
    }
  }
}
function PickNextMove(moveNum) {
  var index = 0;
  var bestScore = 0;
  var bestNum = moveNum;
  for (index = moveNum; index < brd_moveListStart[brd_ply + 1]; ++index) {
    if (brd_moveScores[index] > bestScore) {
      bestScore = brd_moveScores[index];
      bestNum = index;
    }
  }
  temp = brd_moveList[moveNum];
  brd_moveList[moveNum] = brd_moveList[bestNum];
  brd_moveList[bestNum] = temp;
  temp = brd_moveScores[moveNum];
  brd_moveScores[moveNum] = brd_moveScores[bestNum];
  brd_moveScores[bestNum] = temp;
}
function pickSuitableItems(n, options) {
  let items = genItems(n, options);
  let words = items.map(x => x.label);
  let minlen = arrMinMax(words, x => x.length).min;
  let used = [];
  for (const item of items) {
    let res = minlen > 6 ? getRandomVowel(item.label, used) : minlen > 3 ? getRandomConsonant(item.label, used) : getRandomLetter(item.label, used);
    if (isEmpty(res)) return null;
    let i = item.iLetter = res.i;
    let letter = item.letter = item.label[i];
    used.push(letter);
  }
  return items;
}
function pickSuitableItems_dep(n, options) {
  let items = genItems(n, options);
  let words = items.map(x => x.label);
  let used = [];
  for (const item of items) {
    let res = getRandomConsonant(item.label, used);
    if (isEmpty(res)) return null;
    let i = item.iLetter = res.i;
    let letter = item.letter = item.label[i];
    used.push(letter);
  }
  return items;
}
function picLabelDiv(size) { return o => pictoLabelDiv(o.key, o.label, o.color, size); }
function picRandom(type, keywords, n = 1) {
  let infolist = picSearch({ type: type, keywords: keywords });
  return n == 1 ? chooseRandom(infolist) : choose(infolist, n);
}
function picSearch({ keywords, type, func, set, group, subgroup, props, isAnd, justCompleteWords }) {
  if (isdef(set)) ensureSymBySet();
  if (isdef(type) && type != 'all') ensureSymByType();
  let [dict, list] = isdef(set) ? [symBySet[set], symListBySet[set]]
    : nundef(type) || type == 'all' ? [symbolDict, symbolList] : [symByType[type], symListByType[type]];
  if (set == 'role' && firstCond(dict2list(dict), x => x.id == 'rotate')) console.log('===>', symBySet[set], dict, dict2list(dict));
  if (nundef(keywords)) return isdef(func) ? func(dict) : list;
  if (!isList(keywords)) keywords = [keywords];
  if (isString(props)) props = [props];
  let infolist = [];
  if (isList(props)) {
    if (isAnd) {
      if (justCompleteWords) {
        infolist = allWordsContainedInPropsAsWord(dict, keywords, props);
      } else {
        infolist = allWordsContainedInProps(dict, keywords, props);
      }
    } else {
      if (justCompleteWords) {
        infolist = anyWordContainedInPropsAsWord(dict, keywords, props);
      } else {
        infolist = anyWordContainedInProps(dict, keywords, props);
      }
    }
  } else if (nundef(props) && nundef(func)) {
    if (isAnd) {
      if (justCompleteWords) {
        infolist = allWordsContainedInKeysAsWord(dict, keywords);
      } else {
        infolist = allWordsContainedInKeys(dict, keywords);
      }
    } else {
      if (justCompleteWords) {
        infolist = anyWordContainedInKeysAsWord(dict, keywords);
      } else {
        infolist = anyWordContainedInKeys(dict, keywords);
      }
    }
  } else if (isdef(func)) {
    infolist = func(dict, keywords);
  }
  return infolist;
}
function picSet(setname) {
  ensureSymBySet();
  return chooseRandom(symListBySet[setname]);
}
function picto(key, x, y, w, h, fg, bg) {
  let ch = iconChars[key];
  let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
  let text = String.fromCharCode('0x' + ch);
  let d = document.createElement('div');
  d.style.textAlign = 'center';
  d.style.fontFamily = family;
  d.style.fontWeight = 900;
  d.style.fontSize = h;
  d.style.backgroundColor = bg;
  d.style.color = fg;
  d.innerHTML = text;
  return d;
}
function pictoDiv(key, color, w, h) {
  let d = maPicSimple(key);
  mColor(d, color);
  mSizePic(d, w, h);
  return d;
}
function pictoLabelDiv(key, label, color = 'blue', sz = 50, gap = 2, fz) {
  let dOuter = mCreate('div');
  let wOuter = sz;
  let wInner = sz - 2 * gap;
  mStyle(dOuter, {
    width: wOuter,
    padding: 0,
    display: 'inline',
    position: 'absolute',
    'text-align': 'center',
    'background-color': randomColor(),
  });
  let dPic = pictoDiv(key, color, wInner, wInner);
  mAppend(dOuter, dPic)
  mStyle(dPic, { margin: gap, 'margin-bottom': 1 })
  let dText = mAppendText(dOuter, label);
  dText.classList.add('truncate');
  mStyle(dText, { 'margin-bottom': gap, width: wOuter });
  return dOuter;
}
function PieceIsOnSq(sq, top, left) {
  if ((RanksBrd[sq] == 7 - Math.round(top / 60)) &&
    FilesBrd[sq] == Math.round(left / 60)) {
    return BOOL.TRUE;
  }
  return BOOL.FALSE;
}
function pKeyVal(dParent, k, val) { let d = pPanel(dParent); d.innerHTML = k + ':'; pVal(d, val); return d; }
function placeDeck(deck, cont, x, y) {
  deck.unmount();
  deck.mount(cont);
  deck.translate(x, y);
}
function placement() {
  let plac = SPEC.placement;
}
function placeSymbol(sym, szSym, margin, posStyles) {
  let d = iDiv(sym);
  posStyles.position = 'absolute';
  posStyles.margin = margin;
  posStyles.h = szSym;
  posStyles.w = szSym;
  mStyle(d, posStyles);
}
function player_stat_count(key, n, dParent, styles = {}) {
  let sz = valf(styles.sz, 16);
  addKeys({ display: 'flex', margin: 4, dir: 'column', hmax: 2 * sz, 'align-content': 'start', fz: sz, align: 'center' }, styles);
  let d = mDiv(dParent, styles);
  if (isdef(Syms[key])) mSym(key, d, { h: sz, 'line-height': sz, w: '100%' });
  else mText(key, d, { h: sz, fz: sz, w: '100%' });
  d.innerHTML += `<span style="font-weight:bold">${n}</span>`;
  return d;
}
function playsCard(pl, card, dHand, dTarget, faceUp) {
  pl.cardPlayed = card;
  removeCard(card, dHand);
  addCard(card, dTarget);
  if (faceUp == true) Card52.turnFaceUp(card);
  mRemoveStyle(card.div, ['cursor', 'position']);
}
function playSound(key, wait = true) {
  if (!wait) _qSound = [];
  _enqSound(key);
  if (_idleSound) { _idleSound = false; _deqSound(); }
}
function playsound() { playSound(...arguments); }
function playt() {
  var tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  var player;
  function onYouTubeIframeAPIReady() {
    player = new YT.Player('player', {
      height: '390',
      width: '640',
      videoId: 'Kopr6Q3oGHw',
      playerVars: {
        'playsinline': 1,
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
  }
  function onPlayerReady(event) {
    console.log('player is ready - please click anywhere on page')
    onclick = () => event.target.playVideo();
  }
  var done = false;
  function onPlayerStateChange(event) {
    if (event.data == YT.PlayerState.PLAYING && !done) {
      setTimeout(volume_up, 2000);
      done = true;
    }
  }
}
function plot_cdf(canvas, mean, stdev, xfrom, xto, styles = {}) { }
function plot_derivative(canvas, f, xfrom, xto, styles = {}) { }
function plot_function(canvas, f, xfrom, xto, styles = {}) { }
function plot_integral(canvas, f, xfrom, xto, styles = {}) { }
function plot_line(canvas, item) {
  let cx = canvas.cx;
  cx.font = `${valf(item.fz, 16)}px Arial`;
  cx.fillStyle = item.color;
  if (isdef(item.label)) cx.fillText(`  ${item.label}`, 0, 0);
  cLine(item.x1, item.y1, item.x2, item.y2, { bg: item.color }, 0, cx);
}
function plot_on_canvas(d, items) {
  let r = getRect(dTable);
  let c = mCanvas(d, { w: r.w, h: r.h, rounding: 0, bg: 'white' }); let [cv, cx] = [c.cv, c.cx];
  for (const item of items) {
    let d1 = item.div = cRect(item.x, item.y, item.w, item.h, { bg: item.bg }, cx);
  }
}
function plot_on_div(d, items) {
  mStyle(d, { position: 'relative' });
  for (const item of items) {
    let d1 = item.div = mDiv(d, { x: item.x, y: item.y, w: item.w, h: item.h, bg: item.bg, rounding: '50%', position: 'absolute' });
  }
}
function plot_pdf(canvas, mean, stdev, xfrom, xto, styles = {}) { }
function plot_point(canvas, x, y, styles = {}) { }
function plural(n) { return n == 0 || n > 1 ? 's' : ''; }
function points_from_feature(f) {
  let coords = f.geometry.coordinates;
  let pts = [];
  for (const c of coords[0]) {
    let p = { x: c[0], y: c[1] };
    pts.push(p);
  }
  return pts;
}
function points_to_waypoints(pts = []) { return pts.map(x => L.latLng(x[0], x[1])); }
function points2string(listOfPoints) {
  return listOfPoints.map(p => '' + p.x + ',' + p.Y).join(' '); //'0,0 100,0 50,80',
}
function pointStyleFunction(feature, resolution) {
  return new Style({
    image: new CircleStyle({
      radius: 10,
      fill: new Fill({ color: 'rgba(255, 0, 0, 0.1)' }),
      stroke: new Stroke({ color: 'red', width: 1 }),
    }),
    text: createTextStyle(feature, resolution, myDom.points),
  });
}
function poll() {
  if (IS_POLLING_ALLOWED) {
    if (isdef(DA.poll.func)) DA.poll.data = DA.poll.func(DA.poll.data);
    console.log('...poll')
    to_server(DA.poll.data, DA.poll.type);
  } else console.log('polling OFF!');
}
function poll_for_table_seen_or_deleted() {
  start_polling({ uname: Session.cur_user, tid: Session.cur_tid }, 'poll_table_seen', on_poll_table_seen, 3000);
}
function poll_for_table_show() {
  start_polling({ uname: Session.cur_user, tid: Session.cur_tid }, 'poll_table_show', on_poll_table_show, 3000);
}
function poll_for_table_started() {
  start_polling(Session.cur_user, 'poll_table_started', on_poll_table_started, 3000);
}
function polling_shield_off() { mBy('dPollingShield').style.display = 'none'; }
function polling_shield_on(msg) {
  let d = mBy('dPollingShield');
  d.style.display = 'block';
  d.innerHTML = msg;
}
function pollStart() { }
function pollStop() { clearTimeout(TO.poll); Clientdata.AUTORESET = true; }
function polygonStyleFunction(feature, resolution) {
  return new Style({
    stroke: new Stroke({
      color: 'blue',
      width: 1,
    }),
    fill: new Fill({
      color: 'rgba(0, 0, 255, 0.1)',
    }),
    text: createTextStyle(feature, resolution, myDom.polygons),
  });
}
function polyPointsFrom(w, h, x, y, pointArr) {
  x -= w / 2;
  y -= h / 2;
  let pts = pointArr.map(p => [p.X * w + x, p.Y * h + y]);
  let newpts = [];
  for (const p of pts) {
    newp = { X: p[0], Y: Math.round(p[1]) };
    newpts.push(newp);
  }
  pts = newpts;
  let sPoints = pts.map(p => '' + p.X + ',' + p.Y).join(' '); //'0,0 100,0 50,80',
  return sPoints;
}
function pop_hist() { let top = G.hist.pop(); G.selist = top.selist; }
function pop_top(o) {
  if (isEmpty(o.list)) return null;
  let t = o.get_topcard();
  o.list.shift();
  o.renew(o.list, o.cardcontainer, o.items, o.get_card_func);
  return t;
}
function populate_game_settings(dParent, tid) {
  if (nundef(tid)) Session.game_options.game = {};
  let poss = DB.games[Session.cur_game].options;
  if (nundef(poss)) return;
  for (const p in poss) {
    let key = p;
    let val = poss[p];
    if (isString(val)) {
      let list = val.split(',');
      let fs = mRadioGroup(dParent, {}, `d_${key}`, key);
      let checkfirst = nundef(tid);
      for (const v of list) {
        let d = mRadio(v, isNumber(v) ? Number(v) : v, fs, { cursor: 'pointer' }, null, key);
        if (checkfirst || lookup(Session.game_options.game, [key]) == v) {
          let inp = d.firstChild;
          inp.setAttribute('checked', true);
          checkfirst = false;
        }
      }
      measure_fieldset(fs);
    }
  }
}
function populate_players(list) {
  let d = mBy('d_players');
  if (nundef(d)) return;
  mRemoveChildrenFromIndex(d, 1);
  Session.game_options.players = [];
  for (const name of list) {
    Session.game_options.players.push(name);
    let d1 = mDiv(d, {}, 'dpl_' + name);
    let b = mButton('edit', ev => open_player_editor(ev), d1);
    let label = `${name} (${get_startlevel(name, Session.cur_game)} ${get_preferred_lang(name)})`;
    if (name == Session.cur_user) { let el = mToggle(label, name, d1, { display: 'inline' }); el.firstChild.setAttribute('disabled', true); }
    else { mToggle(label, name, d1, { cursor: 'pointer', display: 'inline' }); }
  }
  measure_fieldset(d);
  let styles = { fz: 14, wmin: '90%', matop: 8 };
  mButton('clear all', clear_all_players, d_players, styles, null, 'b_clear_players');
  mButton('add players', add_players, d_players, styles, null, 'b_add_players');
  mButton('hand select', hand_select, d_players, styles, null, 'b_select_players');
  mButton('reduce', reduce_to_current_players, d_players, styles, null, 'b_reduce_players');
  mButton('show all', show_all_players, d_players, styles, null, 'b_show_all_players');
}
function populate_players_v0(list) {
  let d = mBy('d_players');
  if (nundef(d)) return;
  mRemoveChildrenFromIndex(d, 1);
  Session.game_options.players = [];
  for (const name of list) {
    Session.game_options.players.push(name);
    if (name == Session.cur_user) { let el = mToggle(name, name, d); el.firstChild.setAttribute('disabled', true); }
    else { mToggle(name, name, d, { cursor: 'pointer' }); }
  }
  d_players.innerHTML += '<br>';
  mTextArea(3, 20, d_players, { fz: 16, display: 'none', resize: 'none', border: 'none', outline: 'none' }, 'ta_edit_players');
  d_players.innerHTML += '<br>';
  measure_fieldset(d);
  mButton('edit', onclick_edit_players, d_players, { fz: 14, wmin: '90%' }, null, 'b_edit_players');
}
function populate_playmode(d, modes) {
  let group = mRadioGroup(d, {}, 'd_mode', 'play mode');
  modes = modes.split(',');
  for (const m of modes) {
    let name = m == 'pp' ? 'pass&play' : m == 'multi' ? 'multiplayer' : m;
    let d = mRadio(name, m, group, { cursor: 'default' }, null, 'mode');
    let inp = d.firstChild;
    inp.setAttribute('disabled', true);
    if (m != 'multi') mClass(d, 'disabled');
  }
  measure_fieldset(group);
  let mode = Session.game_options.mode = modes.includes(Session.def_playmode) ? Session.def_playmode : modes[0];
  let el = mBy(`i_mode_${mode}`).checked = true;
}
function populateGamenames() {
  let elem = document.getElementById('fChooseGame');
  clearInit(elem, { innerHTML: '<legend>choose game</legend>' });
  for (const name in allGames) {
    let radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = 'game';
    radio.classList.add('radio');
    radio.id = 'c_b_mm_' + name;
    radio.value = name;
    radio.addEventListener('click', () => onClickGamename(radio));
    elem.appendChild(radio);
    elem.appendChild(document.createTextNode(allGames[name].name.toLowerCase()));
    elem.appendChild(document.createElement('br'))
  }
  let checkedGameInput = document.getElementById('c_b_mm_' + GAME.toLowerCase());
  checkedGameInput.checked = true;
}
function populateJoinList() {
  let players = S.gameConfig.players;
  console.log('populateJoinList', S.gameConfig)
  for (let i = 1; i <= S.gameConfig.numPlayers; i++) {
    let pl = players[i - 1];
    let idRadio = getidAvailable(i);
    let idSpan = getidSpanJoin(i);
    if (isEmpty(pl.username)) {
      show(idRadio);
      show(idSpan);
      uncheckAvailable(i);
      document.getElementById(idSpan).innerHTML = pl.id;
    } else {
      hide(idRadio);
      hide(idSpan);
    }
  }
  for (let i = S.gameConfig.numPlayers + 1; i <= MAX_PLAYERS_AVAILABLE; i++) {
    let idRadio = getidAvailable(i);
    let idSpan = getidSpanJoin(i);
    hide(idRadio);
    hide(idSpan);
  }
}
function populateSelect(i, listValues, selValue) {
  let id = getidType(i);
  let el = document.getElementById(id);
  clearElement(el);
  for (opt of listValues) {
    var newOption = document.createElement("option");
    newOption.text = opt.toString();
    el.appendChild(newOption);
  }
  $(el).val(selValue);
}
function pos2id(id, row, col) {
  return id + '_' + row + '_' + col;
}
function posBC(d) {
  let dParent = d.parentNode;
  let dNew = mDiv(dParent, { w: '100%', h: 50, position: 'absolute', bottom: 0, left: 0, bg: 'null', align: 'center' });
  mAppend(dNew, d);
}
function posBL(d) { mStyle(d, { left: 0, bottom: 0, position: 'absolute' }); }
function posBLR(d) { mStyle(d, { left: 0, bottom: 0, position: 'absolute' }); mRot(d, 180); }
function posBR(d) { mStyle(d, { right: 0, bottom: 0, position: 'absolute' }); }
function posBRR(d) { mStyle(d, { right: 0, bottom: 0, position: 'absolute' }); mRot(d, 180); }
function posCenterInCenter(d) { d.classList.add('centerCentered'); }
function posCIC(d) { d = mEnsure(d); d.classList.add('centerCentered'); }
function posCICB(d) { d = mEnsure(d); d.classList.add('centerCenteredBottomHalf'); }
function posCICT(d) { d = mEnsure(d); d.classList.add('centerCenteredTopHalf'); }
function positionGElement(ui, uidParent, topG) {
  let uiParent = mBy(uidParent);
  if (isdef(uiParent) && topG != uiParent) {
    console.log('positionGElement', ui.id, uiParent.id, topG.id);
    console.log(ui, uiParent, topG)
    let bds = getBounds(uiParent, true);
    let trans = getTransformInfo(uiParent);
    console.log('positionGElement,trans', trans)
    let [x, y] = [trans.translateX, trans.translateY];
    let x1 = -22;
    let y1 = 0;
    let x2 = 0; let y2 = 0;
    let trans1 = uiParent.style.transform;
    let tt = trans1.split('translate');
    if (tt.length <= 1) {
      console.log('there is NO translate transform!!! uiParent', uiParent);
    } else {
      let traNumbersX = trans1.split('(');
      x2 = firstNumber(traNumbersX[1]);
      let traNumbersY = trans1.split(',');
      y2 = firstNumber(traNumbersY[1]);
    }
    gPos(ui, x2, y2);
    let nParent = R.uiNodes[uidParent]
    let par1 = R.uiNodes[nParent.uidParent];
    let par2 = R.uiNodes[par1.uidParent];
  }
  return ui;
}
function posOverlap(d1, dParent, dx, dy, propName) {
  let chType = d1[propName];
  let numChildrenOfTarget = [...dParent.children].filter(x => x.type == chType).length - 1;
  posXY(d1, dParent, numChildrenOfTarget * dx, numChildrenOfTarget * dy, unit = 'px', position = 'absolute');
}
function post_accept_blackmail() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let blackmailer = fen.blackmail.blackmailer;
  let blackmailed = fen.blackmail.blackmailed;
  let building_path = fen.blackmail.building_path;
  let fenbuilding = path2fen(fen, building_path);
  let building_owner = stringAfter(building_path, '.'); building_owner = stringBefore(building_owner, '.');
  assertion(building_owner == blackmailed && blackmailed == uplayer, 'blackmailed and uplayer and building owner must be same');
  elem_from_to(item.key, fen.players[blackmailed].stall, fen.players[blackmailer].hand);
  ari_history_list([`${blackmailed} accepts: gives ${item.key} to ${blackmailer}`], 'blackmail');
  delete fenbuilding.isblackmailed;
  [Z.stage, Z.turn] = [35, [blackmailer]];
  take_turn_fen();
}
function post_auction() {
  console.assert(Z.stage == 13, 'WRONG STAGE IN POST AUCTION ' + Z.stage);
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let item = A.selected.map(x => A.items[x])[0];
  lookupSet(fen, ['buy', uplayer], { key: item.key, index: A.selected[0] });
  ari_history_list([`${uplayer} selects ${item.key}`], 'auction');
  for (const plname of fen.maxplayers) {
    if (!lookup(fen, ['buy', plname])) {
      Z.turn = [plname];
      take_turn_fen();
      return;
    }
  }
  let buylist = dict2list(fen.buy, 'playername');
  let discardlist = [];
  for (const plname of fen.maxplayers) {
    let choice = fen.buy[plname];
    let n = arrCount(buylist, x => x.index == choice.index);
    let is_unique = n == 1;
    if (is_unique) {
      fen.players[plname].coins -= fen.second_most;
      let x = UI.player_stat_items[plname].dCoin; mPulse1(x);
      elem_from_to(choice.key, fen.market, fen.players[plname].hand);
      ari_history_list([`${plname} buys ${choice.key} for ${fen.second_most}`], 'auction');
      let card = find_card(choice.index, UI.market);
      animate_card_transfer(card, arrLast(UI.players[plname].hand.items));
    } else {
      addIf(discardlist, choice.key);
      delete fen.buy[plname];
    }
  }
  for (const key of discardlist) {
    elem_from_to(key, fen.market, fen.deck_discard);
    ari_reorg_discard(fen);
    ari_history_list([`${key} is discarded`], 'auction');
  }
  delete fen.second_most;
  delete fen.maxplayers;
  delete fen.buy;
  delete fen.auction;
  Z.stage = 4;
  Z.turn = [fen.plorder[0]];
  setTimeout(take_turn_fen, 1000);
}
function post_ball() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let keys = A.selected.map(x => A.items[x]).map(x => x.key);
  keys.map(x => lookupAddIfToList(fen, ['ball', uplayer], x));
  keys.map(x => removeInPlace(fen.players[uplayer].hand, x));
  let iturn = fen.plorder.indexOf(uplayer) + 1;
  if (iturn >= fen.plorder.length) {
    if (isdef(fen.ball)) {
      let all = [];
      for (const c of fen.market) all.push(c);
      for (const uplayer in fen.ball) for (const c of fen.ball[uplayer]) all.push(c);
      shuffle(all);
      fen.market = [];
      for (let i = 0; i < 2; i++) top_elem_from_to(all, fen.market);
      for (const uplayer in fen.ball) for (let i = 0; i < fen.ball[uplayer].length; i++) top_elem_from_to(all, fen.players[uplayer].hand);
      delete fen.ball;
    }
    iturn = 0;
    Z.stage = 4;
    console.assert(fen.phase == 'queen', 'wie bitte noch nicht in queen phase?!!!!!!!!!!!');
  }
  Z.turn = [fen.plorder[iturn]];
  ari_history_list([`${uplayer} added ${keys.length} card${plural(keys.length)} to ball!`], 'ball');
  take_turn_fen();
}
function post_blackmail() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  ari_history_list([`blackmail complete!`], 'blackmail');
  delete fen.blackmail;
  ari_next_action();
}
function post_build() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  if (A.selected.length < 4 || A.selected.length > 6) {
    select_error('select 4, 5, or 6 cards to build!');
    return;
  }
  let building_items = A.selected.map(x => A.items[x]);
  let building_type = building_items.length == 4 ? 'farm' : building_items.length == '5' ? 'estate' : 'chateau';
  fen.players[uplayer].buildings[building_type].push({ list: building_items.map(x => x.key), h: null, schweine: [], lead: building_items[0].key });
  for (const item of building_items) {
    let source = lookup(fen, item.path.split('.'));
    removeInPlace(source, item.key);
  }
  ari_history_list([`${uplayer} builds a ${building_type}`], 'build');
  let is_coin_pay = process_payment();
  let ms = 1800;
  if (is_coin_pay) animcoin(Z.uplayer, 1000);
  remove_ui_items(building_items);
  let pl = fen.players[uplayer];
  let nfarms = pl.buildings.farm.length;
  let nestates = pl.buildings.estate.length;
  let nchateaus = pl.buildings.chateau.length;
  let index = building_type == 'farm' ? nfarms - 1 : building_type == 'estate' ? nfarms + nestates - 1 : nfarms + nestates + nchateaus - 1;
  console.log('index of new building is', index);
  let ifinal = UI.players[uplayer].indexOfFirstBuilding + index;
  console.log('ifinal', ifinal);
  let dpl = iDiv(UI.players[uplayer]);
  let akku = [];
  while (dpl.children.length > ifinal) { akku.push(dpl.lastChild); dpl.removeChild(dpl.lastChild); }
  let fenbuilding = arrLast(fen.players[uplayer].buildings[building_type]);
  let newbuilding = ui_type_building(fenbuilding, dpl, { maleft: 8 }, `players.${uplayer}.buildings.${building_type}.${index}`, building_type, ari_get_card, true, false);
  animbuilding(newbuilding, ms, ari_next_action);
  akku.map(x => mAppend(dpl, x));
}
function post_buy() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let item = A.items[A.selected[0]];
  elem_from_to(item.key, fen.open_discard, fen.players[uplayer].hand);
  ari_history_list([`${uplayer} buys ${item.key}`], 'buy')
  ari_reorg_discard();
  console.log('hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')
  process_payment();
  setTimeout(ari_next_action, 1000);
}
function post_buy_rumor() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let non_selected = A.items.filter(x => x.index != A.selected[0]);
  let rumor = item.key;
  for (const item of non_selected) { fen.deck_rumors.push(item.key); }
  fen.players[uplayer].rumors.push(rumor);
  fen.players[uplayer].coins -= 1;
  ari_history_list([`${uplayer} bought a rumor`], 'rumor');
  ari_next_action();
}
function post_church() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let pl = fen.players[uplayer];
  let items = A.selected.map(x => A.items[x]);
  let card = items.find(x => x.path && x.path.includes('church')); if (isdef(card)) card = card.key;
  let cand = items.length > 1 ? items.find(x => !x.path) : fen.candidates[0];
  if (isdef(cand) && isDict(cand)) cand = cand.key;
  if (nundef(card) || nundef(cand)) {
    select_error(`You must select a card ${items.length > 1 ? 'and a candidate' : ''}!`);
    return;
  }
  elem_from_to(card, fen.church, fen.players[cand].hand);
  ari_history_list([`${uplayer} gives ${cand} card ${card}`], 'new cards');
  removeInPlace(fen.toBeSelected, cand);
  if (fen.church.length == 1) {
    let cand = fen.toBeSelected[0];
    let card = fen.church[0];
    elem_from_to(card, fen.church, fen.players[cand].hand);
    ari_history_list([`${cand} receives last card: ${card}`], 'new cards');
    Z.stage = 14;
    let plorder = fen.plorder = jsCopy(fen.heraldorder);
    Z.turn = [plorder[0]];
    take_turn_fen();
  } else {
    Z.turn = [get_next_in_list(uplayer, fen.selorder)];
    take_turn_fen();
  }
}
function post_comm_setup_stage() {
  let [fen, A, uplayer, plorder, pl] = [Z.fen, Z.A, Z.uplayer, Z.plorder, Z.pl];
  let achtungHack = false;
  let new_playerdata = [];
  for (const data of Z.playerdata) {
    let o = data;
    if (is_stringified(data)) {
      console.log('achtungHack: data is stringified');
      o = JSON.parse(data);
      achtungHack = true;
    } else if (is_stringified(data.state)) {
      console.log('achtungHack: data.state is stringified');
      o.state = JSON.parse(data.state);
      achtungHack = true;
    }
    new_playerdata.push(o);
    let state = o.state;
    let giver = state.giver;
    let receiver = state.receiver;
    let keys = state.keys;
    keys.map(x => elem_from_to(x, fen.players[giver].commissions, fen.players[receiver].commissions));
  }
  if (achtungHack) { Z.playerdata = new_playerdata; }
  fen.comm_setup_num -= 1;
  if (fen.comm_setup_num <= 0) {
    delete fen.comm_setup_di;
    delete fen.comm_setup_num;
    delete fen.keeppolling;
    ari_history_list([`commission trading ends`], 'commissions');
    if (exp_rumors && plorder.length > 2) {
      [Z.stage, Z.turn] = [24, Z.options.mode == 'hotseat' ? [fen.plorder[0]] : fen.plorder];
      ari_history_list([`gossiping starts`], 'rumors');
    } else { [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, fen.phase); }
  } else {
    [Z.stage, Z.turn] = [23, Z.options.mode == 'hotseat' ? [fen.plorder[0]] : fen.plorder];
  }
  take_turn_fen_clear();
}
function post_commission() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let comm_selected = A.items[A.selected[0]];
  let stall_item = A.commission_stall_item;
  console.log('stall_item:', stall_item);
  let rank = A.commission.key[0];
  if (nundef(fen.commissioned)) fen.commissioned = [];
  let x = firstCond(fen.commissioned, x => x.rank == rank);
  if (x) { removeInPlace(fen.commissioned, x); }
  else { x = { key: A.commission.key, rank: rank, count: 0 }; }
  x.count += 1;
  let pl = fen.players[uplayer];
  let top = isEmpty(fen.commissioned) ? null : arrLast(fen.commissioned);
  let rankstr = 'A23456789TJQK';
  let points = !top || get_rank_index(rank, rankstr) >= get_rank_index(top.rank, rankstr) ? 1 : 0;
  points += Number(x.count);
  pl.coins += points;
  fen.commissioned.push(x);
  let key = stall_item.key;
  removeInPlace(pl.stall, key);
  if (comm_selected.path == 'open_commissions') {
    removeInPlace(fen.open_commissions, comm_selected.key);
    top_elem_from_to(fen.deck_commission, fen.open_commissions);
  } else {
    removeInPlace(fen.deck_commission, comm_selected.key);
  }
  arrReplace(pl.commissions, [A.commission.key], [comm_selected.key]);
  ari_history_list([`${uplayer} commissions card ${A.commission.key}`, `${uplayer} gets ${points} coin${if_plural(points)} for commissioning ${A.commission.key}`], 'commission');
  ari_next_action();
}
function post_complementing_market_after_church() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  let selectedKeys = A.selected.map(i => A.items[i].key);
  for (const ckey of selectedKeys) {
    elem_from_to(ckey, fen.players[uplayer].hand, fen.players[uplayer].stall);
  }
  if (selectedKeys.length > 0) ari_history_list([`${uplayer} complements stall`], 'complement stall');
  let next = get_next_player(Z, uplayer);
  if (next == plorder[0]) {
    ari_clear_church();
    ari_start_action_stage();
  } else {
    Z.turn = [next];
    take_turn_fen();
  }
}
function post_defend_blackmail() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let blackmailer = fen.blackmail.blackmailer;
  let blackmailed = fen.blackmail.blackmailed;
  let building_path = fen.blackmail.building_path;
  let fenbuilding = path2fen(fen, building_path);
  let building_owner = stringAfter(building_path, '.'); building_owner = stringBefore(building_owner, '.');
  assertion(building_owner == blackmailed && blackmailed == uplayer, 'blackmailed and uplayer and building owner must be same');
  let rumors = fen.players[building_owner].rumors;
  let lead = fenbuilding.lead;
  let brumors = fenbuilding.rumors;
  let match = firstCond(rumors, x => x[0] == lead[0]);
  removeInPlace(rumors, match);
  brumors.pop();
  ari_history_list([`${blackmailed} defends: pays matching rumor to deflect blackmail, 1 rumor is removed from building`], 'blackmail');
  delete fenbuilding.isblackmailed;
  [Z.stage, Z.turn] = [35, [blackmailer]];
  take_turn_fen();
}
function post_downgrade() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let pl = fen.players[uplayer];
  A.downgrade_cards = A.selected.map(x => A.items[x]);
  let obuilding = lookup(fen, A.building.path.split('.'));
  let n = obuilding.list.length;
  let nremove = A.downgrade_cards.length;
  let nfinal = n - nremove;
  let type = A.building.o.type;
  let list = pl.buildings[type];
  removeInPlace(list, obuilding);
  let cards = A.downgrade_cards.map(x => x.key);
  if (nfinal < 4) {
    pl.hand = pl.hand.concat(obuilding.list);
  } else if (nfinal == 4) {
    pl.buildings.farm.push(obuilding);
    pl.hand = pl.hand.concat(cards);
  } else if (nfinal == 5) {
    pl.buildings.estate.push(obuilding);
    pl.hand = pl.hand.concat(cards);
  } else if (nfinal == 6) {
    pl.buildings.chateau.push(obuilding);
    pl.hand = pl.hand.concat(cards);
  }
  A.downgrade_cards.map(x => removeInPlace(obuilding.list, x.key));
  if (isdef(pl.tithes)) {
    for (const c of cards) removeInPlace(pl.hand, c);
  }
  ari_history_list([`${uplayer} downgrades to ${ari_get_building_type(obuilding)}`], 'downgrade');
  if (isdef(pl.tithes)) { proceed_to_newcards_selection(); } else ari_next_action(fen, uplayer);
}
function post_endgame() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  if (A.selected[0] == 0) {
    console.log('GAMEOVER!!!!!!!!!!!!!!!!!!!');
    for (const plname of fen.plorder) {
      let pl = fen.players[plname];
      pl.vps = ari_calc_real_vps(fen, plname);
      pl.max_journey_length = ari_get_max_journey_length(fen, plname);
      pl.score = pl.vps * 10000 + pl.max_journey_length * 100 + pl.coins;
      console.log('score', plname, pl.score);
    }
    let playerlist = dict2list(fen.players, 'name');
    let sorted = sortByDescending(playerlist, 'score');
    console.log('scores', sorted.map(x => `${x.name}:${x.score}`));
    let max_score = sorted[0].score;
    let all_winners = sorted.filter(x => x.score == max_score);
    fen.winners = all_winners.map(x => x.name);
    console.log('winners:', fen.winners)
    take_turn_fen();
  } else {
    let iturn = fen.pl_gameover.indexOf(uplayer) + 1;
    if (iturn >= fen.pl_gameover.length) {
      delete fen.pl_gameover;
      Z.turn = [fen.plorder[0]];
      Z.phase = 'queen';
      [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
      take_turn_fen();
    } else {
      Z.turn = [fen.pl_gameover[iturn]];
      take_turn_fen();
    }
  }
}
function post_exchange() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  if (A.selected.length != 2) {
    select_error('please, select exactly 2 cards!');
    return;
  }
  let i0 = A.items[A.selected[0]];
  let i1 = A.items[A.selected[1]];
  let [p0, p1] = [i0.path, i1.path];
  if (p0.includes('build') == p1.includes('build')) {
    select_error('select exactly one building card and one of your hand or stall cards!');
    return;
  }
  let ibuilding = p0.includes('build') ? i0 : i1;
  let ihandstall = ibuilding == i0 ? i1 : i0;
  let fenbuilding = lookup(fen, ibuilding.path.split('.'));
  let ib_index = ibuilding.o.index;
  if (fenbuilding.schweine.includes(ib_index)) {
    fenbuilding.schweine.splice(fenbuilding.schweine.indexOf(ib_index), 1);
  }
  let pl = fen.players[uplayer];
  let list2 = ihandstall.path.includes('hand') ? pl.hand : pl.stall;
  let i2 = list2.indexOf(ihandstall.o.key)
  exchange_by_index(fenbuilding.list, ib_index, list2, i2);
  ari_history_list([`${uplayer} exchanges card in ${ari_get_building_type(fenbuilding)}`], 'exchange');
  animate_card_exchange(ibuilding, ihandstall, ari_next_action);
}
function post_harvest() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let obuilding = lookup(fen, item.path.split('.'));
  fen.players[uplayer].hand.push(obuilding.h);
  obuilding.h = null;
  ari_history_list([`${uplayer} harvests`], 'harvest');
  ari_next_action();
}
function post_inspect() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let schwein = A.items[A.selected[0]].o;
  turn_new_schwein_up(schwein, A.fenbuilding, A.uibuilding);
}
function post_json(url, o, callback) {
  fetch(url, {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(o)
  }).then(response => response.json()).then(response => callback(response));
}
function post_luxury_or_journey_cards() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let luxury_selected = A.selected[0] == 0;
  console.log('carditems', A.carditems);
  let n = A.carditems.length;
  if (luxury_selected) {
    let cardstoreplace = A.carditems.map(x => x.key);
    arrReplace(fen.players[uplayer].hand, cardstoreplace, deck_deal(fen.deck_luxury, n));
  } else {
    let len = A.jlegal.length;
    let handcards = firstCond(A.carditems, x => A.jlegal[0] == x.key) ? arrFromIndex(A.jlegal, len - n) : A.jlegal.slice(0, n);
    console.log('handcards', handcards);
    arrExtend(fen.players[uplayer].hand, handcards);
    A.jlegal = arrMinus(A.jlegal, handcards);
    let cardstoremove = A.carditems.map(x => x.key);
    arrRemove(fen.players[uplayer].hand, cardstoremove);
  }
  let path = A.journeyitem.path;
  let parts = path.split('.');
  let owner = parts[1];
  console.log('path', path, 'parts', parts, 'owner', owner)
  fen.players[owner].journeys.splice(Number(parts[3]), 1, A.jlegal);
  [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
  ari_history_list([`${uplayer} added to existing journey and takes ${luxury_selected ? 'luxury cards' : 'journey cards'}`], 'journey');
  take_turn_fen();
}
function post_new_journey() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  fen.players[uplayer].journeys.push(A.jlegal);
  arrReplace(fen.players[uplayer].hand, A.jlegal, deck_deal(fen.deck_luxury, A.jlegal.length));
  ari_history_list([`${uplayer} added journey`], 'journey');
  [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
  take_turn_fen();
}
function post_pass() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let n = fen.total_pl_actions - fen.num_actions;
  ari_history_list([`${uplayer} passes after ${n} action${plural(n)}`], 'pass');
  fen.num_actions = 0;
  ari_next_action();
}
function post_pickup() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  elem_from_to(item.key, fen.players[uplayer].stall, fen.players[uplayer].hand);
  ari_history_list([`${uplayer} picks up ${item.key}`], 'pickup');
  ari_next_action();
}
function post_reject_blackmail() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let blackmailer = fen.blackmail.blackmailer;
  let blackmailed = fen.blackmail.blackmailed;
  let building_path = fen.blackmail.building_path;
  let fenbuilding = path2fen(fen, building_path);
  let building_owner = stringAfter(building_path, '.'); building_owner = stringBefore(building_owner, '.');
  assertion(building_owner == blackmailed && blackmailed == uplayer, 'blackmailed and uplayer and building owner must be same');
  ari_history_list([`${blackmailed} rejects!`], 'blackmail');
  let rumors = fenbuilding.rumors;
  let has_lead_rumor = firstCond(rumors, x => x[0] == fenbuilding.lead[0]);
  if (has_lead_rumor) {
    let stall = fen.players[blackmailed].stall;
    fen.players[blackmailer].hand = fen.players[blackmailer].hand.concat(stall);
    fen.players[blackmailed].stall = [];
    ari_history_list([`RUMOR CORRECT!!! ${blackmailed} looses entire stall to ${blackmailer}`], 'blackmail');
  } else {
    ari_history_list([`${blackmailed} was lucky!!! rumors incorrect`], 'blackmail');
  }
  delete fenbuilding.rumors;
  delete fenbuilding.isblackmailed;
  [Z.stage, Z.turn] = [35, [blackmailer]];
  take_turn_fen();
}
function post_rumor_both() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let non_selected = A.items.filter(x => x.index != A.selected[0])[0];
  let rumor = item.key;
  let rumor_other = non_selected.key;
  fen.players[uplayer].rumors.push(rumor);
  fen.players[A.owner].rumors.push(rumor_other);
  ari_history_list([`${uplayer} got a rumor, ${A.owner} got one too`], 'rumor');
  ari_next_action();
}
function post_rumor_setup() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  for (const plname of plorder) { fen.players[plname].rumors = []; }
  for (const plname of plorder) {
    let data = firstCond(Z.playerdata, x => x.name == plname);
    let di = data.state.di;
    for (const k in di) {
      arrPlus(fen.players[k].rumors, di[k]);
    }
  }
  ari_history_list([`gossiping ends`], 'rumors');
  [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, fen.phase);
  take_turn_fen_clear();
}
function post_sell() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  if (A.selected.length != 2) {
    select_error('select exactly 2 cards to sell!');
    return;
  }
  for (const i of A.selected) {
    let c = A.items[i].key;
    elem_from_to(c, fen.players[uplayer].stall, fen.deck_discard);
  }
  ari_reorg_discard();
  fen.players[uplayer].coins += 1;
  let [i1, i2] = A.selected.map(x => A.items[x].key)
  ari_history_list([`${uplayer} sells ${i1} and ${i2}`], 'sell');
  ari_next_action(fen, uplayer);
}
function post_stall_selected() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let selectedKeys = A.selected.map(i => A.items[i].key);
  for (const ckey of selectedKeys) {
    elem_from_to(ckey, fen.players[uplayer].hand, fen.players[uplayer].stall);
  }
  ensure_stallSelected(fen);
  fen.stallSelected.push(uplayer);
  ari_history_list([`${uplayer} puts up a stall for ${selectedKeys.length} action${plural(selectedKeys.length)}`], 'market');
  if (is_stall_selection_complete()) {
    delete fen.stallSelected;
    fen.actionsCompleted = [];
    if (check_if_church()) ari_start_church_stage(); else ari_start_action_stage();
  } else {
    Z.turn = [get_next_player(Z, uplayer)];
    take_turn_fen();
  }
}
function post_tax() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let items = A.selected.map(x => A.items[x]);
  let n = fen.pl_tax[uplayer];
  if (items.length != n) {
    select_error(`please select exactly ${n} cards`);
    return;
  }
  for (const item of items) {
    elem_from_to_top(item.key, fen.players[uplayer].hand, fen.deck_discard);
  }
  ari_reorg_discard();
  ari_history_list([`${uplayer} pays tax: ${fen.pl_tax[uplayer]}`], 'tax');
  fen.pl_tax[uplayer] = 0;
  let iturn = fen.plorder.indexOf(uplayer);
  let plnext = ari_get_tax_payer(fen, fen.pl_tax, iturn + 1);
  if (plnext == null) {
    [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, 'king');
    delete fen.pl_tax;
  } else {
    Z.turn = [plnext];
  }
  take_turn_fen(fen, uplayer);
}
function post_tide() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let items = A.selected.map(x => A.items[x]);
  if (items.length == 0) { select_error('No cards selected!'); return; }
  let st = items.map(x => ({ key: x.key, path: x.path }));
  let val = arrSum(st.map(x => ari_get_card(x.key).val));
  lookupSet(fen, ['players', uplayer, 'tides'], { keys: st, val: val });
  remove_tides_from_play(fen, uplayer);
  let pldone = plorder.filter(x => isdef(fen.players[x].tides));
  let minplayers = arrMin(pldone, x => fen.players[x].tides.val);
  let minplayer = isList(minplayers) ? minplayers[0] : minplayers;
  let minval = fen.tidemin = fen.players[minplayer].tides.val;
  let next = get_next_in_list(uplayer, fen.church_order);
  if (next == fen.church_order[0]) {
    assertion(sameList(pldone, plorder), 'NOT all players have tides!!!!!!!', pldone);
    if (minplayers.length > 1) { proceed_to_newcards_selection(); return; }
    else {
      pldone = pldone.filter(x => x != minplayer);
      let sorted = sortBy(pldone, x => fen.players[x].tides.val);
      let second_min = sorted[0];
      fen.tide_minimum = fen.players[second_min].tides.val - minval;
      let pl = fen.players[minplayer];
      let hst = pl.hand.concat(pl.stall);
      let vals = hst.map(x => ari_get_card(x).val);
      let sum = isEmpty(vals) ? 0 : arrSum(vals);
      let min = fen.tide_minimum;
      if (sum < min) {
        pl.hand = [];
        pl.stall = [];
        let buildings = arrFlatten(get_values(pl.buildings));
        console.log('buildings', buildings);
        if (isEmpty(buildings)) {
          ari_history_list([`${minplayer} does not have a building to downgrade!`], 'downgrade');
          proceed_to_newcards_selection();
          return;
        }
        ari_history_list([`${minplayer} must downgrade a building to tide ${min}!`], 'downgrade');
        Z.stage = 22;
      } else {
        ari_history_list([`${minplayer} must tide more cards to reach ${min}!`], 'tide');
        Z.stage = 21;
      }
      Z.turn = [minplayer];
    }
  } else {
    Z.turn = [next];
  }
  turn_send_move_update();
}
function post_tide_minimum() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  let items = A.selected.map(x => A.items[x]);
  let st = items.map(x => ({ key: x.key, path: x.path }));
  pl.tides.keys = pl.tides.keys.concat(st);
  let newval = arrSum(st.map(x => ari_get_card(x.key).val));
  pl.tides.val += newval;
  console.log('tide_minimum', fen.tide_minimum);
  console.log('val', pl.tides.val);
  if (newval < fen.tide_minimum) {
    select_error(`you need to tide at least ${fen.tide_minimum} to reach minimum`);
    return;
  }
  remove_tides_from_play(fen, uplayer, st);
  proceed_to_newcards_selection();
}
function post_tithe() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let items = A.selected.map(x => A.items[x]);
  if (items.length == 0) { select_error('No cards selected!'); return; }
  let st = items.map(x => ({ key: x.key, path: x.path }));
  let val = arrSum(st.map(x => ari_get_card(x.key).val));
  lookupSet(fen, ['players', uplayer, 'tithes'], { keys: st, val: val });
  remove_tithes_from_play(fen, uplayer);
  let pldone = plorder.filter(x => isdef(fen.players[x].tithes));
  let minplayers = arrMin(pldone, x => fen.players[x].tithes.val);
  let minplayer = isList(minplayers) ? minplayers[0] : minplayers;
  let minval = fen.tithemin = fen.players[minplayer].tithes.val;
  let next = get_next_in_list(uplayer, fen.church_order);
  if (next == fen.church_order[0]) {
    assertion(sameList(pldone, plorder), 'NOT all players have tithes!!!!!!!', pldone);
    if (minplayers.length > 1) { proceed_to_newcards_selection(); return; }
    else {
      pldone = pldone.filter(x => x != minplayer);
      let sorted = sortBy(pldone, x => fen.players[x].tithes.val);
      let second_min = sorted[0];
      fen.tithe_minimum = fen.players[second_min].tithes.val - minval;
      let pl = fen.players[minplayer];
      let hst = pl.hand.concat(pl.stall);
      let vals = hst.map(x => ari_get_card(x).val);
      let sum = isEmpty(vals) ? 0 : arrSum(vals);
      let min = fen.tithe_minimum;
      if (sum < min) {
        pl.hand = [];
        pl.stall = [];
        let buildings = arrFlatten(get_values(pl.buildings));
        console.log('buildings', buildings);
        if (isEmpty(buildings)) {
          ari_history_list([`${minplayer} does not have a building to downgrade!`], 'downgrade');
          proceed_to_newcards_selection();
          return;
        }
        ari_history_list([`${minplayer} must downgrade a building to tithe ${min}!`], 'downgrade');
        Z.stage = 22;
      } else {
        ari_history_list([`${minplayer} must tithe more cards to reach ${min}!`], 'tithe');
        Z.stage = 21;
      }
      Z.turn = [minplayer];
    }
  } else {
    Z.turn = [next];
  }
  take_turn_fen();
}
function post_tithe_minimum() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  let items = A.selected.map(x => A.items[x]);
  let st = items.map(x => ({ key: x.key, path: x.path }));
  pl.tithes.keys = pl.tithes.keys.concat(st);
  let newval = arrSum(st.map(x => ari_get_card(x.key).val));
  pl.tithes.val += newval;
  console.log('tithe_minimum', fen.tithe_minimum);
  console.log('val', pl.tithes.val);
  if (newval < fen.tithe_minimum) {
    select_error(`you need to tithe at least ${fen.tithe_minimum} to reach minimum`);
    return;
  }
  remove_tithes_from_play(fen, uplayer, st);
  proceed_to_newcards_selection();
}
function post_trade() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  if (A.selected.length != 2) {
    select_error('please, select exactly 2 cards!');
    return;
  }
  let i0 = A.items[A.selected[0]];
  let i1 = A.items[A.selected[1]];
  let num_own_stall = [i0, i1].filter(x => x.path.includes(uplayer)).length;
  if (i0.path == i1.path) {
    select_error('you cannot trade cards from the same group');
    return;
  } else if (num_own_stall != 1) {
    select_error('you have to pick one card of your stall and one other card');
    return;
  } else {
    let list0 = lookup(fen, i0.path.split('.'));
    let list1 = lookup(fen, i1.path.split('.'));
    exchange_by_index(list0, i0.o.index, list1, i1.o.index);
    ari_history_list(get_trade_history(uplayer, i0, i1), 'trade');
    animate_card_exchange(i0, i1, ari_next_action);
  }
}
function post_upgrade() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  A.building = A.items[A.selected[0]];
  let gb = A.building;
  let b = lookup(fen, gb.path.split('.'));
  let n = A.upgrade_cards.length;
  let type0 = gb.o.type;
  let len = gb.o.list.length + n;
  let type1 = len == 5 ? 'estate' : 'chateau';
  let target = lookup(fen, gb.path.split('.'));
  for (const o of A.upgrade_cards) {
    let source = lookup(fen, o.path.split('.'));
    elem_from_to(o.key, source, target.list);
  }
  let bres = target;
  bres.h = null;
  removeInPlace(fen.players[uplayer].buildings[type0], bres);
  fen.players[uplayer].buildings[type1].push(bres);
  ari_history_list([`${uplayer} upgrades a ${type0}`], 'upgrade');
  console.log('hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')
  process_payment();
  setTimeout(ari_next_action, 1000);
}
function post_visit() {
  let [fen, A, uplayer, building, obuilding, owner] = [Z.fen, Z.A, Z.uplayer, Z.A.building, Z.A.obuilding, Z.A.buildingowner];
  let buildingtype = Z.A.building.o.type;
  let res = A.selected[0] == 0;
  if (!res) {
    if (fen.players[owner].coins > 0) {
      fen.players[owner].coins -= 1;
      fen.players[uplayer].coins += 1;
    }
  } else {
    let list = obuilding.list;
    let correct_key = list[0];
    let rank = correct_key[0];
    while (list.length > 0) {
      let ckey = list[0];
      if (ckey[0] != rank) {
        elem_from_to_top(ckey, list, fen.deck_discard);
      } else {
        elem_from_to(ckey, list, fen.players[owner].hand);
      }
    }
    if (isdef(obuilding.h)) {
      fen.deck_discard.unshift(obuilding.h);
    }
    ari_reorg_discard(fen);
    let blist = lookup(fen, stringBeforeLast(building.path, '.').split('.'));
    removeInPlace(blist, obuilding);
  }
  ari_history_list([`${uplayer} visited ${buildingtype} of ${owner} resulting in ${res ? 'destruction' : 'payoff'}`,], 'visit');
  ari_next_action(fen, uplayer);
}
function posTC(d) { mStyleX(d, { right: '50%', top: 0, position: 'absolute' }); }
async function postCors(url, data, type, handle_result) {
  data.data_type = type;
  var formData = new FormData();
  for (const k in data) {
    formData.append(k, data[k]);
  }
  let h = new Headers();
  h.append('Accept', 'application/text');
  var resp = await fetch(url, {
    method: 'POST',
    mode: 'cors',
    headers: h,
    body: formData,
  });
  let result = await resp.text();
  try {
    let jsonResult = JSON.parse(result);
    if (isdef(handle_result)) handle_result(jsonResult);
  } catch {
    if (isdef(handle_result)) handle_result({ message: result });
  }
}
async function postData(url = '', data = {}) {
  const response = await fetch(url, {
    method: 'POST',
    mode: 'cors',
    cache: 'no-cache',
    credentials: 'omit',
    headers: {
      'Content-Type': 'application/json'
    },
    redirect: 'follow',
    referrerPolicy: 'no-referrer',
    body: JSON.stringify(data)
  });
  return await response.text(); 
}
function posTL(d) { mPos(d, 0, 0) }
function posTopLeftInCenter(d) { d.classList.add('centered'); }
function posToPoint(pos = 'cc', w, h, offx = 0, offy = 0) {
  let di = { t: 0, b: h, l: 0, r: w };
  let py = pos[0] == 'c' ? h / 2 : di[pos[0]];
  let px = pos[1] == 'c' ? w / 2 : di[pos[1]];
  return [px + offx, py + offy];
}
function posTR(d) { mStyle(d, { right: 0, top: 0, position: 'absolute' }); }
function posXY(d1, dParent, x, y, unit = 'px', position = 'absolute') {
  if (nundef(position)) position = 'absolute';
  if (dParent && !dParent.style.position) dParent.style.setProperty('position', 'relative');
  d1.style.setProperty('position', position);
  if (isdef(x)) d1.style.setProperty('left', makeUnitString(x, unit));
  if (isdef(y)) d1.style.setProperty('top', makeUnitString(y, unit));
}
function pPanel(dParent) { return mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }); }
function pr(x) { }
function prelim() {
  console.assert(isdef(DB));
  Speech = new SpeechAPI('E');
  KeySets = getKeySetsX();
  TO = new TimeoutManager();
  initTable();
  initSidebar();
  initAux();
  _start();
}
async function prelims() {
  if (serverData.waiting_for) { await sendStatus(getUsernameForPlid(serverData.waiting_for[0])); }
  if (serverData.end) { d3.select('button').text('RESTART').on('click', restartGame); }
  timit.showTime('* vor package: *')
  preProcessData();
  isTraceOn = SHOW_TRACE;
  G = {};
  PROTO = {};
  POOLS = { augData: makeDefaultPool(jsCopy(serverData)) };
  sData = POOLS.augData;
}
function prelude(s, d) { }
function prep_for_church_downgrade(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  fen.stage = 1004;
  fen.market = ['JHn', 'QSn'];
  let ob = {}; ob[uplayer] = { estate: 1 }; stage_correct_buildings(fen, ob);
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand = ['JHn', 'QSn']; pl.stall = ['JHn', 'QSn'];
    if (plname == uplayer) {
      pl.hand = ['2Hn', '2Sn']; pl.stall = ['AHn', 'ASn'];
    }
  }
}
function prep_move() {
  let [fen, uplayer, pl] = [Z.fen, Z.uplayer, Z.pl];
  for (const k of ['round', 'phase', 'stage', 'step', 'turn']) { fen[k] = Z[k]; }
  deactivate_ui();
  clear_timeouts();
}
function prepParentForChildren(loc, numChildren) {
  let parent = mBy(loc);
  clearElement(loc);
  parent.style.display = 'inline-grid';
  let uiNode = AREAS[loc];
  if (!uiNode.type) uiNode.type = 'panel';
  if (!uiNode.params) uiNode.params = { split: 'equal' };
  uiNode.params.num = numChildren;
  if (!uiNode.panels) uiNode.panels = [];
}
function preProcessData(data) {
  if (nundef(data)) data = serverData;
  for (const plid in data.players) {
    let pl = data.players[plid];
    if (isdef(pl.obj_type)) continue;
    pl.obj_type = plid == plidSentStatus ? 'GamePlayer' : 'opponent';
  }
  if (data.options) {
    tupleGroups = getTupleGroups();
    let iGroup = 0;
    let iTuple = 0;
    boats = [];
    for (const tg of tupleGroups) {
      for (const t of tg.tuples) {
        let boatInfo = { obj_type: 'boat', oids: [], desc: tg.desc, tuple: t, iGroup: iGroup, iTuple: iTuple, text: t.map(x => x.val), weg: false };
        boats[iTuple] = boatInfo;
        iTuple += 1;
      }
      iGroup += 1;
    }
  } else {
    tupleGroups = null;
    boats = [];
  }
}
function PreSearch() {
  if (GameController.GameOver != BOOL.TRUE) {
    srch_thinking = BOOL.TRUE;
    StartThinking();
    setTimeout(function () { StartSearch(); }, 200);
  }
}
function preselectFirstVisualsForBoats() {
  let oidlist = [];
  for (const id of getBoatIds()) {
    let oids = id2oids[id];
    if (isdef(oids)) oids.map(x => addIf(oidlist, x))
  }
  let vislist = oidlist.map(x => getMainId(x)).filter(x => x !== null);
  vislist = vislist.concat(oidlist.map(x => getDefId(x)));
  vislist.map(id => UIS[id].highFrame());
}
function present() {
  if (Settings.perspective == 'me') presentFor(me);
  else presentAll();
}
function present_a_game() {
  let [fen, uplayer, pl] = [Z.fen, Z.uplayer, Z.pl];
  UI.hand = ui_type_hand(pl.hand, dTable, { margin: 20 });
}
function present_account(userdata) {
  DA.imageChanged = DA.colorChanged = false;
  return `
  <div id="dAccount" style="max-width=500px; margin-top:10px; display:flex; animation: appear1 1s ease;justify-content:center; align-content:center">
    <div id="error">some text</div>
    <div style='text-align:center'>
      <form id="myform" autocomplete="off" style='text-align:center;background:${userdata.color}'>
        <span id='img_dd_instruction' style="font-size:11px;">drag and drop an image to change</span><br>
        <img id="imgPreview" onload='addColorPicker("${userdata.color}");' src='${get_image_path(userdata)}' ondragover="handle_drag_and_drop(event)" ondrop="handle_drag_and_drop(event)" ondragleave="handle_drag_and_drop(event)"
          style="height:200px;margin:10px;" />
        <input id='iUsername' type="text" name="motto" placeholder='motto' value="${userdata.motto}" autofocus
          onkeydown="if (event.keyCode === 13){event.preventDefault();collect_data(event);}" />
        <br />
        <input id='save_settings_button' type="button" value="Submit" onclick="collect_data(event)" ><br>
      </form>
  </div></div>
  `;
}
function present_auto(dParent, state) {
  for (const k in state) {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, k);
    let val = state[k];
    if (isSimple(val)) {
      d.innerHTML += ': ' + val;
    } else if (isList(val)) {
      mCenterCenterFlex(d);
      val.map(x => mDiv(d, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, x));
    } else {
      mCenterCenterFlex(d);
      present_auto(d, val);
    }
  }
}
function present_contacts(obj) {
  let others = sync_users(obj.myusers);
  Session.others = others.map(x => x.name);
  var inner_left_panel = mBy("inner_left_panel");
  inner_left_panel.innerHTML = createContactsContent(others, obj.msgs);
}
function present_game_options(tid) {
  if (isdef(tid)) {
    let table = Session.cur_table;
    Session.cur_game = table.game;
    if (nundef(Session.game_options)) Session.game_options = table_options_to_game_options(table);
  } else {
    Session.game_options = {};
  }
  let gname = Session.cur_game;
  let g = DB.games[gname];
  let d = mBy('inner_left_panel');
  d.innerHTML = get_lobby(tid);
  let d1 = mBy('d_game_options');
  group = mRadioGroup(d1, { wmin: 190 }, 'd_players', 'players');
  populate_game_settings(d1, tid);
  populate_playmode(d1, g.av_modes);
  populate_players(isdef(tid) ? get_keys(Session.cur_players) : get_def_players_for_user(Session.cur_user));
}
function present_games() {
  let html = `<div id='game_menu' style="text-align: center; animation: appear 1s ease both">`;
  for (const g of dict2list(DB.games)) { html += ui_game_menu_item(g, Session.tables_by_game[g.id]); }
  mBy('inner_left_panel').innerHTML = html;
  mCenterCenterFlex(mBy('game_menu'));
}
function present_games_dep(obj) {
  bygame = set_tables_by_game(obj);
  Session.cur_tid = !isEmpty(obj.tables) ? obj.tables[0].id : null;
  mBy('inner_left_panel').innerHTML = createGamesContent(dict2list(DB.games), bygame);
  mCenterCenterFlex(mBy('game_menu'));
}
function present_intro() {
  let dParent = mBy('divTest'); show(dParent); clearElement(dParent);
  mStyle(dParent, { position: 'absolute', top: 0, bg: 'green', wmin: '100vw', hmin: '100vw' });
  param_present_contacts(Session, dParent, 'onclick_user_in_intro');
}
function present_login(obj) { param_present_contacts(obj, mBy('inner_left_panel'), 'onclick_user_login'); }
function present_login_new(obj) {
  let others = sync_users(obj.myusers);
  Session.others = others.map(x => x.name);
  var inner_left_panel = mBy("inner_left_panel");
  inner_left_panel.innerHTML = createLoginNewContent(others, obj.msgs);
}
function present_non_admin_user(username) {
  load_user(username);
  get_dictionary();
  poll_for_table_started();
}
function present_non_admin_waiting_screen() {
  let dParent = mBy('divTest'); show(dParent); clearElement(dParent);
  mStyle(dParent, { position: 'absolute', top: 0, bg: 'green', wmin: '100vw', hmin: '100vw' });
  let dlogout = mDiv(dParent, { position: 'absolute', right: 10, top: 4, cursor: 'pointer' }, 'ddd_logout', `logout`);
  dlogout.onclick = onclick_logout;
  show_user_image(Session.cur_user, dParent);
  status_message_new(`hi, ${capitalize(Session.cur_user)}, a game is starting soon...`, dParent, { classname: 'slow_gradient_blink' });
  mLinebreak(dParent, 100);
  show_rankings(dParent);
}
function present_resume_game_options() {
  let gname = Session.cur_game;
  let g = DB.games[gname];
  Session.game_options = {};
  let d = mBy('inner_left_panel');
  let game = DB.games[Session.cur_game];
  let html = `
  <div id="lobby_holder" class="layout_lobby">
    <div id="lobby_header"><div class='logo'>⛱</div>Settings for ${game.friendly}</div>
    <div id="lobby_main">
        <div id='d_game_options' class='vCenterChildren'>
        </div>
        <div class="button_wrapper">
          <button id='bJoinGame' class='button' style='display:none'>join game</button>
          <button id='bCreateGame' class='button' onclick='onclick_create_game_button()' style='display:none'>create game</button>
          <button id='bResumeGame' class='button' onclick='onclick_resume_game_button()'>resume game</button>
          <button id='bLobbyOk' class='button' onclick='onClickCreateGameOk()' style='display:none'>Ok</button>
          <button id='bLobbyCancel' class='button' onclick='onClickCreateGameCancel()' style='display:none'>Cancel</button>
          <button id='bLobbyJoinOk' class='button' onclick='onClickJoinGameOk()' style='display:none'>Ok</button>
          <button id='bLobbyJoinCancel' class='button' onclick='onClickJoinGameCancel()' style='display:none'>Cancel</button>
        </div>
      </div>
    </div>
  `;
  d.innerHTML = html;
  let d1 = mBy('d_game_options');
  group = mRadioGroup(d1, { wmin: 190 }, 'd_players', 'players');
  populate_game_settings(d1);
  populate_playmode(d1, g.av_modes);
  populate_players(get_def_players_for_user(Session.cur_user));
}
function present_simple(dParent, item) {
  if (isDict(item)) {
    mCenterCenterFlex(dParent);
    for (const k in item) {
      let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, k + ': ');
      val = item[k];
      present_simple(d, val);
    }
  } else if (isList(item)) {
    mCenterCenterFlex(dParent);
    item.map(x => present_simple(dParent, x));
  } else {
    dParent.innerHTML += item;
  }
}
function present_simple0(dParent, item) {
  if (isDict(item)) {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    mCenterCenterFlex(d);
    for (const k in item) {
      d.innerHTML += k;
      present_simple0(d, item[k]);
    }
  } else if (isList(item)) {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    mCenterCenterFlex(d);
    item.map(x => present_simple0(d, x));
  } else {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    d.innerHTML = item;
  }
}
function present_state_player(dParent, state, player) {
  if (!lookup(state, ['players', player])) { console.log('no state for player', player); return; }
  let dplayer = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, 'your items:');
  present_auto(dplayer, state.players[player]);
  let drest = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, 'table');
  present_auto(drest, state);
}
function present_structured(dParent, item) {
  let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
  if (isDict(item)) {
    mCenterCenterFlex(d);
    for (const k in item) {
      val = item[k];
      let d1 = mDiv(d, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, k);
      present_structured(d1, val);
    }
  } else if (isList(item)) {
    mCenterCenterFlex(d);
    item.map(x => present_structured(d, x));
  } else {
    d.innerHTML = item;
  }
}
function present_structured1(dParent, item) {
  if (isDict(item)) {
    mCenterCenterFlex(dParent);
    for (const k in item) {
      val = item[k];
      let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, k);
      present_structured1(d, val);
    }
    return dParent;
  } else if (isList(item)) {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    mCenterCenterFlex(d);
    item.map(x => present_structured1(d, x));
    return d;
  } else {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    d.innerHTML = item;
    return d;
  }
}
function present_table(obj) {
  Session.cur_menu = 'play';
  console.assert(isdef(obj.table), 'present_table without obj.table!!!!!!!!!!!!!!');
  update_session(obj);
  let table_status = Session.cur_table.status;
  let my_status = Session.cur_me.player_status;
  let have_another_move = my_status == 'joined';
  if (table_status == 'deleted') { in_game_off(); in_game_open_prompt_off(); status_message_off(); get_games(); return; }
  if (!in_game()) { open_game_ui(); in_game_on(); }
  let d = mBy('table'); d.animate([{ opacity: 0, transform: 'translateY(50px)' }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: 1000, easing: 'ease' });
  if (!have_another_move) { reload_last_game_state(); }
  else if (!in_game_open_prompt()) { open_prompt(); in_game_open_prompt_on(); }
  else { uiActivated = true; }
  update_game_status(Session.cur_players);
  if (table_status == 'over') {
    stop_game();
    let winners = Session.winners = race_check_endcondition();
    if (!isEmpty(winners)) {
      stop_game();
      DA.after_status_message = onclick_gameover_screen;
      show_gameover(winners);
    }
  }
}
function present_table_from_csv(csv_text, dParent) {
  prepare_table();
  dParent.innerHTML = get_table_html();
  import_the_text(csv_text);
}
function present_wait_for_table_to_start() {
  status_message(`hi, ${capitalize(Session.cur_user)}, a game is starting soon...`, { top: 330, classname: 'slow_gradient_blink' });
  poll_for_table_started();
}
function present_wait_for_table_to_start_after_reload() {
  status_message(`table has been canceled by host, new game starting soon...`, { top: 330, classname: 'slow_gradient_blink' });
  poll_for_table_started();
}
function present0(dParent, item) {
  for (const k in item) {
    val = item[k];
    let d = mDiv(dParent, { display: 'inline-block', bg: 'random', rounding: 10, margin: 10, padding: 10 });
    if (isDict(val)) {
      present0(d, val);
    } else if (isList(val)) {
      val.map(x => presentSimpleVal(d, x));
    } else {
      presentSimpleVal(d, val);
    }
  }
}
function present00(items, options) {
  [options.rows, options.cols, options.szPic.w, options.szPic.h] = [10, 10, 50, 50];
  console.log('present00: rows', options.rows, 'cols', options.cols);
  let fzOrig = options.fzOrig = options.fzText;
  _setRowsColsSize(options);
  makeItemDivs(items, options);
  if (options.fixTextFont == true) {
    _setTextFont(items, options, (options.fzOrig + options.fzText) / 2);
  }
  let dGrid = mDiv(options.dArea, { hmax: options.area.h, fz: 2, padding: options.gap }, getUID());
  options.idGrid = dGrid.id;
  for (const item of items) { mAppend(dGrid, iDiv(item)); }
  _makeGridGrid(items, options, dGrid);
  let wa = options.area.w, ha = options.area.h;
  let wi = (wa / options.cols) - 1.25 * options.gap;
  let hi = ha / options.rows - 1.25 * options.gap;
  wi = Math.min(200, wi); wi = Math.round(wi);
  hi = Math.min(200, hi); hi = Math.round(hi);
  let fzMax, fpMax;
  if (options.showLabels) {
    fzMax = Math.floor(idealFontDims(options.wLongest, wi - 2 * options.padding, hi, 24).fz);
    fpMax = options.showPic ? Math.min(hi / 2, wi * 2 / 3, hi - fzMax) : 0;
  } else { fzMax = 1; fpMax = options.showPic ? Math.min(hi * 2 / 3, wi * 2 / 3) : 0; }
  options.fzPic = options.picStyles.fz = fpMax;
  options.fzText = options.labelStyles.fz = fzMax;
  options.szPic = { w: wi, h: hi };
  for (const item of items) {
    let ui = item.live;
    mStyleX(ui.div, { wmin: wi, hmin: hi, padding: 0 });
    if (isdef(ui.dPic)) mStyleX(ui.dPic, { fz: fpMax });
    if (isdef(ui.dLabel)) mStyleX(ui.dLabel, { fz: fzMax });
  }
  if (options.fzText < options.fzOrig && options.fixTextFont == true) _setTextFont(items, options, (options.fzOrig + options.fzText) / 2)
  mStyleX(dGrid, { display: 'inline-grid', wmax: options.area.w, hmax: options.area.h });
  if (isOverflown(dGrid)) {
    let factor = .9;
    w = options.szPic.w * factor;
    h = options.szPic.h * factor;
    fz = options.fzText * factor;
    fzPic = options.fzPic * factor;
    options.fzPic = options.picStyles.fz = fzPic;
    options.fzText = options.labelStyles.fz = fz;
    options.szPic = { w: w, h: h };
    options.padding *= factor;
    options.gap *= factor;
    mStyleX(dGrid, { gap: options.gap / 2 });
    for (const item of items) {
      let ui = item.live;
      if (options.showLabels) mStyleX(ui.dLabel, { fz: fz });
      mStyleX(ui.div, { padding: options.padding, w: w, h: h });
      mStyleX(ui.dPic, { fz: fzPic });
    }
  }
  return [items, options];
}
function presentActions() {
  deleteActions();
  let areaName = 'a_d_divSelect';
  UIS[areaName].elem.scrollTop = 0;
  let iGroup = 0;
  let iTuple = 0;
  for (const tg of G.tupleGroups) {
    for (const t of tg.tuples) {
      let boatInfo = { obj_type: 'boat', oids: [], desc: tg.desc, tuple: t, iGroup: iGroup, iTuple: iTuple, text: t.map(x => x.val), weg: false };
      let mobj = makeDefaultAction(boatInfo, areaName);
      iTuple += 1;
    }
    iGroup += 1;
  }
}
function presentAddNode(n, title, area, lf, ls, lo) {
  if (nundef(lo)) lo = [];
  addIf(lo, 'act');
  addIf(lo, 'ui');
  let d = isString(area) ? mBy(area) : area;
  mNodeFilter(n, { dParent: d, title: title, lstFlatten: lf, lstShow: ls, lstOmit: lo });
}
function presentAll() {
  clearZones();
  for (const pl of T.players) {
    let zone = Zones[pl.id];
    pl.hand.showDeck(zone.dData, 'right', 0, false);
  }
  showTrick();
}
function presentAllProps(oid, pool, ms) {
  let o_new = pool[oid];
  let akku = [];
  for (const prop in o_new) {
    let nval = o_new[prop];
    let sval = simpleRep(nval);
    akku.push(prop + ':' + sval);
  }
  ms.multitext({ txt: akku, fz: 12, fill: 'black' });
}
function presentChoices() {
  G.tupleGroups = getTupleGroups();
  decider.genMove(
    G,
    idx => {
      freezeUI();
      sendAction(idx, [gameStep]);
    },
  );
  timit.end_of_cycle('');
}
function presentDefault(oid, o, isTableObject = true) {
  let mobj = getDefVisual(oid);
  if (!mobj) return;
  if (isPlain() && !isTableObject && G.player == oid) { mobj.hide(); return null; }
  if (isPlain() && !isTableObject) mobj.show();
  let optin = isTableObject ? S.settings.table.optin : S.settings.player.optin;
  let optout = isTableObject ? S.settings.table.optout : S.settings.player.optout;
  keys = optout ? arrMinus(getKeys(o), optout) : optin ? optin : getKeys(o);
  let x = mobj.tableX(o, keys);
  if (!isPlain() && !isTableObject) {
    growIfDefaultMainAreaWidth(mobj);
  }
  return x;
}
function presentDictTree(nDict, uidStart, area, treeProperty, R, lf, ls, lo, styles) {
  if (nundef(nDict)) {
    console.log('presentDictTree: cannot present nDict!!!');
    return;
  }
  d = mBy(area);
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mColor(d1, colorTrans('black', i * .1));
    if (isdef(styles)) mStyleX(d1, styles);
  }
  if (isEmpty(nDict)) return;
  maxLevel = 1 + recPresent(nDict[uidStart], 0, dLevel, nDict, treeProperty,
    { lstFlatten: lf, lstShow: ls, lstOmit: lo });
}
function presentEnd() {
  if (nundef(G.end)) return false;
  let winner = G.serverData.end.winner;
  let msg = winner == null ? 'Both players win!' : 'Winner is ' + G.playersAugmented[winner].name;
  setStatus('GAME OVER! ' + msg);
  if (winner) {
    setCSSVariable('--bgWinner', G.playersAugmented[winner].color);
    areaBlink('a_d_status');
  }
  S_autoplay = false;
  unfreezeUI();
  let d = document.getElementById('a_d_divSelect');
  clearElement(d);
  d.scrollTop = 0;
  return true;
}
function presentFor(me) {
  clearElement(dTable);
  let others = arrWithout(T.players, [me]);
  for (const pl of others) {
    pl.hand.showDeck(dTable, 'right', 0, false);
  }
  mLinebreak(dTable);
  T.trick.showDeck(dTable, 'right', 20, true);
  mLinebreak(dTable);
  me.hand.showDeck(dTable, 'right', 0, false);
  showFleetingMessage('click to play a card!');
}
function presentGenerations_dep(indices, area, R, genKey = 'G') {
  d = mBy(area);
  let level = 0;
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mSize(d1, '100%', 'auto');
    mFlexWrap(d1)
    mColor(d1, colorTrans('black', i * .1));
  }
  let di = 0;
  for (const i of indices) {
    let div = dLevel[di]; di++;
    presentNodes(R.gens[genKey][i], div);
  }
}
function presentInChatList(result, dParent) {
  let d2 = mDiv(dParent, { display: 'flex', gap: 10, margin: 10, padding: 10, bg: 'white', fg: 'dimgray' });
  d2.setAttribute('username', result.username);
  let path = getProfileImagePath(result);
  let img = mImg(path, d2, { h: 50 });
  let d3 = mDiv(d2);
  let name = mText(result.username, d3);
  return d2;
}
function presentInContactMenu(result, d1) {
  let d2 = mDiv(d1, { position: 'relative' }, null, null, 'contact');
  d2.setAttribute('username', result.username);
  let dir = '../base/assets/images/';
  let path = dir + (result.hasImage ? result.username : 'unknown_user') + '.jpg';
  let img = mImg(path, d2, {});
  let name = mText(result.username, d2);
  return d2;
}
function presentItems(items, dParent, rows) {
  let dGrid = mDiv(dParent);
  items.map(x => mAppend(dGrid, x.div));
  let gridStyles = { 'place-content': 'center', gap: 4, margin: 4, padding: 4 };
  let gridSize = layoutGrid(items, dGrid, gridStyles, { rows: rows, isInline: true });
  return { dGrid: dGrid, sz: gridSize };
}
function presentLocationChange(oid, ms) {
  if (G.table[oid].obj_type == 'robber') {
    let o = G.table[oid];
    let changedProps = G.tableUpdated[oid];
    if (changedProps.summary.includes('loc')) {
      let oidLoc = o.loc._obj;
      let visLoc = getVisual(oidLoc);
      ms.setPos(visLoc.x, visLoc.y);
    }
  }
}
function presentLog() {
  let pl = G.player;
  let logId = 'a_d_log' + '_' + pl;
  if (!UIS[logId]) makeLogArea(pl);
  let d = document.getElementById(logId);
  let BASEMARGIN = 16;
  for (const k of G.logUpdated) {
    let logEntry = G.log[pl][k];
    let lineArr = logEntry.line;
    let lineDiv = document.createElement('div');
    lineDiv.style.marginLeft = '' + (BASEMARGIN * (logEntry.level)) + 'px';
    for (const item of lineArr) {
      if (isSimple(item)) {
        let s = trim(item.toString());
        if (!isEmpty(s)) {
          lineDiv.appendChild(document.createTextNode(item));
        }
      } else if (isDict(item)) {
        if (item.type == 'obj') {
          let oid = item.ID;
          let mobj = makeAux(item.val, oid, 'a_d_log', lineDiv);
        } else if (item.type == 'player') {
          let oid = item.val;
          let mobj = makeAux(item.val, oid, 'a_d_log', lineDiv);
        } else {
        }
      }
    }
    d.appendChild(lineDiv);
    d.scrollTop = d.scrollHeight;
  }
}
function presentMain(oid, mobj, pool, isTableObject = true) {
  if (mobj.isa.card) {
    let collKey = mobj.collectionKey;
    if (isdef(collKey)) {
    }
  }
  let o = pool[oid];
  let validKeys = computePresentedKeys(o, isTableObject);
  let color = S.settings.useColorHintForProperties ? getColorHint(o) : mobj.fg;
  let akku = [];
  for (const k of validKeys) {
    let val = o[k];
    if (isSimple(val)) akku.push(val.toString());
  }
  if (!isEmpty(akku)) { mobj.multitext({ txt: akku, fill: color }); } else mobj.clearText();
}
function presentMainMenu() {
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  S.gameInProgress = false;
  initDom();
  openTabTesting('Redmond');
}
function presentMainPlayer(oid, mobj, pool, isTableObject) {
  let o = pool[oid];
  if (!mobj) return;
  if (oid != G.player) { mobj.hide(); return; } else mobj.show();
  let optin = S.settings.player.optin;
  let optout = S.settings.player.optout;
  keys = optout ? arrMinus(getKeys(o), optout) : optin ? optin : getKeys(o);
  let x = mobj.tableX(o, keys);
  growIfDefaultMainAreaWidth(mobj);
  return x;
}
function presentMappings(oid, o) {
  let otype = o.obj_type;
  if (mappingTypes[otype]) {
    if (mappingsInitialized[otype + '.' + oid]) return;
    let mm = mappings.filter(x => x[otype]);
    let onlyOnce = false;
    for (const mapping of mm) {
      executeMapping(mapping, otype, oid, o);
    }
    if (onlyOnce) mappingsInitialized[otype + '.' + oid] = true;
  }
}
function presentNicely(oid, pool, ms) {
  let o_new = pool[oid];
  let akku = [];
  for (const prop in o_new) {
    let nval = o_new[prop];
    let sval = simpleRep(nval);
    akku.push(prop + ':' + sval);
  }
  ms.multitext({ txt: akku, fz: 12, fill: 'black' });
}
function presentNode(o, title, area, lstFlatten, lstShow, lstOmit = [], lstOmitTopLevel = []) {
  if (!isEmpty(lstOmitTopLevel)) {
    let oNew = {};
    for (const k in o) {
      if (lstOmitTopLevel.includes(k)) continue;
      oNew[k] = o[k];
    }
    o = oNew;
  }
  addIf(lstOmit, 'act');
  addIf(lstOmit, 'ui');
  addIf(lstOmit, 'live');
  let d = isString(area) ? mBy(area) : area;
  mNodeFilter(o, { dParent: d, title: title, lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
}
function presentNodes(sp, area, lf, ls, lo) {
  for (const k in sp) {
    presentAddNode(sp[k], k, area, lf, ls, lo);
  }
}
function presentOidNodes(R, area, lf, ls, lo) {
  for (const oid in R._sd) {
    let rsg = R.getR(oid);
    if (!isEmpty(rsg)) {
      let x = { rsg: rsg };
      presentAddNode(x, oid, area, ['rsg'], ls, lo);
    }
  }
}
function presentPlayer(id, ms, o_new, o_old, options) {
  let res = {};
  if (isdef(G.player)) res.color = G.players[G.player].color;
  return res;
}
function presentPlayers() {
  _playersCreateNew();
  _playersUpdate();
}
function presentPlayersSimple() { }
function presentRoot_dep(n, area, lf, ls, lo) {
  d = mBy(area);
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mColor(d1, colorTrans('black', i * .1));
  }
  addIf(lo, 'act');
  addIf(lo, 'ui');
  maxLevel = 1 + recPresentFilter(n, 0, dLevel, { lstFlatten: lf, lstShow: ls, lstOmit: lo });
}
function presentRootPresetLists_dep(n, area) {
  let lstFlatten = ['type', 'pool', 'source', 'data', 'content'];
  let lstShow = ['type', 'oid', 'data', 'content', 'pool'];
  let lstOmit = ['act', 'bi', 'sub', '_id', '_ref', 'children', 'source', 'specKey', 'params', 'cssParams', 'typParams', 'stdParams', 'uid', 'ui'];
  d = mBy(area);
  let level = 0;
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mColor(d1, colorTrans('black', i * .1));
  }
  maxLevel = 1 + recPresentFilter(n, 0, dLevel, { lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
  removeInPlace(lstOmit, 'children');
}
function presentServerData(sdata, area) {
  let d = mBy(area);
  clearElement(d);
  for (const [k, v] of Object.entries(sdata)) {
    mNode(v, { title: k, dParent: d, omitEmpty: true });
  }
}
function presentSimpleVal(d, item) {
  let d1 = mDiv(d, { display: 'inline-block', bg: 'random', rounding: 10, margin: 10, padding: 10 });
  d1.innerHTML = item;
}
function presentSpecAndCode(callbacks = []) {
  let d = document.getElementById('a_d_spec_content');
  if (S.user.spec && S.settings.userSettings) {
    d.innerHTML = S.user.specText;
  } else { d.innerHTML = ''; }
  d = document.getElementById('a_d_code_content');
  if (S.user.script && S.settings.userBehaviors) {
    d.innerHTML = S.user.script;
  } else { d.innerHTML = ''; }
  $('pre').html(function () {
    return this.innerHTML.replace(/\t/g, '&nbsp;&nbsp;');
  });
  if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
}
function presentState1(state, areas) {
  let trick1 = arrFlatten(state.pl1.trick)
  let trick2 = arrFlatten(state.pl2.trick);
  let pl1Hand = state.pl1.hand;
  let pl2Hand = state.pl2.hand;
  let arrs = [[trick1, trick2], [pl1Hand], [pl2Hand]];
  let hands = [];
  for (let i = 0; i < 3; i++) {
    let area = areas[i];
    let d = diContent(area);
    iMessage(area, '');
    for (let j = 0; j < arrs[i].length; j++) {
      let arr = arrs[i][j];
      let id = 'a' + i + '_h' + j;
      let what = iH00(arr, d, {}, id);
      hands.push(what);
    }
  }
  for (let i = 0; i < 2; i++) {
    let cards = hands[i].iHand.items;
    if (isEmpty(hands[i].arr)) continue;
    console.log('cards', cards, 'hands[i]', hands[i])
    for (let j = 0; j < cards.length - 1; j++) {
      Card52.turnFaceDown(cards[j]);
    }
  }
}
function presentStatus() {
  if (isdef(G.serverData.status)) {
    let lineArr = G.serverData.status.line;
    let areaName = isPlain() ? 'c_d_statusInHeaderText' : 'c_d_statusText';
    let d = document.getElementById(areaName);
    let mobj = UIS[areaName];
    mobj.clear(); clearElement(d);
    let pl = G.player;
    let msStatus = makeAux(G.playersAugmented[pl].username + ' (' + pl + ')', pl, areaName);
    let color = getPlayerColor(pl);
    msStatus.setBg(color);
    msStatus.setFg(colorIdealText(color));
    d.appendChild(document.createTextNode(': '));
    for (const item of lineArr) {
      if (isSimple(item)) {
        let s = trim(item.toString());
        if (!isEmpty(s)) {
          d.appendChild(document.createTextNode(item));
        }
      } else if (isDict(item)) {
        if (item.type == 'obj') {
          let oid = item.ID;
          let mobj = makeAux(item.val, oid, areaName);
        } else if (item.type == 'player') {
          let oid = item.val;
          let mobj = makeAux(item.val, oid, areaName);
        }
      }
    }
  }
}
function presentTable() {
  _tableRemove();
  _tableCreateNew();
  _tableUpdate();
}
function presentTableSimple() {
  _tableRemoveSimple();
  _tableCreateNewSimple();
  _tableUpdateSimple();
}
async function presentTree(uiRoot, R) {
  if (R.presentationStrategy == 'rec') {
    recPresentNode(uiRoot, R, uiRoot.params);
  } else if (R.presentationStrategy == 'new') {
    recMeasureOverride(R.tree.uid, R);
  } else if (R.presentationStrategy == 'orig') {
    if (uiRoot.params.sizing == 'sizeToContent') {
      recMeasureAbs(R.tree.uid, R);
      recArrangeContent(R.tree.uid, R);
    } else if (uiRoot.params.sizing == 'fixed') {
      let [minx, maxx, miny, maxy] = recMeasureArrangeFixedSizeAndPos(R.tree.uid, R);
      uiRoot.size = { w: maxx, h: maxy };
      uiRoot.ui.style.minWidth = (uiRoot.size.w + 4) + 'px';
      uiRoot.ui.style.minHeight = (uiRoot.size.h + 4) + 'px';
    } else {
      recMeasureOverride(R.tree.uid, R);
    }
  } else if (nundef(R.presentationStrategy)) {
    if (uiRoot.params.sizing == 'sizeToContent') {
      recMeasureAbs(R.tree.uid, R);
      recArrangeContent(R.tree.uid, R);
    } else if (uiRoot.params.sizing == 'fixed') {
      let [minx, maxx, miny, maxy] = recMeasureArrangeFixedSizeAndPos(R.tree.uid, R);
      uiRoot.size = { w: maxx, h: maxy };
      uiRoot.ui.style.minWidth = (uiRoot.size.w + 4) + 'px';
      uiRoot.ui.style.minHeight = (uiRoot.size.h + 4) + 'px';
    } else {
      recMeasureOverride(R.tree.uid, R);
    }
  } else {
    trace('UNKNOWN presentationStrategy!!!!!!', R.presentationStrategy)
  }
}
function presentTree_dep(n, treeProperty, area, R, lf, ls, lo) {
  d = mBy(area);
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mColor(d1, colorTrans('black', i * .1));
  }
  let nDict = R.rNodes;
  maxLevel = 1 + recPresent(n, 0, dLevel, nDict, treeProperty, { lstFlatten: lf, lstShow: ls, lstOmit: lo });
}
function presentVisible(id, ms, o_new, o_old, options) {
  let visPlayers = getVisibleList(o_new);
  let visColors = visPlayers.map(x => G.players[x].color);
  dots(ms, visColors.length, { UL: false, UR: true, colors: visColors });
}
function presentWaitingFor() {
  if (G.serverData.error) {
    alert(G.serverData.error.type + ' ' + G.serverData.error.msg);
    return;
  }
  let pl = G.serverData.waiting_for[0];
  if (nundef(G.previousWaitingFor) || G.previousWaitingFor != pl) {
    G.previousWaitingFor = pl;
    _updatePageHeader(pl);
  }
  if (S.settings.playmode != 'passplay' && (isMyPlayer(pl) || isFrontAIPlayer(pl) && isMyPlayer(G.player))) {
    let user = G.playersAugmented[pl].username;
    sendStatus(user, [gameStep]);
  } else if (S.settings.playmode == 'passplay') {
    _showPassToNextPlayer(pl);
  } else {
    socketEmitMessage({ type: 'poll', data: pl });
  }
}
function presentWordProblem() { }
function previewBrowsedFile(dParent, imgFile) {
  var imgView = document.createElement("div");
  imgView.className = "image-view";
  mAppend(dParent, imgView);
  var img = document.createElement("img");
  imgView.appendChild(img);
  var reader = new FileReader();
  reader.onload = function (e) {
    img.src = e.target.result;
    imgFile.data = e.target.result;
  }
  reader.readAsDataURL(imgFile);
}
function previewImageFromFile(imgFile, img) {
  var reader = new FileReader();
  reader.onload = function (e) {
    img.src = e.target.result;
    imgFile.data = e.target.result;
  }
  reader.readAsDataURL(imgFile);
}
function previewImageFromUrl(url, img) {
  img.onerror = function () {
    alert("Error in uploading");
  }
  img.crossOrigin = "";
  img.src = url;
}
function prex(x) {
  prll(expand(x));
}
function PRHLayout() {
  let drr = UI.DRR = mDiv(dTable);
  mAppend(drr, UI.dHistory);
  Clientdata.historyLayout = 'prh';
}
function print_board(gameArr) {
  console.log()
  for (i = 0; i < 9; i++) {
    let row = get_row(gameArr, i)
    if (i % 3 == 0) {
      console.log("|=======|=======|=======|")
    }
    console.log("|",
      print_cell(row[0]), print_cell(row[1]), print_cell(row[2]), "|",
      print_cell(row[3]), print_cell(row[4]), print_cell(row[5]), "|",
      print_cell(row[6]), print_cell(row[7]), print_cell(row[8]), "|")
  }
  console.log("|=======|=======|=======|")
}
function print_cell(value) {
  if (Array.isArray(value)) {
    return "."
  } else if (value == 0) {
    return "."
  } else {
    return value
  }
}
function printBoard(arr, rows, cols, reduced = true) {
  let arrR = boardArrOmitFirstRowCol(arr, rows, cols);
  let s = toBoardString(arrR, rows, cols);
  console.log('board', s);
}
function PrintBoard() {
  return;
  var sq, file, rank, piece;
  console.log("\nGame Board:\n");
  for (rank = RANKS.RANK_8; rank >= RANKS.RANK_1; rank--) {
    var line = ((rank + 1) + "  ");
    for (file = FILES.FILE_A; file <= FILES.FILE_H; file++) {
      sq = FR2SQ(file, rank);
      piece = brd_pieces[sq];
      line += (" " + PceChar[piece] + " ");
    }
    console.log(line);
  }
  console.log("");
  var line = "   ";
  for (file = FILES.FILE_A; file <= FILES.FILE_H; file++) {
    line += (' ' + String.fromCharCode('a'.charCodeAt() + file) + ' ');
  }
  console.log(line);
  console.log("side:" + SideChar[brd_side]);
  console.log("enPas:" + brd_enPas);
  line = "";
  if (brd_castlePerm & CASTLEBIT.WKCA) line += 'K';
  if (brd_castlePerm & CASTLEBIT.WQCA) line += 'Q';
  if (brd_castlePerm & CASTLEBIT.BKCA) line += 'k';
  if (brd_castlePerm & CASTLEBIT.BQCA) line += 'q';
  console.log("castle:" + line);
  console.log("key:" + brd_posKey.toString(16));
}
function printGameLine() {
  var moveNum = 0;
  var gameLine = "";
  for (moveNum = 0; moveNum < brd_hisPly; ++moveNum) {
    gameLine += PrMove(brd_history[moveNum].move) + " ";
  }
  return $.trim(gameLine);
}
function printMatrix(arr2d, title = 'result') {
  let rows = arr2d.length;
  let cols = arr2d[0].length;
  let arr = arrFlatten(arr2d);
  let s = toBoardString(arr, rows, cols);
  console.log(title, s)
}
function PrintMoveList() {
  var index;
  var move;
  console.log("MoveList:");
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    move = brd_moveList[index];
    console.log("Move:" + (index + 1) + " > " + PrMove(move));
  }
}
function PrintPceLists() {
  var piece, pceNum;
  for (piece = PIECES.wP; piece <= PIECES.bK; ++piece) {
    for (pceNum = 0; pceNum < brd_pceNum[piece]; ++pceNum) {
      console.log("Piece " + PceChar[piece] + " on " + PrSq(brd_pList[PCEINDEX(piece, pceNum)]));
    }
  }
}
function PrintPieceLists() {
  var piece, pceNum;
  for (piece = PIECES.wP; piece <= PIECES.bK; ++piece) {
    for (pceNum = 0; pceNum < BFBoard.pceNum[piece]; ++pceNum) {
      console.log('Piece ' + PceChar[piece] + ' on ' + PrSq(BFBoard.pList[PCEINDEX(piece, pceNum)]));
    }
  }
}
function PrintSqAttacked() {
  var sq, file, rank, piece;
  console.log("\nAttacked:\n");
  for (rank = RANKS.RANK_8; rank >= RANKS.RANK_1; rank--) {
    var line = ((rank + 1) + "  ");
    for (file = FILES.FILE_A; file <= FILES.FILE_H; file++) {
      sq = FR2SQ(file, rank);
      if (SqAttacked(sq, COLOURS.BLACK) == BOOL.TRUE) piece = "X";
      else piece = "-";
      line += (" " + piece + " ");
    }
    console.log(line);
  }
  console.log("");
}
function printState(state, cols, rows) {
  let formattedString = '';
  state.forEach((cell, index) => {
    formattedString += isdef(cell) ? ` ${cell == '0' ? ' ' : cell} |` : '   |';
    if ((index + 1) % cols == 0) {
      formattedString = formattedString.slice(0, -1);
      if (index < rows * cols - 1) {
        let s = '\u2015\u2015\u2015 '.repeat(cols);
        formattedString += '\n' + s + '\n';
      }
    }
  });
  console.log('%c' + formattedString, 'color: #6d4e42;font-size:10px');
  console.log();
}
function prj(j) { }
function prjstart(j) { }
function prlist(arr) {
  if (isList(arr)) {
    if (isEmpty(arr)) return '';
    else return '[' + prlist(arr[0]) + arr.slice(1).map(x => ',' + prlist(x)) + ']';
  } else return arr;
}
function prll(ll) {
  if (!isList(ll)) {
    testHelpers('NOT a list', ll);
    return;
  }
  for (const l of ll) {
    if (!isList(ll)) {
      return;
    }
  }
  let s = '[';
  for (const l of ll) {
    s += '[' + l.toString() + ']';
  }
  s += ']';
  testHelpers(s);
}
function PrMove(move) {
  var MvStr;
  var ff = FilesBrd[FROMSQ(move)];
  var rf = RanksBrd[FROMSQ(move)];
  var ft = FilesBrd[TOSQ(move)];
  var rt = RanksBrd[TOSQ(move)];
  MvStr = String.fromCharCode('a'.charCodeAt() + ff) + String.fromCharCode('1'.charCodeAt() + rf) +
    String.fromCharCode('a'.charCodeAt() + ft) + String.fromCharCode('1'.charCodeAt() + rt)
  var promoted = PROMOTED(move);
  if (promoted != PIECES.EMPTY) {
    var pchar = 'q';
    if (PieceKnight[promoted] == BOOL.TRUE) {
      pchar = 'n';
    } else if (PieceRookQueen[promoted] == BOOL.TRUE && PieceBishopQueen[promoted] == BOOL.FALSE) {
      pchar = 'r';
    } else if (PieceRookQueen[promoted] == BOOL.FALSE && PieceBishopQueen[promoted] == BOOL.TRUE) {
      pchar = 'b';
    }
    MvStr += pchar;
  }
  return MvStr;
}
function ProbePvTable() {
  var index = brd_posKey % PVENTRIES;
  if (brd_PvTable[index].posKey == brd_posKey) {
    return brd_PvTable[index].move;
  }
  return NOMOVE;
}
function proceed(nextLevel) {
  if (nundef(nextLevel)) nextLevel = currentLevel;
  if (nextLevel > MAXLEVEL) {
    let iGame = gameSequence.indexOf(currentGame) + 1;
    if (iGame == gameSequence.length) {
      soundGoodBye();
      mClass(document.body, 'aniSlowlyDisappear');
      show(dLevelComplete);
      dLevelComplete.innerHTML = 'CONGRATULATIONS! You are done!';
    } else {
      let nextGame = gameSequence[iGame];
      startGame(nextGame);
    }
  } else if (LevelChange) startLevel(nextLevel);
  else startRound();
}
function proceed_to_newcards_selection() {
  let fen = Z.fen;
  let selorder = fen.selorder = sortByFuncDescending(fen.church_order, x => fen.players[x].tithes.val);
  fen.toBeSelected = jsCopy(selorder);
  fen.plorder = selorder;
  Z.turn = [selorder[0]];
  Z.stage = 19;
  take_turn_fen();
}
function proceedIfNotStepByStep(nextLevel) {
  if (!StepByStepMode) { proceed(nextLevel); }
}
function proceedRedraw() {
  flags.specAndDOM = true;
  let xdata = G.serverData;
  G = { table: {}, players: {}, signals: {} };
  UIS = {};
  IdOwner = {};
  id2oids = {};
  oid2ids = {};
  id2uids = {};
  initDom();
  gameStep(xdata);
}
function proceedToConfig() {
  populateGamenames();
  hideEventList();
  showGameConfig();
  setMessage('Setup new game!');
  hide('bJoinGame');
  hide('bCreateGame');
  show('bLobbyOk');
  show('bLobbyCancel');
  show('bResumeGame');
  updateGamename(S.settings.game);
  updatePlayersForGame();
  updatePlaymode(S.settings.playmode);
  updatePlayersForMode();
}
function process_auction() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  if (isEmpty(A.selected)) A.selected = [0];
  let playerbid = Number(valf(A.items[A.selected[0]].a, '0'));
  lookupSet(fen, ['auction', uplayer], playerbid);
  let iturn = fen.plorder.indexOf(uplayer) + 1;
  if (iturn >= fen.plorder.length) {
    let list = dict2list(fen.auction, 'uplayer');
    list = sortByDescending(list, 'value');
    let max = list[0].value;
    if (max == 0) {
      Z.stage = 4;
      Z.turn = [fen.plorder[0]];
      take_turn_fen();
      return;
    }
    let second = fen.second_most = list.length == 1 ? randomNumber(0, max) : list[1].value;
    Z.stage = 13;
    let maxplayers = fen.maxplayers = list.filter(x => x.value == max).map(x => x.uplayer);
    Z.turn = [maxplayers[0]];
    for (const plname of plorder) {
      ari_history_list([`${plname} bids ${fen.auction[plname]}`], 'auction');
    }
    ari_history_list([`auction winner${if_plural(fen.maxplayers.length)}: ${fen.maxplayers.join(', ')} (price: ${fen.second_most} coin)`], 'auction');
  } else {
    Z.turn = [fen.plorder[iturn]];
  }
  take_turn_fen();
}
function process_blackmail() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  console.log('selected building to blackmail:', item);
  let building_owner = stringAfter(item.o.path, '.'); building_owner = stringBefore(building_owner, '.');
  let path = item.o.path;
  fen.blackmail = { blackmailer: uplayer, blackmailed: building_owner, payment: A.payment, building_path: path };
  let fenbuilding = lookup(fen, path.split('.'));
  console.log('blackmail:', fen.blackmail);
  fenbuilding.isblackmailed = true;
  ari_history_list([`${uplayer} is blackmailing ${building_owner}`], 'blackmail');
  [Z.stage, Z.turn] = [33, [building_owner]];
  console.log('hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')
  process_payment();
  setTimeout(take_turn_fen, 1000);
}
function process_comm_setup() {
  let [fen, A, uplayer, plorder, pl] = [Z.fen, Z.A, Z.uplayer, Z.plorder, Z.pl];
  assertion(fen.keeppolling == true, "keeppolling must be true for process_comm_setup!!!");
  if (DA.hallo) {
    console.log('process_comm_setup:', Z.playerdata, Z.stage, uplayer, pl);
    return;
  }
  let items = A.selected.map(x => A.items[x]);
  let next = get_next_player(Z, uplayer);
  let receiver = next;
  let giver = uplayer;
  let keys = items.map(x => x.key);
  Z.state = { giver: giver, receiver: receiver, keys: keys };
  assertion(isdef(Z.playerdata), "Z.playerdata must be defined for process_comm_setup!!!");
  let data = firstCond(Z.playerdata, x => x.name == uplayer);
  assertion(isdef(data), `MISSING: playerdata for ${uplayer}`);
  data.state = Z.state;
  let can_resolve = check_resolve();
  if (can_resolve) {
    Z.turn = [Z.host];
    Z.stage = 104; 
    take_turn_fen_write();
  } else {
    if (Z.mode == 'hotseat') { Z.turn = [get_next_player(Z, uplayer)]; take_turn_fen_write(); }
    else take_turn_multi();
  }
}
function process_command() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let item = A.last_selected;
  if (nundef(item)) { post_pass(); return; }
  A.selected = [item.index];
  let a = A.items[A.selected[0]];
  A.command = a.key;
  ari_pre_action();
}
function process_commission() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  A.commission = A.items[A.selected[0]];
  if (A.commission.similar.length > 1) {
    Z.stage = 37;
  } else {
    A.commission_stall_item = A.commission.similar[0];
    Z.stage = 16;
  }
  ari_pre_action();
}
function process_commission_stall() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  console.log('process_commission_stall selected', A.selected, 'item', A.items[A.selected[0]]);
  Z.A.commission_stall_item = A.items[A.selected[0]];
  Z.stage = 16;
  ari_pre_action();
}
function process_downgrade() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  A.building = A.items[A.selected[0]];
  fen.stage = Z.stage = 103;
  let items = ui_get_hidden_building_items(A.building.o);
  items.map(x => face_up(x.o));
  A.possible_downgrade_cards = items;
  ari_pre_action();
}
function process_inspect() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let cards = item.o.items;
  cards.map(x => face_up(x))
  weiter_process_inspect();
}
function process_journey() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  if (isEmpty(A.selected)) {
    if (nundef(fen.passed)) fen.passed = []; fen.passed.push(uplayer);
    [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
    take_turn_fen();
    return;
  }
  let sel = A.selected.map(x => A.items[x].key);
  let [carditems, journeyitem, jlegal] = check_correct_journey(A, fen, uplayer);
  if (!carditems) return;
  delete fen.passed;
  [A.carditems, A.journeyitem, A.jlegal] = [carditems, journeyitem, jlegal];
  Z.stage = A.journeyitem ? 30 : 31;
  ari_pre_action();
}
function process_payment() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let item = A.payment;
  is_coin_pay = nundef(item.o);
  if (is_coin_pay) a2_pay_with_coin(uplayer); else a2_pay_with_card(item);
  ari_history_list(get_pay_history(is_coin_pay ? 'coin' : item.o.key, uplayer), 'payment');
  A.payment_complete = true;
  return is_coin_pay;
}
function process_rumor() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let items = A.selected.map(x => A.items[x]);
  let building = firstCond(items, x => x.path.includes('building'));
  let rumor = firstCond(items, x => !x.path.includes('building'));
  if (nundef(building) || nundef(rumor)) {
    select_error('you must select exactly one building and one rumor card!');
    return;
  }
  let fenbuilding = lookup(fen, building.path.split('.'));
  lookupAddToList(fenbuilding, ['rumors'], rumor.key);
  removeInPlace(fen.players[uplayer].rumors, rumor.key);
  ari_history_list([`${uplayer} added rumor to ${ari_get_building_type(fenbuilding)}`,], 'rumor');
  ari_next_action(fen, uplayer);
}
function process_rumor_discard() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  console.log('.........items', A.items, A.selected, item);
  let rumor = item.key;
  removeInPlace(fen.players[uplayer].rumors, rumor);
  ari_history_list([`building is correct! ${uplayer} had to discard rumor (${rumor})`], 'rumor');
  ari_next_action();
}
function process_rumors_setup() {
  let [fen, A, uplayer, plorder, data] = [Z.fen, Z.A, Z.uplayer, Z.plorder, Z.uplayer_data];
  let items = A.selected.map(x => A.items[x]);
  let receiver = firstCond(items, x => plorder.includes(x.key)).key;
  let rumor = firstCond(items, x => !plorder.includes(x.key));
  if (nundef(receiver) || nundef(rumor)) {
    select_error('you must select exactly one player and one rumor card!');
    return;
  }
  assertion(isdef(data), 'no data for player ' + uplayer);
  rumor_update_playerdata(data, receiver, rumor);
  let playerdata_complete = rumor_playerdata_complete();
  if (playerdata_complete) {
    Z.turn = [Z.host];
    Z.stage = 105; 
    clear_transaction();
    take_turn_fen_write();
  } else if (isEmpty(data.state.remaining)) {
    clear_transaction();
    take_turn_write();
  } else {
    add_transaction('rumorsetup');
    take_turn_write();
  }
}
function process_upgrade() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let n = A.selected.length;
  if (n > 2 || n == 2 && !has_farm(uplayer)) {
    select_error('too many cards selected!');
    return;
  } else if (n == 0) {
    select_error('please select hand or stall card(s) to upgrade!');
    return;
  }
  A.upgrade_cards = A.selected.map(x => A.items[x]);
  Z.stage = fen.stage = 102;
  ari_pre_action();
}
function process_visit() {
  alert('NOT IMPLEMENTED!');
  process_payment();
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let item = A.items[A.selected[0]];
  let obuilding = lookup(fen, item.path.split('.'));
  let parts = item.path.split('.');
  let owner = parts[1];
  if (isdef(obuilding.schweine)) {
    Z.stage = 46;
    A.building = item;
    A.obuilding = obuilding;
    A.buildingowner = owner;
    ari_pre_action();
    return;
  } else {
    let cards = item.o.items;
    let key = cards[0].rank;
    for (const c of cards) {
      if (c.rank != key) { schweine = true; schweine = c.key; face_up(c); break; }
    }
    if (schweine) {
      if (fen.players[owner].coins > 0) {
        fen.players[owner].coins--;
        fen.players[uplayer].coins++;
      }
      let b = lookup(fen, item.path.split('.'));
      b.schweine = schweine;
    }
    ari_history_list([
      `${uplayer} visited ${ari_get_building_type(obuilding)} of ${owner} resulting in ${schweine ? 'schweine' : 'ok'} ${ari_get_building_type(obuilding)}`,
    ], 'visit');
  }
}
function processActions(data) {
  if (nundef(G.serverData.options)) { G.tupleGroups = null; return false; }
  G.tupleGroups = getTupleGroups();
  return true;
}
function processCsvData(allText) {
  var numHeadings = 5;
  var allTextLines = allText.split(/\r\n|\n/);
  var headings = allTextLines[0].split(',');
  numHeadings = headings.length;
  let entries = allTextLines.splice(1);
  var records = { headings: headings };
  for (const e of entries) {
    let o = {};
    let values = e.split(',');
    for (let i = 0; i < numHeadings; i++) {
      let k = headings[i];
      o[k] = values[i];
    }
    o.order = Number(last(values));
    records[o.hexcode] = o;
  }
  return records;
}
function processCsvData_from_CBII(allText) {
  var numHeadings = 5;
  var allTextLines = allText.split(/\r\n|\n/);
  var headings = allTextLines[0].split(',');
  numHeadings = headings.length;
  let entries = allTextLines.splice(1);
  var records = { headings: headings };
  var recordsByName = {};
  for (const e of entries) {
    let o = {};
    let values = e.split(',');
    for (let i = 0; i < numHeadings; i++) {
      let k = headings[i];
      o[k] = values[i];
    }
    records[o.hexcode] = o;
    recordsByName[o.annotation] = o.hexcode;
  }
  return { records: records, recordsByName: recordsByName };
}
function processData(data) {
  if (G.end) {
    stopBlinking('a_d_status');
    stopInteraction();
    clearLog();
  }
  S.gameInProgress = true;
  G.serverData = data;
  G.phase = G.serverData.phase;
  processTable(data);
  processPlayers(data);
  if (!S_useSimpleCode) updateCollections();
  processLog(data);
  if (processEnd(data)) return;
  if (!processActions(data)) { processWaitingFor(); }
}
function processEnd(data) {
  G.end = data.end;
  if (G.end) {
    if (G.signals.receivedEndMessage) delete G.signals.receivedEndMessage;
    else socketEmitMessage({ type: 'end', data: G.player });
    setAutoplayFunctionForMode();
  }
  return G.end;
}
function processLocOids(cycle, max_cycles, isCyclic, R) {
  if (isEmpty(cycle)) return;
  let cycles = 0;
  let locOids = cycle;
  if (isCyclic) {
    let i = 0; let top = null;
    while (isEmpty(top)) {
      let oid = cycle[i];
      top = einhaengen(oid, R.getO(oid), R);
      if (!isEmpty(top)) break;
      i += 1; if (i > cycle.length - 1) break;
    }
    if (i > cycle.length - 1) {
      return;
    }
    locOids = arrRotate(cycle, i);
  }
  while (true) {
    cycles += 1;
    if (cycles > max_cycles) {
      return;
    }
    let changed = false;
    for (const oid of locOids) {
      let top = einhaengen(oid, R.getO(oid), R);
      if (!isEmpty(top)) {
        changed = true;
      }
    }
    if (!changed) { break; }
  }
}
function processLog(data) {
  if (!G.log) G.log = {};
  let pl = G.player;
  if (!G.log[pl]) G.log[pl] = {};
  let dict = G.log[pl];
  G.logUpdated = [];
  if (isdef(data.log)) {
    for (const logEntry of data.log) {
      let key = '' + logCounter + '_' + logEntry.line.map(x => isSimple(x) ? x : x.val).join(' ');
      logCounter += 1;
      if (dict[key]) continue;
      dict[key] = logEntry;
      G.logUpdated.push(key);
    }
  }
}
function processMessage(msg) {
  console.log('*** processMessage *** message is:\n', msg);
  let omsg = tryConvertToJSON(msg);
  if (omsg) {
    let msgType = omsg.type;
    console.log('got message', msgType, omsg);
    if (omsg.type == 'gc') {
      S.gameConfig = omsg.data;
      addMessage('updated game configuration!');
    } else if (omsg.type == 'started') {
      addMessage(omsg.data);
      if (iAmInGame() && !iAmStarter()) {
        console.log('I,', USERNAME, 'am in the game!!!!!')
        _startNewGame('joiner');
      }
    } else if (omsg.type == 'poll') {
      let pl = omsg.data;
      if (isMyPlayer(pl)) {
        let uname = getUsernameForPlayer(pl);
        sendStatus(uname, [gameStep]);
      }
    } else if (omsg.type == 'end') {
      console.log('received end!!!');
      G.signals.receivedEndMessage = true;
      let pl = omsg.data;
      if (!isMyPlayer(pl)) {
        let uname = getUsernameForPlayer(pl);
        sendStatus(uname, [gameStep]);
      }
    }
    return;
  }
  addMessage(msg);
  let parts = msg.split(' ');
  if (parts.length > 3 && startsWith(parts[1], 'join')) {
    let uname = parts[0];
    let plid = parts[3].trim();
    let players = S.gameConfig.players;
    let plChosen = firstCond(players, x => x.id == plid);
    if (plChosen) {
      if (isJoinMenuOpen()) closeJoinConfig();
      plChosen.username = uname;
      if (checkGameConfigComplete() && iAmStarter()) {
        _startNewGame('starter');
      }
    }
  }
}
function processPlayerChange() {
  if (isdef(G.serverData.end)) return;
  let players = G.serverData.players;
  let player = null;
  for (const plid in players) {
    let pl = players[plid];
    if (pl.obj_type == 'GamePlayer') {
      player = plid;
      break;
    }
  }
  if (!player) {
    error('NO GamePlayer obj_type in G.serverData.players!!!!!!!!!!!!!');
  }
  if (player != G.player) {
    G.player = player;
    G.playerChanged = true;
    setBackgroundToPlayerColor();
  } else {
    delete G.playerChanged;
  }
}
function processPlayers(data) {
  if (!S.players) _initPlayers();
  G.playersCreated = [];
  G.playersRemoved = [];
  G.playersUpdated = {};
  G.previousPlayer = G.player;
  let canProceed = false;
  delete G.playerChanged;
  if (data.players) {
    let plkeys = union(Object.keys(G.players), Object.keys(data.players));
    for (id of plkeys) {
      let pl_new = id in data.players ? data.players[id] : null;
      let pl_old = id in G.players ? G.players[id] : null;
      let changes = propDiffSimple(pl_old, pl_new);
      if (changes.hasChanged) {
        G.playersUpdated[id] = changes;
        if (nundef(pl_old)) {
          G.playersCreated.push(id);
        } else if (nundef(pl_new)) {
          G.playersRemoved.push(id);
        }
      }
      if (pl_new.obj_type == 'GamePlayer') {
        if (id != G.previousPlayer) G.playerChanged = true;
        if (nundef(G.player) || isMyPlayer(id) || G.player == id || isMyPlayer(G.previousPlayer) && isFrontAIPlayer(id)) {
          G.player = id;
          G.playerIndex = S.players[id].index;
          canProceed = true;
        } else {
        }
      }
    }
    G.players = data.players;
    G.playersAugmented = jsCopy(G.players);
    for (const pl in G.players) {
      G.playersAugmented[pl].color = S.players[pl].color;
      G.playersAugmented[pl].altName = S.players[pl].altName;
      G.playersAugmented[pl].id = pl;
      G.playersAugmented[pl].index = S.players[pl].index;
      G.playersAugmented[pl].username = S.players[pl].username;
      G.playersAugmented[pl].playerType = S.players[pl].playerType;
      G.playersAugmented[pl].agentType = S.players[pl].agentType;
    }
  }
  return canProceed;
}
function processServerdata(obj, cmd) {
  if (isdef(Serverdata.table)) Serverdata.prevtable = jsCopy(Serverdata.table);
  if (isdef(obj.playerdata)) {
    let old_playerdata = valf(Serverdata.playerdata, []);
    let di = list2dict(old_playerdata, 'name');
    Serverdata.playerdata = if_stringified(obj.playerdata);
    Serverdata.playerdata_changed_for = [];
    for (const o of Serverdata.playerdata) {
      let old = di[o.name];
      o.state = isEmpty(o.state) ? '' : if_stringified(o.state);
      let changed = nundef(old) ? true : !simpleCompare(old, o);
      if (changed) {
        Serverdata.playerdata_changed_for.push(o.name);
      }
    }
  } else if (isdef(Serverdata.playerdata)) {
    Serverdata.playerdata_changed_for = Serverdata.playerdata.map(x => x.name);
    Serverdata.playerdata = [];
  } else Serverdata.playerdata_changed_for = [];
  for (const k in obj) {
    if (k == 'tables') Serverdata.tables = obj.tables.map(x => unpack_table(x));
    else if (k == 'table') { Serverdata.table = unpack_table(obj.table); }
    else if (k == 'users') Serverdata[k] = obj[k];
    else if (k == 'playerdata') continue;
    else if (cmd != 'assets') Serverdata[k] = obj[k];
  }
  if (isdef(obj.table)) {
    assertion(isdef(Serverdata.table) && obj.table.id == Serverdata.table.id, 'table NOT in Serverdata or table id mismatch');
    let i = Serverdata.tables.findIndex(x => x.id == obj.table.id);
    if (i != -1) { Serverdata.tables[i] = Serverdata.table; } else Serverdata.tables.push(Serverdata.table);
  }
  else if (isdef(Serverdata.table)) {
    let t = Serverdata.tables.find(x => x.id == Serverdata.table.id);
    if (nundef(t)) delete Serverdata.table;
  }
}
function processStatus() {
  if (isdef(G.serverData.status)) {
    let msg = G.serverData.status;
    if (Array.isArray(msg)) {
      msg = msg[0];
    }
    if (typeof msg == 'object') msg = msg.line;
    if (Array.isArray(msg)) msg = msg.join('');
    msg = G.players[G.player].name + ', ' + msg;
    setStatus(msg);
  }
}
function processTable(data) {
  if (!G.table) G.table = {};
  G.tableCreated = [];
  G.tableRemoved = [];
  G.tableUpdated = {};
  if (data.table) {
    let allkeys = union(Object.keys(G.table), Object.keys(data.table));
    for (id of allkeys) {
      let o_new = id in data.table ? data.table[id] : null;
      let o_old = id in G.table ? G.table[id] : null;
      let changes = propDiffSimple(o_old, o_new);
      if (changes.hasChanged) {
        G.tableUpdated[id] = changes;
        if (nundef(o_old)) {
          G.tableCreated.push(id);
        } else if (nundef(o_new)) {
          G.tableRemoved.push(id);
        }
      }
    }
    G.table = data.table;
  }
}
function processWaitingFor() {
  if (nundef(G.serverData.waiting_for)) {
    error('No options AND No waiting_for data!!!!!!!!!!');
    return;
  }
}
function PROMOTED(m) { return (((m) >> 20) & 0xF); }
function prompt() {
  QuestionCounter += 1;
  showStats();
  G.trialNumber = 0;
  G.instance.prompt();
}
function promptML() {
  showPictures(false, () => fleetingMessage('just enter the missing letter!'));
  setGoal();
  showInstruction(bestWord, currentLanguage == 'E' ? 'complete' : "ergänze", dTitle, true);
  mLinebreak(dTable);
  let style = { margin: 6, fg: 'white', display: 'inline', bg: 'transparent', align: 'center', border: 'transparent', outline: 'none', family: 'Consolas', fz: 80 };
  let d = createLetterInputs(bestWord.toUpperCase(), dTable, style);
  let indices = getIndicesCondi(bestWord, (x, i) => isAlphaNum(x) && i <= MaxPosMissing);
  nMissing = Math.min(indices.length, NumMissingLetters);
  let ilist = choose(indices, nMissing); sortNumbers(ilist);
  for (const idx of ilist) {
    let inp = d.children[idx];
    inp.innerHTML = '_';
    mClass(inp, 'blink');
    inputs.push({ letter: bestWord[idx].toUpperCase(), div: inp, index: idx });
  }
  mLinebreak(dTable);
  showFleetingMessage(composeFleetingMessage(), 3000);
  return 10;
}
function promptNextTrial() {
  QuestionCounter += 1;
  clearTimeout(TOTrial);
  uiActivated = false;
  let delay = G.instance.trialPrompt(G.trialNumber);
  TOMain = setTimeout(activateUi, delay);
}
function promptSP() {
  showPictures(true, () => mBy(defaultFocusElement).focus());
  setGoal();
  showInstruction(bestWord, currentLanguage == 'E' ? 'say:' : "sage: ", dTitle);
  mLinebreak(dTable);
  MicrophoneUi = mMicrophone(dTable);
  return 10;
}
function promptSPA() {
  showPictures(true, () => mBy(defaultFocusElement).focus(), undefined, [currentKeys[NextPictureIndex]]);
  NextPictureIndex += 1;
  setGoal();
  showInstruction(bestWord, currentLanguage == 'E' ? 'say:' : "sage: ", dTitle);
  mLinebreak(dTable);
  MicrophoneUi = mMicrophone(dTable);
  return 10;
}
function promptStart() {
  beforeActivationUI();
  isINTERRUPT = false;
  dTable = dLineTableMiddle;
  dTitle = dLineTitleMiddle;
  if (nundef(dTable)) return;
  clearTable();
  let delay = GFUNC[currentGame].prompt();
  setTimeout(activateUi, delay);
}
function promptTC() {
  let colors = choose(SIMPLE_COLORS, NumColors);
  showPictures(false, evaluate, colors);
  setGoal(randomNumber(0, NumPics * colors.length - 1));
  Goal.correctionPhrase = Goal.shade + ' ' + Goal.label;
  let spoken = `click the ${Goal.shade} ${bestWord}`;
  showInstruction(bestWord, `click the <span style='color:${Goal.shade}'>${Goal.shade.toUpperCase()}</span>`,
    dTitle, true, spoken);
  return 10;
}
function promptTP() {
  showPictures(false, evaluate);
  setGoal();
  showInstruction(bestWord, 'click', dTitle, true);
  return 10;
}
function promptWP() {
  showPictures(true, () => mBy(defaultFocusElement).focus());
  setGoal();
  showInstruction(bestWord, currentLanguage == 'E' ? 'type' : "schreib'", dTitle, true);
  mLinebreak(dTable);
  inputBox = addNthInputElement(dTable, trialNumber);
  defaultFocusElement = inputBox.id;
  return 10;
}
function propDiff(o_old, o_new) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  for (const prop in o_new) {
    if (o_new.hasOwnProperty(prop)) {
      if (!(prop in o_old)) {
        addIf_dep(prop, onlyNew);
        addIf_dep(prop, summary);
        hasChanged = true;
      } else if (o_new[prop] != o_old[prop]) {
        if (prop == 'visible') {
          let visOld = getVisibleSet(o_old);
          let visNew = getVisibleSet(o_new);
          if (sameList(visOld, visNew)) {
            continue;
          }
        } else if (typeof o_new[prop] == 'object') {
          if (hasSameProps(o_new[prop], o_old[prop])) {
            continue;
          }
        }
        addIf_dep({ prop: prop, old: o_old[prop], new: o_new[prop] }, propChange);
        addIf_dep(prop, summary);
        hasChanged = true;
      }
    }
  }
  for (const prop in o_old) {
    if (o_old.hasOwnProperty(prop)) {
      if (!(prop in o_new)) {
        addIf_dep(prop, onlyOld);
        addIf_dep(prop, summary);
        hasChanged = true;
      }
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propDiffFast_dep(o_old, o_new, deepCheck = false, optInOut = {}) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  for (const prop in o_new) {
    if (fundef(optInOut[prop])) continue;
    let nprop = o_new[prop];
    let oprop = o_old[prop];
    if (isdef(nprop)) {
      let nval = o_new[prop];
      if (nundef(oprop)) {
        addIf(onlyNew, prop);
        addIf(summary, prop);
        hasChanged = true;
      } else if (nval != o_old[prop]) {
        if (!isSimple(nval)) {
          if (!deepCheck) continue;
          if (JSON.stringify(nval) == JSON.stringify(o_old[prop])) {
            console.log(JSON.stringify(nval), JSON.stringify(o_old[prop]));
            continue;
          }
        }
        addIf(propChange, { prop: prop, old: o_old[prop], new: o_new[prop] });
        addIf(summary, prop);
        hasChanged = true;
      }
    }
  }
  for (const prop in o_old) {
    if (fundef(optInOut[prop])) continue;
    if (nundef(o_new[prop])) {
      addIf(onlyOld, prop);
      addIf(summary, prop);
      hasChanged = true;
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propDiffGSM_dep(o_old, o_new, deepCheck = false, optInOut = {}) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  for (const prop in o_new) {
    if (fundef(optInOut[prop])) continue;
    let nprop = o_new[prop];
    let oprop = o_old[prop];
    if (isdef(nprop)) {
      let nval = o_new[prop];
      if (nundef(oprop)) {
        addIf(onlyNew, prop);
        addIf(summary, prop);
        hasChanged = true;
      } else if (nval != o_old[prop]) {
        if (!deepCheck && !isSimple(nval)) continue;
        if (prop == 'visible') {
          console.log('visibility', nval);
          let visOld = getVisibleList(o_old);
          let visNew = getVisibleList(o_new);
          if (sameList(visOld, visNew)) continue;
        } else if (typeof nval == 'object' && sameProps(nval, o_old[prop])) {
          continue;
        } else if (isList(nval) && sameList(nval, o_old[prop])) {
          continue;
        }
        addIf(propChange, { prop: prop, old: o_old[prop], new: o_new[prop] });
        addIf(summary, prop);
        hasChanged = true;
      }
    }
  }
  for (const prop in o_old) {
    if (fundef(optInOut[prop])) continue;
    if (nundef(o_new[prop])) {
      addIf(onlyOld, prop);
      addIf(summary, prop);
      hasChanged = true;
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propDiffPlus_dep(o_old, o_new, deepCheck = false, optInOut = {}) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  for (const prop in o_new) {
    if (fundef(optInOut[prop])) continue;
    let nprop = o_new[prop];
    let oprop = o_old[prop];
    if (isdef(nprop)) {
      let nval = o_new[prop];
      if (nundef(oprop)) {
        addIf(onlyNew, prop);
        addIf(summary, prop);
        hasChanged = true;
      } else if (nval != o_old[prop]) {
        if (!deepCheck && !isSimple(nval)) continue;
        if (typeof nval == 'object' && hasSameProps(nval, o_old[prop])) {
          continue;
        } else if (isList(nval) && sameList(nval, o_old[prop])) {
          continue;
        }
        addIf(propChange, { prop: prop, old: o_old[prop], new: o_new[prop] });
        addIf(summary, prop);
        hasChanged = true;
      }
    }
  }
  for (const prop in o_old) {
    if (fundef(optInOut[prop])) continue;
    if (nundef(o_new[prop])) {
      addIf(onlyOld, prop);
      addIf(summary, prop);
      hasChanged = true;
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propDiffSimple(o_old, o_new, props = null) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  if (!o_old) {
    return { onlyOld: [], onlyNew: Object.keys(o_new), propChange: [], summary: Object.keys(o_new), hasChanged: true };
  } else if (!o_new) {
    return { onlyOld: Object.keys(o_old), onlyNew: [], propChange: [], summary: Object.keys(o_old), hasChanged: true };
  }
  if (nundef(props)) props = union(Object.keys(o_old), Object.keys(o_new));
  for (const prop of props) {
    let nval = o_new[prop];
    let oval = o_old[prop];
    if (isdef(nval) && isdef(oval)) {
      if (nval == oval) continue;
      else if (typeof nval == 'object' && sameStringify(nval, oval)) {
        continue;
      } else if (isList(nval) && sameList(nval, oval)) {
        continue;
      }
      addIf(propChange, { prop: prop, old: oval, new: nval });
      addIf(summary, prop);
      hasChanged = true;
    } else if (nundef(oval)) {
      addIf(onlyNew, prop);
      addIf(summary, prop);
      hasChanged = true;
    } else if (nundef(nval)) {
      addIf(onlyOld, prop);
      addIf(summary, prop);
      hasChanged = true;
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propertyGiver(o, prop, setter, getter) {
  Object.defineProperty(o, prop, {
    get: function () { return getter(); },
    set: function (val) { setter(val); }
  });
}
function propertyGiverW0(o, prop, setter) {
  Object.defineProperty(o, prop, {
    get: function () { return this.val; },
    set: function (val) { setter(val); }
  });
}
function PrSq(sq) {
  var file = FilesBrd[sq];
  var rank = RanksBrd[sq];
  var sqStr = String.fromCharCode('a'.charCodeAt() + file) + String.fromCharCode('1'.charCodeAt() + rank);
  return sqStr;
}
function pSBC(p, c0, c1, l) {
  let r, g, b, P, f, t, h, i = parseInt, m = Math.round, a = typeof c1 == 'string';
  if (typeof p != 'number' || p < -1 || p > 1 || typeof c0 != 'string' || (c0[0] != 'r' && c0[0] != '#') || (c1 && !a)) return null;
  h = c0.length > 9;
  h = a ? (c1.length > 9 ? true : c1 == 'c' ? !h : false) : h;
  f = pSBCr(c0);
  P = p < 0;
  t = c1 && c1 != 'c' ? pSBCr(c1) : P ? { r: 0, g: 0, b: 0, a: -1 } : { r: 255, g: 255, b: 255, a: -1 };
  p = P ? p * -1 : p;
  P = 1 - p;
  if (!f || !t) return null;
  if (l) { r = m(P * f.r + p * t.r); g = m(P * f.g + p * t.g); b = m(P * f.b + p * t.b); }
  else { r = m((P * f.r ** 2 + p * t.r ** 2) ** 0.5); g = m((P * f.g ** 2 + p * t.g ** 2) ** 0.5); b = m((P * f.b ** 2 + p * t.b ** 2) ** 0.5); }
  a = f.a;
  t = t.a;
  f = a >= 0 || t >= 0;
  a = f ? (a < 0 ? t : t < 0 ? a : a * P + t * p) : 0;
  if (h) return 'rgb' + (f ? 'a(' : '(') + r + ',' + g + ',' + b + (f ? ',' + m(a * 1000) / 1000 : '') + ')';
  else return '#' + (4294967296 + r * 16777216 + g * 65536 + b * 256 + (f ? m(a * 255) : 0)).toString(16).slice(1, f ? undefined : -2);
}
function pSBCr(d) {
  let i = parseInt, m = Math.round, a = typeof c1 == 'string';
  let n = d.length,
    x = {};
  if (n > 9) {
    ([r, g, b, a] = d = d.split(',')), (n = d.length);
    if (n < 3 || n > 4) return null;
    (x.r = parseInt(r[3] == 'a' ? r.slice(5) : r.slice(4))), (x.g = parseInt(g)), (x.b = parseInt(b)), (x.a = a ? parseFloat(a) : -1);
  } else {
    if (n == 8 || n == 6 || n < 4) return null;
    if (n < 6) d = '#' + d[1] + d[1] + d[2] + d[2] + d[3] + d[3] + (n > 4 ? d[4] + d[4] : '');
    d = parseInt(d.slice(1), 16);
    if (n == 9 || n == 5) (x.r = (d >> 24) & 255), (x.g = (d >> 16) & 255), (x.b = (d >> 8) & 255), (x.a = m((d & 255) / 0.255) / 1000);
    else (x.r = d >> 16), (x.g = (d >> 8) & 255), (x.b = d & 255), (x.a = -1);
  }
  return x;
}
function pTest0() {
  let state = DB.tables.t0;
  console.log('state', state);
  let dMiddle = makePage();
  mStyle(dMiddle, { padding: 20, overflow: 'auto' });
  mCenterCenterFlex(dMiddle)
  let dTable = mDiv100(dMiddle, { wmax: 800, box: true, rounding: 12 });
  dTable.style.overflow = 'auto';
  console.log('dTable', dTable)
  present0(dTable, state);
  return;
  mCenterCenterFlex(dTable);
  let d1 = mDiv(dTable);
  let d2 = present_structured1(d1, state);
}
function pureId(id) { return id.substring(4) }
function purge(elem) {
  var a = elem.attributes, i, l, n;
  if (a) {
    for (i = a.length - 1; i >= 0; i -= 1) {
      n = a[i].name;
      if (typeof elem[n] === 'function') {
        elem[n] = null;
      }
    }
  }
  a = elem.childNodes;
  if (a) {
    l = a.length;
    for (i = a.length - 1; i >= 0; i -= 1) {
      purge(elem.childNodes[i]);
    }
  }
  elem.remove();
}
function push_hist() { let o = { i: G.i, items: G.selist.map(x => iStrip(x)) }; G.hist.push(o); }
function pVal(dParent, val) { let d = pPanel(dParent); d.innerHTML = val; return d; }
function pxToNumber(s) {
  return (Number(s.substring(0, s.length - 2)));
}
function q_mirror_fen() {
  let fen = Z.fen;
  for (const prop of arguments) {
    let ui = UI[prop];
    fen[prop] = ui.list;
  }
  qanim();
}
function q_move_topmost(uideck, uito) {
  let topmost = pop_top(uideck);
  let dfrom = iDiv(topmost);
  dfrom.remove();
  dfrom.style.position = 'static';
  dfrom.style.zIndex = 0;
  uito.items.push(topmost);
  uito.list = uito.items.map(x => x.key);
  mAppend(uito.cardcontainer, dfrom);
  qanim();
}
function q0() {
  let list = dict2list(EMO.emoscale, 'k').map(x => ({ name: x.k, key: x.key, color: x.color, text: x.list }));
  show_prompt('how are you feeling right now?', list, a0);
}
function q1() {
  let list = [];
  for (const item of G.selist) {
    let alpha = .4;
    for (const w of item.text.split(',')) {
      let o = { name: w.trim(), key: item.key, color: colorTrans(item.color, alpha), text: w.trim() };
      alpha += .2;
      list.push(o);
    }
  }
  show_prompt('select the 2 dominant feelings', list, a1);
}
function q2() {
  console.log('G', G)
  const transitions = {
    worried: {
      money: {},
      time: {},
      past: {},
      future: {},
      material: {},
    },
  };
  let step1 = ''
}
function qanim() {
  if (!isEmpty(DA.qanim)) {
    let [f, params] = DA.qanim.shift();
    f(...params);
  }
}
function qanim_flip(card, ms = 400) {
  mAnimate(iDiv(card), 'transform', [`scale(1,1)`, `scale(0,1)`],
    () => {
      if (card.faceUp) face_down(card); else face_up(card);
      mAnimate(iDiv(card), 'transform', [`scale(0,1)`, `scale(1,1)`], qanim, ms / 2, 'ease-in', 0, 'both');
    },
    ms / 2, 'ease-out', 0, 'both');
}
function qanim_flip_topmost(deck, ms = 400) {
  qanim_flip(deck.get_topcard(), ms);
}
function qanim_move(card, uifrom, uito, ms = 400) {
  let dfrom = iDiv(card);
  let dto = isEmpty(uito.items) ? uito.cardcontainer : iDiv(arrLast(uito.items));
  let dParent = find_common_ancestor(dfrom, dto);
  let rfrom = getRect(dfrom, dParent);
  let rto = getRect(dto, dParent);
  dfrom.style.zIndex = 100;
  let [offx, offy] = isEmpty(uito.items) ? [4, 4] : [card.w, 0];
  let a = mAnimate(dfrom, 'transform',
    [`translate(${offx + rto.l - rfrom.l}px, ${offy + rto.t - rfrom.t}px)`], qanim,
    ms, 'ease');
}
function qanim_move_topmost(uideck, uito, ms = 400) {
  let card = uideck.get_topcard();
  qanim_move(card, uideck, uito, ms);
}
function qOptions(bg = BLUEGREEN) {
  let options = {
    bCaption: '☰',
    bStyles: { fz: 30, margin: 4 },
    menuStyles: { bg: wblack, alpha: .65 },
    sbStyles: { bg: wblack, alpha: .25 },
    divStyles: { bg: wwhite, alpha: .25 },
    innerStyles: {},
    outerStyles: { bg: bg },
  };
  return options;
}
function qPageMST(dParent, options) {
  mStyle(dParent, { h: '100%', w: '100%', box: true, bg: 'silver' });
  setRect(dParent);
  let item = iMenuSidebarDiv(dParent, options);
  return { item: item, sidebar: iGetl(item, 'sidebar'), dContent: iGetl(item, 'dContent'), dMenu: iGetl(item, 'dMenu') };
}
function QReset() {
  console.log('...', getFunctionCallerName());
  clearTimeout(TOQ);
  clearTimeout(TOQRunner);
  Q = [];
  AkQ = [];
}
function QRunner() {
  if (QCancelAutoreset) { QRunnerRunning = false; QCancelAutoreset = false; restartQ(); }
  else if (isEmpty(Q)) TOQRunner = setTimeout(QRunner, 1000);
  else _runQ(QRunner);
}
function QStop() {
  console.log('...', getFunctionCallerName());
  QCancelAutoreset = true;
}
function qTable(dParent, options) {
  mStyleX(dParent, { h: '100%', w: '100%', box: true, bg: 'silver' });
  setRect(dParent);
  let item = iMenuSidebarDiv(dParent, options);
  return { item: item, sidebar: iGetl(item, 'sidebar'), dContent: iGetl(item, 'dContent'), dMenu: iGetl(item, 'dMenu') };
}
function quadCenters(rows, cols, wCell, hCell) {
  let offX = wCell / 2, offY = hCell / 2;
  let centers = [];
  let x = 0; y = 0;
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      let center = { x: x + offX, y: y + offY };
      centers.push(center);
      x += wCell;
    }
    y += hCell; x = 0;
  }
  return [centers, wCell * cols, hCell * rows];
}
function quadGrid(soDict, loc, condList) {
  let [idBoard, sBoard] = findMatch(soDict, condList);
  return _quadGrid(loc, idBoard, sBoard, soDict);
}
function quadGrid_old(soDict, loc, sBoard, idBoard) {
  return _quadGrid(loc, idBoard, sBoard, soDict);
}
function quantization(rgbValues, depth) {
  const MAX_DEPTH = 4;
  if (depth === MAX_DEPTH || rgbValues.length === 0) {
    const color = rgbValues.reduce(
      (prev, curr) => {
        prev.r += curr.r;
        prev.g += curr.g;
        prev.b += curr.b;
        return prev;
      },
      {
        r: 0,
        g: 0,
        b: 0,
      }
    );
    color.r = Math.round(color.r / rgbValues.length);
    color.g = Math.round(color.g / rgbValues.length);
    color.b = Math.round(color.b / rgbValues.length);
    return [color];
  }
  const componentToSortBy = findBiggestColorRange(rgbValues);
  rgbValues.sort((p1, p2) => {
    return p1[componentToSortBy] - p2[componentToSortBy];
  });
  const mid = rgbValues.length / 2;
  return [
    ...quantization(rgbValues.slice(0, mid), depth + 1),
    ...quantization(rgbValues.slice(mid + 1), depth + 1),
  ];
}
function queryINSERT(data) {
  let newData = {};
  for (const k in data) {
    let val = data[k];
    if (!isNumber(val)) newData[k] = "'" + val + "'"; else newData[k] = val;
  }
  let q = 'INSERT INTO users (' + Object.keys(newData).join() + ') VALUES (' + Object.values(newData).join(',') + ')';
  return q;
}
function querySelectUser(data) {
  let newData = {};
  for (const k in data) {
    let val = data[k];
    if (!isNumber(val)) newData[k] = "'" + val + "'"; else newData[k] = val;
  }
  let q = 'SELECT * FROM users WHERE username = ' + newData.username;
  return q;
}
function queryStringToJson() {
  let q = window.location.search;
  if (isEmpty(q)) return {};
  q = q.substring(1);
  let result = {};
  let parts = q.split('&');
  for (const p of parts) {
    let key = stringBefore(p, '=');
    let val = stringAfter(p, '=');
    result[key] = val;
  }
  return result;
}
function question2(ev) {
  let id = evToId(ev);
  let item = Items[id];
  console.log('item', item);
  say(`why do you feel ${item.list}???`, 'uk', show_reasons, .5, .8);
}
function quick_classes(superdi) {
  let text = '//#region classes\r\n';
  let keys = sortClassKeys(superdi);
  for (const k of keys) {
    let code = superdi.cla[k].code;
    if (['colorDict', 'VectorLayer', 'lCard'].some(x => code.includes(x))) continue;
    if (isdef(superdi.func[k])) { continue; }
    text += code.trim() + '\r\n';
  }
  text += '//#endregion\r\n\r\n';
  return text;
}
function quick_consts(superdi) {
  let text = '//#region consts\r\n';
  let constlist = sortConstKeys(superdi);
  for (const c of constlist) {
    let constkey = c.key;
    if (['cx', 'PORT', 'SERVER', 'SERVERRURL'].some(x => x == constkey)) { delete superdi.const[constkey]; continue; }
    if (isdef(superdi.func[constkey]) || isdef(superdi.cla[constkey])) { delete superdi.const[constkey]; continue; }
    let code = c.code;
    text += code.trim() + '\r\n';
  }
  text += '//#endregion\r\n\r\n';
  return text;
}
function quick_funcs(superdi, lstart = '_', lend = 'L') {
  let text = '';
  let byletter = sortFuncsAlpha(superdi);
  let skip = isdef(lstart);
  for (const letter in byletter) {
    if (skip && letter != lstart) continue;
    skip = false;
    text += `//#region ${letter}\r\n`;
    for (const k of byletter[letter]) {
      let code = superdi.func[k].code;
      if (['colorDict', 'VectorLayer', 'lCard'].some(x => code.includes(x))) continue;
      text += code.trim() + '\r\n';
    }
    text += '//#endregion\r\n\r\n';
    if (letter == lend) break;
  }
  return text;
}
function quick_vars(superdi) {
  let text = '//#region vars\r\n';
  let varkeys = Object.keys(superdi.var);
  let dichess = {};
  for (const varkey of varkeys) {
    if (['lifeView', 'exp', 'Deck', 'gridsize'].some(x => x == varkey)) { delete superdi.var[varkey]; continue; }
    let o = superdi.var[varkey];
    if (is_chessvar(o)) {
      dichess[varkey] = o;
    } else if (varkey == varkey.toLowerCase() && varkey != 'c52') {
      delete superdi.var[varkey];
      continue;
    } else {
      text += o.code.trim() + '\r\n';
    }
  }
  let chessvars = sortChessVars(dichess);
  let chessvarkeys = chessvars.map(x => x.name);
  for (const varkey of chessvarkeys) { let o = superdi.var[varkey]; text += o.code.trim() + '\r\n'; }
  text += '//#endregion\r\n\r\n';
  return text;
}
function Quiescence(alpha, beta) {
  if ((srch_nodes & 2047) == 0) CheckUp();
  srch_nodes++;
  if (IsRepetition() || brd_fiftyMove >= 100) {
    return 0;
  }
  if (brd_ply > MAXDEPTH - 1) {
    return EvalPosition();
  }
  var Score = EvalPosition();
  if (Score >= beta) {
    return beta;
  }
  if (Score > alpha) {
    alpha = Score;
  }
  GenerateCaptures();
  var MoveNum = 0;
  var Legal = 0;
  var OldAlpha = alpha;
  var BestMove = NOMOVE;
  Score = -INFINITE;
  var PvMove = ProbePvTable();
  if (PvMove != NOMOVE) {
    for (MoveNum = brd_moveListStart[brd_ply]; MoveNum < brd_moveListStart[brd_ply + 1]; ++MoveNum) {
      if (brd_moveList[MoveNum] == PvMove) {
        brd_moveScores[MoveNum].score = 2000000;
        break;
      }
    }
  }
  for (MoveNum = brd_moveListStart[brd_ply]; MoveNum < brd_moveListStart[brd_ply + 1]; ++MoveNum) {
    PickNextMove(MoveNum);
    if (MakeMove(brd_moveList[MoveNum]) == BOOL.FALSE) {
      continue;
    }
    Legal++;
    Score = -Quiescence(-beta, -alpha);
    TakeMove();
    if (srch_stop == BOOL.TRUE) return 0;
    if (Score > alpha) {
      if (Score >= beta) {
        if (Legal == 1) {
          srch_fhf++;
        }
        srch_fh++;
        return beta;
      }
      alpha = Score;
      BestMove = brd_moveList[MoveNum];
    }
  }
  if (alpha != OldAlpha) {
    StorePvMove(BestMove);
  }
  return alpha;
}
function race_check_endcondition() {
  let players = get_values(Session.cur_players);
  let winners = players.filter(x => x.score >= Session.winning_score).map(x => x.name);
  return winners;
}
function race_open_prompt(fen) {
  console.assert(!uiActivated, 'open_prompt_ with uiActivated ON !!!!!!!!!!!!!!!!!!!!!!!!!!');
  let g = update_game_values();
  clearTable(); set_background_color(g.color);
  QContextCounter += 1;
  show_game_name(g.friendly);
  show_title(g.table.friendly);
  show_level(g.level, g.maxlevel);
  if (Session.is_badges) g.level = setBadgeLevel(g.level, Session.cur_user, Session.cur_game, g.maxlevel);
  g.startTime = get_timestamp();
  mLinebreak(dTable, 15);
  Session.cur_funcs.prompt(g, fen);
  Selected = null;
  if (nundef(fen)) uiActivated = true;
}
function race_present_table(obj) {
  console.assert(isdef(obj.table), 'present_table without obj.table!!!!!!!!!!!!!!');
  if (obj.table.status != 'past') { update_table_options_for_user(Session.cur_user, obj.table.pl_options, obj.table.game); }
  update_session(obj);
  let table_status = Session.cur_table.status;
  if (is_admin() && table_status == 'past') { in_game_off(); in_game_open_prompt_off(); status_message_off(); get_games(); return; }
  if (!in_game()) { open_game_ui(); in_game_on(); }
  let d = mBy('table'); d.animate([{ opacity: 0, transform: 'translateY(50px)' }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: 1000, easing: 'ease' });
  let my_status = Session.cur_me.player_status;
  let have_move = my_status == 'joined';
  if (!have_move) { if (!in_game_open_prompt()) race_open_prompt(Session.cur_me.state); }
  else if (!in_game_open_prompt()) { race_open_prompt(); in_game_open_prompt_on(); }
  else { uiActivated = true; }
  ui_game_stats(Session.cur_players);
  if (table_status != 'started') {
    stop_game();
    let winners = Session.winners = race_check_endcondition();
    if (!isEmpty(winners)) {
      stop_game();
      show_gameover_new(winners);
    }
  } else Session.scoring_complete = false;
}
function race_set_fen() {
  let me = Session.cur_players[Session.cur_user];
  let fen = Session.cur_funcs.fen();
  me.state = fen;
}
function race_update_my_score(inc) {
  let me = Session.cur_me;
  me.score += inc;
  if (me.score >= Session.winning_score) me.player_status = 'done';
}
function rAdd(dmin = -1, dmax = 1) { return x => x + dmin + Math.random() * (dmax - dmin); }
function rAddSub(d) { return x => x + (coin() ? d : -d); }
function rAddSubRange(d) { return x => x + (Math.random() * 2 * d - d); }
function rAlphanums(n) { return rChoose(toLetters('0123456789abcdefghijklmnopq'), n); }
function RAND_32() { return (Math.floor((Math.random() * 255) + 1) << 23) | (Math.floor((Math.random() * 255) + 1) << 16) | (Math.floor((Math.random() * 255) + 1) << 8) | Math.floor((Math.random() * 255) + 1); }
function random_motto() { return chooseRandom(["time to play!", "life's good", "one game at a time!", "let's play!", "no place like home", "cafe landmann"]) }
function randomAlphanum() {
  let s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  return s[randomNumber(0, s.length - 1)];
}
function randomBotName() { return (coin() ? randomVowel() : '') + randomConsonant() + randomVowel() + 'bot'; }
function randomC52() { return Card52.getShortString(randomCard52()); }
function randomCard52() { return Card52.random(); }
function randomColor() { return rColor(); }
function randomColorDark(contrastTo) { return randomColorX(contrastTo, 10, 30); }
function randomColorLight(contrastTo) { return randomColorX(contrastTo); }
function randomColorX(contrastColor, minContrast = 25, mod = 60, startWheel = 0, minLum = 70, maxLum = 90, minSat = 100, maxSat = 100) {
  let hue = getContrastingHueX(contrastColor, minContrast, mod, startWheel);
  let sat = minSat + (maxSat - minSat) * Math.random();
  let lum = minLum + (maxLum - minLum) * Math.random();
  let result = "hsl(" + hue + ',' + sat + '%,' + lum + '%)';
  return result;
}
function randomConsonant() { let s = 'bcdfghjklmnpqrstvwxz'; return s[randomNumber(0, s.length - 1)]; }
function randomContent(type) {
  if (nundef(type)) { type = randomType(); }
  let content = window['random' + capitalize(type)]();
  if (isDict(content)) { content.type = type; } else content = { content: content, type: type };
  return content;
}
function randomDarkColor() {
  let s = '#';
  for (let i = 0; i < 3; i++) {
    s += chooseRandom([0, 1, 2, 3, 4, 5, 6, 7]) + chooseRandom(['f', 'c', '9', '6', '3', '0']);
  }
  return s;
}
function randomDigit() { let s = '0123456789'; return s[randomNumber(0, s.length - 1)]; }
function randomHexColor() {
  let s = '#';
  for (let i = 0; i < 6; i++) {
    s += chooseRandom(['f', 'c', '9', '6', '3', '0']);
  }
  return s;
}
function randomHslaColor(s = 100, l = 70, a = 1) {
  var hue = Math.round(Math.random() * 360);
  return hslToHslaString(hue, s, l, a);
}
function randomIndex(array) { return randomRange(0, array.length) | 0 }
function randomizeNum(n, percentUp = 25, percentDown = 25) {
  let max = n * percentUp / 100;
  let min = n * percentDown / 100;
  return randomNumber(n - min, n + max);
}
function randomLetter() { let s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; return s[randomNumber(0, s.length - 1)]; }
function randomLightColor() {
  let s = '#';
  for (let i = 0; i < 3; i++) {
    s += chooseRandom(['A', 'B', 'C', 'D', 'E', 'F']) + chooseRandom(['f', 'c', '9', '6', '3', '0']);
  }
  return s;
}
function randomList(len = 3, onlySimple = true, elType) {
  if (nundef(elType)) { elType = randomType(onlySimple); }
  let result = [];
  for (let i = 0; i < len; i++) {
    let c = randomContent(elType);
    result.push(isdef(c.content) ? c.content : c);
  }
  return { content: result, elType: elType };
}
function randomName() { return chooseRandom(coin() ? GirlNames : BoyNames); }
function randomNumber(min = 0, max = 100) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function randomObject(len = 3, onlySimple = true, elTypes) {
  if (nundef(elTypes)) { elTypes = Array.from({ length: len, }, () => randomType(true)); }
  let result = { id: getUID('o') };
  let i = 0;
  for (const t of elTypes) {
    let key = t + '_' + i; i += 1;
    let val = randomContent(t);
    result[key] = isdef(val.content) ? val.content : val;
  }
  return result;
}
function randomRange(min, max) { return min + Math.random() * (max - min) }
function randomRank() { return Card52.randomRankSuit[0]; }
function randomString(len = 4, startLetter) {
  let s = '';
  if (isdef(startLetter)) { s = startLetter; len -= 1; }
  let isVowel = coin() ? true : false;
  for (let i = 0; i < len; i++) {
    if (isVowel) s += randomVowel(); else s += randomConsonant();
    isVowel = !isVowel;
  }
  return s;
}
function randomSuit() { return Card52.randomRankSuit[1]; }
function randomType(onlySimple = false) {
  let complexTypes = ['list'];
  let simpleTypes = ['number', 'string', 'varLenString', 'C52', 'Card52'];//'card'?,'html','DOM'];
  let allTypes = complexTypes.concat(simpleTypes);
  type = chooseRandom(onlySimple ? simpleTypes : allTypes);
  return type;
}
function randomUnitTuple() {
  let tile = chooseRandom(assets.tileNames);
  let nationality = chooseRandom(assets.nationalityNames);
  let unitType = chooseRandom(assets.unitTypeNames);
  return [nationality, tile, unitType, 2];
}
function randomUserId(len = 20, isNumeric = false) {
  let id = '';
  if (isNumeric) for (let i = 0; i < len; i++) { id += randomDigit(); }
  else for (let i = 0; i < len; i++) { id += randomAlphanum(); }
  return id;
}
function randomVarLenString(lmin = 3, lmax = 12, startLetter) { let len = randomNumber(lmin, lmax); return randomString(len, startLetter); }
function randomVowel() { let s = 'aeiouy'; return s[randomNumber(0, s.length - 1)]; }
function range(f, t, st = 1) {
  if (nundef(t)) {
    t = f - 1;
    f = 0;
  }
  let arr = [];
  for (let i = f; i <= t; i += st) {
    arr.push(i);
  }
  return arr;
}
function rAreas() {
  let d1 = mDiv(dTable, { bg: 'blue', w: 800, h: 600 }, 'd1');
  SPEC = { views: { d1: { layout: ['T', 'P O'] } } };
  console.log(SPEC)
  for (const k in SPEC.views) { createLayout(k, SPEC.views[k].layout); }
}
function rAreas_0() {
  let color = SPEC.color.theme;
  document.body.style.backgroundColor = color;
  let fg = colorIdealText(color)
  document.body.style.color = fg;
  let palette = getTransPalette9();
  let ipal = 1;
  let d = document.getElementById('areaTable');
  setTableSize(...SPEC.tableSize);
  let s = '';
  let m = [];
  for (const line of SPEC.layout) {
    s += '"' + line + '" ';
    let letters = line.split(' ');
    let arr = [];
    for (const l of letters) { if (!isEmpty(l)) arr.push(l); }
    m.push(arr);
  }
  d.style.gridTemplateAreas = s;
  if (SPEC.collapseEmptySmallLetterAreas) { collapseSmallLetterAreas(m, d); }
  else fixedSizeGrid(m, d);
  for (const k in SPEC.areas) {
    let areaName = SPEC.areas[k];
    let d1 = document.createElement('div');
    d1.id = areaName;
    d1.style.gridArea = k;
    if (SPEC.shadeAreaBackgrounds) { d1.style.backgroundColor = palette[ipal]; ipal = (ipal + 1) % palette.length; }
    if (SPEC.showAreaNames) { d1.innerHTML = makeAreaNameDomel(areaName); }
    UIS[areaName] = { elem: d1, children: [] };
    d.appendChild(d1);
  }
}
function rBehaviorCode() {
  for (const key of ['table', 'players']) {
    let pool = serverData[key];
    for (const oid in pool) {
      let o = pool[oid];
      for (const cond in COND) {
        console.log('try', cond)
        let todo = COND[cond](o);
        if (isdef(todo)) {
          FUNCS[todo.f](oid, o);
          DONE[oid] = true;
        }
      }
    }
  }
}
function rCard(postfix = 'n', ranks = '*A23456789TJQK', suits = 'HSDC') { return rChoose(ranks) + rChoose(suits) + postfix; }
function rChoose(arr, n = 1, func = null, exceptIndices = null) {
  let indices = arrRange(0, arr.length - 1);
  if (isdef(exceptIndices)) {
    for (const i of exceptIndices) removeInPlace(indices, i);
  }
  if (isdef(func)) indices = indices.filter(x => func(arr[x]));
  if (n == 1) {
    let idx = Math.floor(Math.random() * indices.length);
    return arr[indices[idx]];
  }
  arrShufflip(indices);
  return indices.slice(0, n).map(x => arr[x]);
}
function rCoin(percent = 50) {
  let r = Math.random();
  r *= 100;
  return r < percent;
}
function rColor(cbrightness, c2, alpha = null) {
  if (isdef(c2)) {
    let c = colorMix(cbrightness, c2, rNumber(0, 100));
    return colorTrans(c, alpha ?? Math.random());
  }
  if (isdef(cbrightness)) {
    let hue = rHue();
    let sat = 100;
    let b = isNumber(cbrightness) ? cbrightness : cbrightness == 'dark' ? 25 : cbrightness == 'light' ? 75 : 50;
    return colorFromHSL(hue, sat, b);
  }
  let s = '#';
  for (let i = 0; i < 6; i++) {
    s += rChoose(['f', 'c', '9', '6', '3', '0']);
  }
  return s;
}
function rConsonant(w, except = []) { let vowels = w ? getConsonants(w, except) : toLetters('aeiouy'); return chooseRandom(vowels); }
function rDate(before, after) {
  let after_date = new Date(after);
  let before_date = new Date(before);
  let random_date = new Date(Math.random() * (before_date.getTime() - after_date.getTime()) + after_date.getTime());
  return random_date;
}
function rDigits(n) { return rChoose(toLetters('0123456789'), n); }
function reAddServerObject(label) {
  let tv = TV[label];
  if (nundef(tv)) {
    console.log('this object has NOT been entered in TV!!! did you remove the object?!?', label);
    return;
  }
  let oid = tv.oid;
  let o = tv.o;
  addServerObject(oid, o, R);
}
function readExp() { }
function realTimeIfTrue(f, cnt) {
  console.log('counter', cnt)
  if (f()) setTimeout(() => realtimeIfTrue(f, cnt + 1), 10);
}
function rec_create_nodes_tree(r, t, path, keys) {
  if (isLiteral(t)) {
    let type = is_game_card(t) ? 'card' : typeof t;
    return register_node(t, type, getUID('o'), path, r);
  } else if (isList(t)) {
    let content = t;
    let type;
    if (startsWith(path, 'deck') || startsWith(path, 'achievements')) {
      type = 'deck';
    } else if (!isEmpty(t) && is_game_card(t[0])) {
      type = 'cardlist';
    }
    else {
      type = 'string';
    }
    let n = register_node(content, type, getUID('o'), path, r);
    if (type == 'cardlist') {
      let ch = [];
      let i = 0;
      for (const el of t) {
        if (!isLiteral(el)) continue;
        let type = is_game_card(el) ? 'card' : typeof t;
        let n1 = register_node(el, type, getUID('o'), path + '.' + el, r);
        i += 1;
        ch.push(n1.oid);
      }
      n.children = ch;
    }
    return n;
  } else if (isDict(t)) {
    let n = register_node(stringAfterLast(path, '.'), 'string', getUID('o'), path, r);
    let ch = [];
    for (const k in t) {
      if (nundef(keys[k]) && k.length > 1) { continue; }
      let pnew = isEmpty(path) ? k : path + '.' + k;
      let tnew = t[k];
      let n1 = rec_create_nodes_tree(r, tnew, pnew, keys);
      ch.push(n1.oid);
    }
    n.children = ch;
    return n;
  } else {
    let type = 'null';
    return register_node('null', type, getUID('o'), path, r);
  }
}
function rec_create_nodes_tree_akku(r, t, path, keys, akku) {
  if (isLiteral(t)) {
    let type = is_game_card(t) ? 'card' : typeof t;
    return register_node(t, type, getUID('o'), path, r);
  } else if (isList(t)) {
    let content = t;
    let type;
    if (startsWith(path, 'deck') || startsWith(path, 'achievements')) {
      type = 'deck';
    } else if (!isEmpty(t) && is_game_card(t[0])) {
      type = 'cardlist';
    }
    else {
      type = 'string';
    }
    let n = register_node(content, type, getUID('o'), path, r);
    if (type == 'cardlist') {
      let ch = [];
      let i = 0;
      for (const el of t) {
        if (!isLiteral(el)) continue;
        let type = is_game_card(el) ? 'card' : typeof t;
        let n1 = register_node(el, type, getUID('o'), path + '.' + el, r);
        i += 1;
        ch.push(n1.oid);
      }
      n.children = ch;
    }
    return n;
  } else if (isDict(t)) {
    let n = register_node(stringAfterLast(path, '.'), 'string', getUID('o'), path, r);
    let ch = [];
    for (const k in t) {
      if (nundef(keys[k]) && k.length > 1) { continue; }
      let pnew = isEmpty(path) ? k : path + '.' + k;
      akku.push(pnew);
      let tnew = t[k];
      let n1 = rec_create_nodes_tree_akku(r, tnew, pnew, keys, akku);
      ch.push(n1.oid);
    }
    n.children = ch;
    return n;
  } else {
    let type = 'null';
    return register_node('null', type, getUID('o'), path, r);
  }
}
function recAdjustDirtyContainers(uid, R, verbose = false) {
  let nui = R.uiNodes[uid];
  if (isdef(nui.children)) {
    for (const ch of nui.children) recAdjustDirtyContainers(ch, R, verbose);
  }
  if (nui.adirty) {
    adjustContainerLayout(nui, R);
  }
}
function recAdjustDirtyContainers_dep(uid, R, verbose = false) {
  let nui = R.uiNodes[uid];
  if (nui.adirty) {
    adjustContainerLayout(nui, R);
  }
  if (nundef(nui.children)) return;
  for (const ch of nui.children) recAdjustDirtyContainers(ch, R, verbose);
}
function recAllNodes(n, f, p, tailrec, safe = false) {
  if (safe) { ___enteredRecursion += 1; if (___enteredRecursion > MAX_RECURSIONS) { error('MAX_RECURSIONS reached!!!' + f.name); return; } }
  if (isList(n)) {
    if (tailrec) f(n, p);
    n.map(x => recAllNodes(x, f, p, tailrec));
    if (!tailrec) f(n, p);
  } else if (isDict(n)) {
    if (tailrec) f(n, p);
    for (const k in n) { recAllNodes(n[k], f, p, tailrec); }
    if (!tailrec) f(n, p);
  }
}
function recArrangeContent(uid, R) {
  let n = R.uiNodes[uid];
  if (nundef(n.children)) return;
  let parentPadding = isdef(n.params.paddingAroundChildren) ? n.params.paddingAroundChildren : DEFS.defaultPadding;
  let childMargin = isdef(n.params.gapBetweenChildren) ? n.params.gapBetweenChildren : DEFS.defaultGap;
  let posModified = false;
  let sizeModified = false;
  let children = n.children.map(x => R.uiNodes[x]);
  if (isdef(n.params.contentwalign) && n.params.contentwalign == 'center') {
    let children = n.children.map(x => R.uiNodes[x]);
    let xchimin = Math.min(...children.map(x => x.pos.x));
    let xchimax = Math.max(...children.map(x => x.pos.x + x.size.w));
    let diff = xchimax - xchimin;
    let wpar = n.size.w - 2 * parentPadding;
    let displ = (wpar - diff) / 2;
    if (displ >= 1) {
      posModified = true;
      for (const ch of children) { ch.params.pos = { x: ch.pos.x + displ, y: ch.pos.y }; }
    }
  }
  if (isdef(n.params.contenthalign) && n.params.contenthalign == 'center') {
    let ychimin = Math.min(...children.map(ch => ch.pos.y));
    let ychimax = Math.max(...children.map(ch => ch.pos.y + ch.size.h));
    let diff = ychimax - ychimin;
    let hpar = n.size.h - 2 * parentPadding;
    let displ = (hpar - diff) / 2;
    if (displ >= 1) {
      posModified = true;
      for (const ch of children) { ch.params.pos = { x: ch.pos.x, y: ch.pos.y + displ }; }
    }
  }
  if (posModified || sizeModified) {
    for (const ch of children) { setFixedSizeAndPos(ch); }
  }
  for (const ch of n.children) recArrangeContent(ch, R);
}
function recBuildRTree(n, key, path, parent, sp, R, oid) {
  CYCLES += 1; if (CYCLES > MAX_CYCLES) return;
  console.log('***', n, path, parent, sp)
  let n1 = { uid: getUID(), key: key, uidParent: parent ? parent.uid : null, path: path };
  if (isdef(oid)) n1.oid = oid;
  let locProp = '_id';
  let nodeName = n[locProp];
  if (isString(nodeName)) {
    lookupAddToList(R.Locations, [nodeName], n1.uid);
    n1.here = nodeName;
    let nSpec = sp[nodeName];
    console.log(nodeName, nSpec)
    if (nundef(nSpec.cond)) {
      let branch = recBuildRTree(nSpec, nodeName, '.', n1, sp, R, oid);
      R.rNodes[branch.uid] = branch;
      n1.children = [branch.uid];
    } else {
    }
  }
  let chProp = 'sub';
  let chlist = n[chProp];
  if (isdef(chlist)) {
    n1.children = [];
    let i = 0;
    for (const chInfo of chlist) {
      let newPath = extendPath(path, i);
      i += 1;
      let ch = recBuildRTree(chInfo, key, newPath, n1, sp, R, oid);
      R.rNodes[ch.uid] = ch;
      n1.children.push(ch.uid);
    }
  }
  return n1;
}
function recBuildUiFromNode(n, uidParent, R, iParams = {}) {
  CYCLES += 1; if (CYCLES > MAX_CYCLES) return;
  let n1 = {};
  let sp = R.getSpec();
  n1.uid = n.uid;
  if (isdef(n.children)) {
    n1.children = n.children.map(x => x);
    n1.adirty = true;
  }
  let parent = lookup(R.rNodes, [uidParent]);
  let nsp = sp[n.key];
  let nsub = evalSpecPath(nsp, n.path, R);
  n1.type = nsub.type;
  n1.data = nsub.data;
  n1.params = isdef(nsub.params) ? nsub.params : {};
  n1.defParams = jsCopy(iParams);
  let oid = n1.oid = n.oid;
  let o = oid ? R.getO(oid) : null;
  if (n1.data) {
    n1.content = calcContentFromData(oid, o, n1.data, R);
    if (isString(n1.content)) {
      console.log(n1.content)
      let oid1 = n1.content;
      console.log('oid of card', oid1, '\noid of n1', oid);
      if (oid1 != oid) {
        let o1 = R.getO(oid1);
        if (o1) {
          let oidNode1 = R.oidNodes[oid1];
          if (isdef(oidNode1)) {
            let key1list = Object.keys(oidNode1);
            console.log('following keys available for', oid1, key1list);
            let key1 = key1list[0];
            console.log('FOUND BETTER REP FOR O', oid1, key1, '\nWAS JETZT???????');
            console.log('der rNode muss doch existieren!!!', R.rNodes[n.uid])
            instantiateOidKeyAtParent(oid1, key1, uidParent, R);
            console.log('HALLOOOOOOOO');
          }
        }
      }
    }
  }
  if (n1.type == 'grid') {
    createBoard(n1, uidParent, R, iParams);
  } else {
    n1.ui = createUi(n1, uidParent, R, iParams);
  }
  R.uiNodes[n1.uid] = n1;
  if (R.isUiActive) n1.act.activate(highSelfAndRelatives, unhighSelfAndRelatives, selectUid);
  if (nundef(n1.children) || n1.type == 'grid') { return; }
  iParams = jsCopy(iParams);
  if (nundef(iParams[n1.type])) iParams[n1.type] = {};
  iParams[n1.type].params = n1.defParams;
  for (const ch of n1.children) {
    let nNew = R.rNodes[ch];
    recBuildUiFromNode(nNew, n1.uid, R, iParams, n1.oid);
  }
}
function recCollect(n, cond, akku, safe = false) {
  if (safe) { ___enteredRecursion += 1; if (___enteredRecursion > MAX_RECURSIONS) { error('MAX_RECURSIONS reached!!!' + f.name); return; } }
  if (cond(n)) akku.push(n);
  if (nundef(n.children)) return;
  for (const ch of n.children) {
    recCollect(ch, cond, akku, safe);
  }
}
function recCollectSizeInfo(t, R, uiNodeSizes) {
  if (nundef(t.size)) return;
  uiNodeSizes[t.uid] = { w: Math.floor(t.size.w), h: Math.floor(t.size.h) };
  if (nundef(t.children)) return;
  for (const ch of t.children) { recCollectSizeInfo(R.uiNodes[ch], R, uiNodeSizes); }
}
function recConvertLists(o, maxlen = 25) {
  for (const k in o) {
    let val = o[k];
    if (isList(val)) {
      if (val.length > maxlen) val = val.slice(0, maxlen).toString() + '...';
      else val = val.toString();
      o[k] = val;
    } else if (isDict(val)) recConvertLists(val);
  }
}
function recConvertToList(n, listOfProps) {
  if (isList(n)) { n.map(x => recConvertToList(x, listOfProps)); }
  else if (isDict(n) && isList(listOfProps)) {
    for (const prop of listOfProps) {
      let lst = n[prop];
      if (isList(lst) && !isEmpty(lst)) { n[prop] = lst.join(' '); }
    }
    for (const k in n) { recConvertToList(n[k], listOfProps); }
  }
}
function recConvertToSimpleList(n, listOfProps) {
  if (isList(n)) { n.map(x => recConvertToList(x, listOfProps)); }
  else if (isDict(n) && isList(listOfProps)) {
    for (const prop of listOfProps) {
      let conv = dictOrListToString(n[prop]);
      if (conv) n[prop] = conv;
    }
    for (const k in n) { recConvertToList(n[k], listOfProps); }
  }
}
function recDeleteEmptyObjects(o) {
  if (isLiteral(o)) return o;
  else if (isList(o)) return o.map(x => recDeleteEmptyObjects(x));
  let onew = {};
  for (const k in o) {
    if (!isEmpty(o[k])) {
      onew[k] = recDeleteEmptyObjects(jsCopy(o[k]));
    }
  }
  return onew;
}
function recDeleteKeys(o, deleteEmpty = true, omitProps) {
  if (isLiteral(o)) return o;
  else if (isList(o)) return o.map(x => recDeleteKeys(x, deleteEmpty, omitProps));
  let onew = {};
  for (const k in o) {
    if (omitProps.includes(k)) continue;
    if (isLiteral(o[k]) || !isEmpty(o[k])) {
      onew[k] = recDeleteKeys(jsCopy(o[k]), deleteEmpty, omitProps);
    } else {
    }
  }
  return onew;
}
function Receptor(div, board) {
  var self = this;
  this.div = div;
  this.board = board;
}
function recFindDOMs(o) {
  if (!isDict(o)) return [];
  if (isDOM(iDiv(o))) return [iDiv(o)];
  let akku = [];
  for (const k in o) {
    let val = o[k];
    akku = akku.concat(recFindDOMs(val));
  }
  return akku;
}
function recFindExecute(o, prop, func) {
  if (!isDict(o) && !Array.isArray(o)) { return; }
  if (isDict(o)) {
    if (o[prop]) { func(o); }
    for (const k in o) { recFindExecute(o[k], prop, func); }
  } else if (isList(o)) {
    for (let i = 0; i < o.length; i++) {
      this.recFindExecute(o[i], prop, func);
    }
  }
}
function recFindProp(o, prop, path, akku) {
  if (!isDict(o) && !Array.isArray(o)) { return; }
  if (isDict(o)) {
    if (o[prop]) { akku[path] = { name: o[prop], node: o }; }
    for (const k in o) { recFindProp(o[k], prop, path + '.' + k, akku); }
  } else if (isList(o)) {
    for (let i = 0; i < o.length; i++) {
      this.recFindProp(o[i], prop, path + '.' + i, akku);
    }
  }
}
function recFindProp_dep(o, prop, path, akku) {
  if (!isDict(o) && !Array.isArray(o)) { return; }
  if (isDict(o)) {
    if (o[prop]) { akku[path] = o[prop]; }
    for (const k in o) { recFindProp(o[k], prop, path + '.' + k, akku); }
  } else if (isList(o)) {
    for (let i = 0; i < o.length; i++) {
      this.recFindProp(o[i], prop, path + '.' + i, akku);
    }
  }
}
function recFlattenLists(o) {
  for (const k in o) {
    let cand = o[k];
    if (isList(cand)) o[k] = cand.join(' ');
    else if (isDict(cand)) recFlattenLists(cand);
  }
}
function recListToString(lst) {
  if (!isList(lst)) return lst;
  if (isListOfLiterals(lst)) return lst.join(',');
  else {
    let res = [];
    for (const el of lst) {
      let elString = recListToString(el);
      res.push(elString);
    }
    return res;
  }
}
function recMeasureAbs(uid, R) {
  let n = R.uiNodes[uid];
  if (isdef(n.children)) {
    for (const ch of n.children) {
      recMeasureAbs(ch, R);
    }
  }
  n.sizeMeasured = calcSizeMeasured(n, R);
  n.sizeNeeded = uniformSizeToContent(uid, R);
  n.size = {
    w: Math.max(n.sizeMeasured.w, n.sizeNeeded.w),
    h: Math.max(n.sizeMeasured.h, n.sizeNeeded.h)
  }
  n.ui.style.width = n.size.w + 'px';
  n.ui.style.height = n.size.h + 'px';
}
function recMeasureArrangeFixedSizeAndPos(uid, R) {
  let n = R.uiNodes[uid];
  let [minx, maxx, miny, maxy] = [100000, 0, 100000, 0];
  if (isdef(n.children)) {
    for (const ch of n.children) {
      let [xmin, xmax, ymin, ymax] = recMeasureArrangeFixedSizeAndPos(ch, R);
      minx = Math.min(minx, xmin);
      maxx = Math.max(maxx, xmax);
      miny = Math.min(miny, ymin);
      maxy = Math.max(maxy, ymax);
    }
    if (nundef(n.params.pos)) {
      return [minx, maxx, miny, maxy];
    }
    let wParent = Math.max(n.params.size.w, maxx);
    let hParent = Math.max(n.params.size.h, maxy);
    n.params.size.w = wParent + 4;
    n.params.size.h = hParent + 4;
    setFixedSizeAndPos(n);
    n.ui.style.opacity = .5;
    minx = Math.min(minx, n.pos.x);
    maxx = Math.max(maxx, n.pos.x + n.size.w);
    miny = Math.min(miny, n.pos.y);
    maxy = Math.max(maxy, n.pos.y + n.size.h);
    return [minx, maxx, miny, maxy];
  } else {
    setFixedSizeAndPos(n);
    let b = getBounds(n.ui);
    return [n.pos.x, n.pos.x + b.width, n.pos.y, n.pos.y + b.height];
  }
}
function recMeasureOverride(uid, R) {
  let n = R.uiNodes[uid];
  if (isdef(n.children)) { for (const ch of n.children) { recMeasureOverride(ch, R); } }
  n.sizeMeasured = calcSizeMeasured(n, R);
  n.sizeNeeded = arrangeOverride(n, R);
  n.size = {
    w: Math.max(n.sizeMeasured.w, n.sizeNeeded.w),
    h: Math.max(n.sizeMeasured.h, n.sizeNeeded.h)
  }
}
function recMergeSpecNode(n, sp, spNew) {
  if (isList(n._NODE)) {
    let lst = n._NODE;
    let combiName = getCombNodeName(lst);
    let nComb = {};
    for (const name of lst) {
      nComb = mergedSpecNode(nComb, sp[name]);
    }
    spNew[combiName] = nComb;
    n._NODE = combiName;
  }
  if (isdef(n.sub)) {
    for (const n1 of n.sub) recMergeSpecNode(n1, sp, spNew);
  }
}
function recNormalize(n, sp) {
  let n1 = jsCopy(n);
  let t = n1.type = nundef(n.type) ? inferType(n) : n.type;
  let locProp = 'panel';
  if (locProp != 'p') {
    n1.p = n[locProp];
    delete n1[locProp];
  }
  let contProp = 'sub';
  if (contProp && isdef(n[contProp])) {
    n1.ch = n[contProp].map(x => recNormalize(x, sp));
    delete n1[contProp];
  }
  return n1;
}
function recompute_const_var_classes() {
  let dir = 'C:\\xampp\\htdocs\\aroot\\basejs\\cb1\\';
  let superdi = get_current_superdi(dir);
  let text = quick_consts(superdi);
  text += quick_vars(superdi);
  text += quick_classes(superdi);
  let dirout = 'C:\\xampp\\htdocs\\aroot\\basejs\\cb2\\';
  toFile(text, dirout + 'allglobalshuge.js');
}
function recompute_func_alpha() {
  let dir = 'C:\\xampp\\htdocs\\aroot\\basejs\\cb1\\';
  let superdi = get_current_superdi(dir);
  let text = quick_funcs(superdi, null, 'L');
  let text2 = quick_funcs(superdi, 'M');
  let dirout = 'C:\\xampp\\htdocs\\aroot\\basejs\\cb2\\';
  toFile(text, dirout + 'allfuncs.js');
  toFile(text2, dirout + 'allfuncs_m.js');
}
function recomputeBestED() {
  for (const k in symbolDict) {
    let info = symbolDict[k];
    if (info.type == 'emo' && isString(info.D) && isString(info.E)) {
      info.bestD = stringAfterLast(info.D, '|').trim().toLowerCase();
      info.bestE = stringAfterLast(info.E, '|').trim().toLowerCase();
    } else if (nundef(info.E) || isNumber(info.E) || isdef(info.bestE)) continue;
    if (info.type == 'emo') continue;
    if (info.E.includes('|')) {
      console.log('he das gibt es doch nicht!!!', k, info);
    } else {
      info.bestE = info.E;
    }
    if (nundef(info.D)) {
      console.log('he das gibt es doch nicht!!! KEIN DEUTSCH!', k, info);
    } else {
      info.bestD = stringBefore(info.D, '|').trim().toLowerCase();
    }
  }
  downloadAsYaml(symbolDict, 'sym');
}
function record(lang, best) {
  if (!isGameWithSpeechRecognition()) return;
  let wordlist = ['du', 'bist', 'ein', 'vogel', best];
  if (!isdef(recognition)) {
    speech00(lang);
    setTimeout(record(lang, wordlist), 3000);
    return;
  }
  setVocabulary(wordlist);
  if (isdef(recognition) && isRunning) {
    console.log('.......................stopping recog');
    recordCallback = () => record(lang, wordlist);
    recognition.stop();
  } else {
    isRunning = true;
    recognition.start();
  }
}
function record_winners(winners, game) { ensure_winnerlist(game).push(winners); }
function recoverStateAndSettings() {
  onClickRetrieveState();
  let settings = localStorage.getItem('settings');
  if (isdef(settings)) {
    settings = JSON.parse(settings);
    console.log('retrieved settings (baseColor)', settings.baseColor);
    G.settings = settings;
    Socket.emit('settings', { settings: G.settings });
  } else {
    console.log('no settings in localStorage!');
  }
}
function recPopulateTree(t, R, levels) {
  if (levels > 0) {
    addRandomChildren(t, R);
    if (Object.keys(R.rNodes).length >= MAXNODES) { console.log('MAXNODES REACHED!!!'); return; }
    for (const id of t.children) {
      if (chooseRandom([true, false])) {
        recPopulateTree(R.rNodes[id], R, levels - 1);
      }
    }
  }
}
function recPosRandomUiTreeX(uid, R, context) {
  let n = R.uiNodes[uid];
  let gran = context.granularity;
  n.params.size = { w: randomNumber(1, context.wmax) * gran, h: randomNumber(1, context.hmax) * gran };
  n.params.pos = { x: randomNumber(1, context.xmax) * gran, y: randomNumber(1, context.ymax) * gran }
  n.params.sizing = 'fixed';
  if (nundef(n.children)) return;
  for (const ch of n.children) { recPosRandomUiTreeX(ch, R, context); }
}
function recPosRegularUiTree(uid, R) {
  let n = R.uiNodes[uid];
  n.params.sizing = 'fixed';
  if (nundef(n.children)) return;
  for (const ch of n.children) { recPosRegularUiTree(ch, R); }
  let num = n.children.length;
  if ([2, 4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 29, 56, 64].includes(num)) arrangeChildrenAsQuad(n, R);
  else if ([3, 8, 15, 24, 35, 48, 63].includes(num)) {
    let lower = Math.floor(Math.sqrt(num));
    console.assert(num == lower * (lowe + 2), 'RECHNUNG FALSCH IN recPosRegularUiTree');
    arrangeChildrenAsMatrix(n, R, lower, lower + 2);
  } else if (num > 1 && num < 10) arrangeChildrenAsCircle(n, R);
}
function recPresent(n, level, dLevel, nDict, treeProp, { lstFlatten, lstShow, lstOmit } = {}) {
  mNodeFilter(n, { dParent: dLevel[level], lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
  if (nundef(n.children)) return level;
  let max = 0;
  for (const x of n.children) {
    let nx = nDict[x];
    let newMax = recPresent(nx, level + 1, dLevel, nDict, treeProp, { lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
    if (newMax > max) max = newMax;
  }
  return max;
}
function recPresent_dep(n, level, dLevel, { lstFlatten, lstShow, lstOmit } = {}) {
  let n1 = jsCopy(n);
  n1 = filterByNoKey(n, lstOmit);
  mNode(n1, { dParent: dLevel[level], listOfProps: lstFlatten });
  if (nundef(n.children)) return level;
  let max = 0;
  for (const x of n.children) {
    let newMax = recPresent_dep(x, level + 1, dLevel, { lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
    if (newMax > max) max = newMax;
  }
  return max;
}
function recPresent_dep1(n, level, dLevel, lstFlatten, lstShow) {
  let n1 = jsCopy(n);
  n1 = filterByNoKey(n, ['sub', '_id', '_ref', 'children', 'source', 'specKey', 'params', 'cssParams', 'typParams', 'stdParams', 'uid', 'ui'])
  mNode(n1, { dParent: dLevel[level], listOfProps: lstFlatten });
  if (nundef(n.children)) return level;
  let max = 0;
  for (const x of n.children) {
    let newMax = recPresent_dep1(x, level + 1, dLevel, lstFlatten, lstShow);
    if (newMax > max) max = newMax;
  }
  return max;
}
function recPresentFilter(n, level, dLevel, { lf, ls, lo } = {}) {
  mNodeFilter(n, { dParent: dLevel[level], lstFlatten: lf, lstShow: ls, lstOmit: lo });
  if (nundef(n.children)) return level;
  let max = 0;
  for (const x of n.children) {
    let newMax = recPresentFilter(x, level + 1, dLevel, { lf: lf, ls: ls, lo: lo });
    if (newMax > max) max = newMax;
  }
  return max;
}
function recPresentNode_dep(n, R, sizing) {
  console.log('sizing', n.uid, sizing);
  if (isdef(n.children)) {
    for (const ch of n.children) {
      let n1 = R.uiNodes[ch];
      recPresentNode_dep(n1, R, getSizing(n1, R, sizing));
    }
  }
  if (sizing == 'sizeToContent') { }
  else if (sizing == 'fixed') { }
  else if (sizing == 'sizeChildren') { }
  else {
    if (isdef(n.children)) {
      let fLayout = n.params.layout;
      if (nundef(fLayout)) fLayout = RLAYOUT[n.type];
      if (nundef(fLayout)) fLayout = panelLayout;
      let szNeeded = fLayout(n, R);
    }
  }
}
function recRemove(n, R) {
  if (isdef(n.children)) {
    let ids = jsCopy(n.children);
    for (const ch of ids) recRemove(R.rNodes[ch], R);
  }
  delete R.rNodes[n.uid];
  R.unregisterNode(n);
  delete R.uiNodes[n.uid];
  let parent = R.rNodes[n.uidParent];
  removeInPlace(parent.children, n.uid);
  if (isEmpty(parent.children)) delete parent.children;
  let uiParent = R.uiNodes[n.uidParent];
  removeInPlace(uiParent.children, n.uid);
  if (isEmpty(uiParent.children)) delete uiParent.children;
}
function recShowHints(ilist, rc, delay = 3000, fProgression = d => d * 1.5) {
  if (isEmpty(ilist) || QContextCounter != rc) return;
  let i = ilist.shift();
  TOTrial = setTimeout(() => recShowHintsNext(i, ilist, rc, fProgression(delay), fProgression), delay);
}
function recShowHintsNext(i, ilist, rc, delay, fProgression) {
  showSayHint(i);
  if (QContextCounter == rc) recShowHints(ilist, rc, delay, fProgression);
}
function recShowTree(o, indent, childrenKeys, lstShow, lstOmit) {
  showObject(o, indent, true, lstShow, lstOmit);
  let chkey = findFirstListKey(o, childrenKeys);
  if (chkey) {
    console.log(' '.repeat(indent + 2) + chkey + ':');
    for (const ch of o[chkey]) {
      recShowTree(ch, indent + 4, childrenKeys, lstShow, lstOmit);
    }
  }
}
function recTree(n, rParent, R, oid, key) {
  let uid = getUID();
  let n1 = {};
  let chanav;
  [n, chanav] = mixinChannel(n, rParent, R);
  let expandProp = '_NODE'; let nodeName = n[expandProp];
  if (isString(nodeName)) {
    let nSpec = R.getSpec(nodeName);
    if (nundef(n.cond) && nundef(nSpec.cond)) {
      let merged = merge1(nSpec, n, { dataMerge: 'reverse' });
      delete merged._NODE;
      if (isdef(nSpec._NODE)) merged._NODE = nSpec._NODE;
      return recTree(merged, rParent, R, oid, key);
    } else if (n.cond) {
      n = merge1(nSpec, n, { dataMerge: 'none' });
      delete n._NODE;
    } else {
      if (n.cond) { console.log('ja, n.cond kann sein!!!!', '\nn', n, '\nnSpec', nSpec) }
      lookupAddToList(R.Locations, [nodeName], uid);
      n1.here = nodeName;
      if (nundef(n.data) && nundef(n.type)) n1.type = 'invisible';
    }
  } else if (isList(nodeName)) {
    console.log('REINGEFALLEN!!!!!!!!!!!!!!!!!!!!!!')
  }
  n1 = mergeOverrideArrays(n, n1);
  if (isdef(n1.sub)) delete n1.sub;
  n1.uid = uid;
  n1.uidParent = rParent ? rParent.uid : null;
  if (isdef(oid)) n1.oid = oid;
  if (chanav) n1.chanav = chanav;
  let chProp = 'sub'; let chlist = n[chProp];
  if (isdef(chlist)) {
    n1.children = [];
    for (const chInfo of chlist) {
      let ch = recTree(chInfo, n1, R, oid, key);
      R.rNodes[ch.uid] = ch;
      n1.children.push(ch.uid);
    }
  }
  return n1;
}
function recUi(n, R, area, oid, key) {
  let n1 = R.uiNodes[n.uid] = jsCopy(n);
  let o = isdef(oid) ? R.getO(oid) : null;
  if (isdef(n1.data)) { n1.content = calcContentFromData(oid, o, n1.data, R, n1.default_data); }
  if (n1.type == 'grid') {
    createBoard(n1, R, area);
  } else {
    let lst = getElements(n1.content);
    if (isdef(lst) && !isEmpty(lst)) {
      let o = R.getO(lst[0]);
      if (isListOfLiterals(lst) && isdef(o)) { handleListOfObjectIds(lst, n1, area, R); }
      else if (isListOfLists(lst) && isdef(o[0])) {
        for (const l of lst) { handleListOfObjectIds(l, n1, area, R); }
      }
      else {
        if (nundef(n1.type)) n1.type = 'info';
        n1.content = lst.join(' ');
        n1.ui = createUi(n1, R, area);
      }
      let rTreePanel = R.rNodes[n1.uid];
      n1.children = rTreePanel.children;
    } else {
      n1.ui = createUi(n1, R, area);
    }
  }
  if (nundef(n1.children) || n1.type == 'grid') return n1;
  n1.adirty = true;
  for (const ch of n1.children) {
    if (isdef(R.uiNodes[ch])) { continue; }
    recUi(R.rNodes[ch], R, n1.uid, oid, key);
  }
  return n1;
}
function recUiTestX(n, R) {
  let n1 = R.uiNodes[n.uid] = jsCopy(n);
  let area = isdef(n1.uidParent) ? n1.uidParent : R.baseArea;
  n1.ui = createUiTestX(n1, R, area);
  if (nundef(n1.children)) return;
  for (const ch of n1.children) {
    recUiTestX(R.rNodes[ch], R);
  }
}
function recVerify(series, index, maxIndex) {
  if (index > maxIndex) return;
  else setTimeout(() => doNext(series, index, maxIndex), 1000);
}
function redrawScreen() {
  checkCleanup_II();
  if (S.settings.userBehaviors) {
    loadCode0(userCode.asText, 'setUserSpecAndCode();proceedRedraw();', () => {
      console.log('setting code now!')
      setUserSpecAndCode();
      proceedRedraw();
    });
    console.log('userCode', userCode);
  }
  else proceedRedraw();
}
function reduce_to_current_players() {
  let d = mBy('d_players');
  let checkboxes = d.getElementsByTagName('input');
  let list = [];
  for (const chk of checkboxes) {
    if (chk.checked) {
      list.push(chk.value);
    }
  }
  populate_players(list);
}
function reduceBoard(board, rNew, cNew, iModify) {
  let [boardArrOld, rOld, cOld] = [board.fields.map(x => isdef(x.item) ? x.item.index : null), board.rows, board.cols];
  let rest = [];
  if (rOld > rNew) { rest = bGetRow(boardArrOld, iModify, rOld, cOld).filter(x => x != null); }
  else if (cOld > cNew) { rest = bGetCol(boardArrOld, iModify, rOld, cOld).filter(x => x != null); }
  let boardArrNew = new Array(rNew * cNew);
  for (let r = 0; r < rNew; r++) {
    for (let c = 0; c < cNew; c++) {
      let i = iFromRowCol(r, c, rNew, cNew);
      let x = (rOld != rNew) ? r : c;
      if (x < iModify) {
        let iOld = iFromRowCol(r, c, rOld, cOld);
        boardArrNew[i] = boardArrOld[iOld];
      }
      else {
        let [ir, ic] = (rOld != rNew) ? [r + 1, c] : [r, c + 1];
        let iOld = iFromRowCol(ir, ic, rOld, cOld);
        boardArrNew[i] = boardArrOld[iOld];
      }
    }
  }
  return { rows: rNew, cols: cNew, boardArr: boardArrNew, extras: rest };
}
function refillCharInput(inp, ch) { fillCharInput(inp, ch); }
function register(el, id, type, x, y, nid1, nid2) {
  let lst = addIfKeys(EC, [y, x], []);
  lst.push(el);
  lst = addIfKeys(ET, [type], []);
  lst.push(el);
  if (id in EID) {
  }
  EID[id] = el;
  if (type == 'edge' && nid1 !== undefined && nid2 !== undefined) {
    ENN[comp_(nid1, nid2)] = el;
  }
}
function register_menu_item(elem, key, handler) { }
function register_node(content, type, oid, path, r) {
  let n = {
    content: content,
    type: type,
    oid: oid,
    path: path,
    children: [],
  };
  r.add_node(n, oid);
  return n;
}
function registerAsNewItem(item) { item.id = iRegister(item); return item; }
function registeredItemCopy(orig) { let item = jsCopy(orig); item.id = iRegister(item); return item; }
function registerElement(mobj) {
  elements[mobj.id] = mobj;
}
function registerItems(items) {
  for (const i of items) UIS[i.div.id] = i;
}
function registerObject(what, props, mapping, mParentId) {
  ensureUIS();
  let mk = new MK();
  let id = mk.id = getUID();
  if (mParentId) mk.mParentId = mParentId;
  let oid = mk.oid = isDict(what) ? mapping.oid : what;
  let o = mk.o = isDict(what) ? what : isEmpty(props) ? getServerObject(oid) : mapping.omap;
  let myPath = mk.myPath = isDict(what) ? mapping.path + o.key : oid == mapping.oid ? oid + mapping.props.join('.') : what;
  mk.isLeaf = isDict(what) || oid != mapping.oid;
  let idType = mk.idType = 'm';
  listKey(path2mainIds, myPath, id);
  mk.mapping = mapping;
  linkObjects(id, oid);
  listKey(IdOwner, idType, id);
  UIS[id] = mk;
  return mk;
}
function registerObject_dep(o, idType, loc, rsgType) {
  let id = getUID();
  let mk = new MK();
  mk.o = o.o;
  mk.info = o.info;
  let oid = stringBefore(o.oid, '.');
  mk.oid = oid;
  mk.path = o.oid;
  mk.rsg = rsgType;
  mk.id = id;
  mk.idType = idType;
  mk.loc = loc;
  if (o.ui) registerUiFor(mk, o.ui);
  linkObjects(id, oid);
  listKey(IdOwner, idType, id);
  UIS[id] = mk;
  return mk;
}
function registerUiFor(mk, ui) { mk.elem = ui; mk.elem.id = mk.id; mk.parts.elem = ui; mk.domType = getTypeOf(ui); mk.cat = DOMCATS[mk.domType]; }
function reindex_items(items) { let i = 0; items.map(x => { x.index = i; i++; }); }
function reload() {
  console.log('reload!!!')
  if (radio_contacts.checked == true) get_contacts();
  else if (radio_chat.checked == true) get_chats();
  else if (radio_games.checked == true) get_games();
  else if (radio_play.checked == true) get_play();
}
function reload_assets() {
  const asset_names = {
    'Syms': 'allSyms',
    'users': 'db_users',
    'games': 'db_games',
    'tables': 'db_tables',
  }
  assets_get(arguments);
}
function reload_last_game_state() { if (!in_game_open_prompt()) open_prompt(Session.cur_me.state); }
function reload_prompt(fen) {
  console.assert(!uiActivated, 'open_prompt with uiActivated ON !!!!!!!!!!!!!!!!!!!!!!!!!!');
  let game = Session.cur_game;
  let uname = Session.cur_user;
  let g = Session;
  let next = lookup(DB.games, [game]); if (next) copyKeys(next, g);
  next = lookup(DB.users, [uname, 'games', game]); if (next) copyKeys(next, g);
  let level = g.level = valf(g.startlevel, g.def_startlevel);
  lookupSet(DB.users, [uname, 'games', game, 'startlevel'], level);
  next = lookup(DB.games, [game, 'levels']);
  if (next) copyKeys(next[level], g);
  g.maxlevel = valf(get_keys(next).length, 0) - 1;
  g.color = getColorDictColor(g.color);
  g.winning_score = Session.cur_table.options.winning_score;
  delete g.levels;
  clearTable(); set_background_color(g.color);
  QContextCounter += 1;
  show_game_name(g.friendly);
  show_title(g.table.friendly);
  show_level(g.level, g.maxlevel);
  if (Session.is_badges) setBadgeLevel(g.level);
  g.startTime = get_timestamp();
  mLinebreak(dTable, 15);
  let items = g.items = spotit_deal(g.num_cards, g.rows, g.cols, g.vocab, g.lang, g.min_scale, g.max_scale, fen);
  Selected = null;
}
function remove_all_region_endregion(code) {
  let lines = code.split(`\r\n`);
  let res = '';
  for (const line of lines) {
    let trimmed = line.trim();
    if (trimmed.startsWith('//')) continue;
    res += line + '\r\n';
  }
  return res;
}
function remove_card_shadow(c) { iDiv(c).firstChild.setAttribute('class', null); }
function remove_from_selection(card) {
  if (nundef(Z.A)) return;
  let A = Z.A;
  let item = firstCond(A.items, x => x.id == card.id);
  if (isdef(item)) {
    let idx = item.index;
    A.items.splice(item.index, 1);
    removeInPlace(A.selected, item.index);
    make_card_unselectable(item);
    make_card_unselected(item);
    reindex_items(A.items);
  }
}
function remove_hourglass(uname) { let d = mBy(`dh_${uname}`); if (isdef(d)) mRemove(d); }
function remove_hover_ui(b) { b.onmouseenter = null; b.onmouseleave = null; }
function remove_player(fen, uname) {
  if (nundef(fen.original_players)) fen.original_players = jsCopy(fen.players);
  removeInPlace(fen.plorder, uname);
  delete fen.players[uname];
  return fen.plorder;
}
function remove_tides_from_play(fen, plname, tides) {
  let pl = fen.players[plname];
  if (nundef(tides)) tides = pl.tides.keys;
  for (const tide of tides) {
    if (tide.path.includes('hand')) { removeInPlace(pl.hand, tide.key); }
    else if (tide.path.includes('stall')) { removeInPlace(pl.stall, tide.key); }
  }
  ari_history_list([`${plname} tides ${tides.map(x => x.key).join(', ')}!`], 'tide');
}
function remove_tithes_from_play(fen, plname, tithes) {
  let pl = fen.players[plname];
  if (nundef(tithes)) tithes = pl.tithes.keys;
  for (const tithe of tithes) {
    if (tithe.path.includes('hand')) { removeInPlace(pl.hand, tithe.key); }
    else if (tithe.path.includes('stall')) { removeInPlace(pl.stall, tithe.key); }
  }
  ari_history_list([`${plname} tithes ${tithes.map(x => x.key).join(', ')}!`], 'tithe');
}
function remove_ui_items(items) {
  console.log('remove_ui_items', items);
  for (const item of items) {
    let card = item.o;
    make_card_unselectable(item);
    iDiv(item.o).remove();
  }
}
function removeAllEvents(elem) {
  var a = elem.attributes, i, l, n;
  if (a) {
    for (i = a.length - 1; i >= 0; i -= 1) {
      n = a[i].name;
      if (typeof elem[n] === 'function') {
        console.log('.......removing', n, 'from', elem.id)
        elem[n] = null;
      }
    }
  }
}
function removeAllGlobalHandlers() {
  removeEventListener('keyup', keyUpHandler);
  removeEventListener('keydown', keyDownHandler);
  document.getElementById('login_form').removeEventListener('submit', onLoginSubmitted);
  document.getElementById('bLogout').removeEventListener('click', onClickLogout);
  if (USE_SOCKETIO) document.getElementById('chat_form').removeEventListener('submit', onChatSubmitted);
  document.getElementById('bJoinGame').removeEventListener('click', onClickJoinGameLobby);
  document.getElementById('bCreateGame').removeEventListener('click', onClickCreateGameLobby);
  document.getElementById('bResumeGame').removeEventListener('click', onClickResumeGameLobby);
}
function removeAllHighlighting(id) { let ms = UIS[id]; ms.unhighAll(); }
function removeAttributes(elem) {
  while (elem.attributes.length > 0) {
    elem.removeAttribute(elem.attributes[0].name);
  }
}
function removeBadgeAndRevertLevel() {
  removeBadges(dLeiste, currentLevel);
  setBackgroundColor();
  proceedIfNotStepByStep();
}
function removeBadges(dParent, level) {
  while (badges.length > level) {
    let badge = badges.pop();
    mRemove(iDiv(badge));
  }
}
function removeBoard(R) {
  let oid = detectFirstBoardObject(R);
  removeServerObject(oid, 'board');
}
function removeBorder(elem) {
  elem.style.border = null;
}
function removeByProp(arr, prop, val) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i][prop] === val) {
      arr.splice(i, 1);
      i--;
      return;
    }
  }
}
function removeCard(c, deck) { removeInPlace(deck, c); }
function removeCardFromHand(oid, hand, subArea) {
  let id = getMainId(oid);
  if (isdef(id)) {
    let mobj = UIS[id];
    mobj.detach();
    mobj.hand = null;
  }
  if (nundef(hand)) return;
  removeInPlace(hand.cards, oid);
  hand.numCards = hand.cards.length;
  _repositionCards(hand, subArea);
}
function removeCards(deck) {
  return removeTopNCards(deck, getNumCards(deck));
}
function removeCardsFromTo(deck, iFrom, iTo) {
  let n = iTo - iFrom + 1;
  return removeNCardsFrom(deck, iFrom, n);
}
function removeClass(el, clName) { if (!el) return; el.classList.remove(clName); }
function removeClickHandler(id) { let ms = UIS[id]; ms.removeHandlers(); }
function removeColNew(board, cClick) { return reduceBoard(board, board.rows, board.cols - 1, cClick); }
function removeCommentLines(text, cstart, cend) {
  let lines = text.split('\n');
  let inComment = false, res = '';
  for (const line of lines) {
    let lt = line.trim();
    if (lt.startsWith(cstart) && lt.endsWith(cend)) { continue; }
    if (lt.startsWith(cstart)) { inComment = true; continue; }
    if (lt.endsWith(cend)) { inComment = false; continue; }
    res += line + '\n';
  }
  return res;
}
function removeCommentsFromLine(line) {
  let l = line;
  if (!l.includes("`//") && !l.includes("'//") && !l.includes("//'") && !l.includes("http")) {
    l = replaceAllFast(line, '://', ':@@');
    l = replaceAllFast(l, '//#', '@@#');
    l = stringBefore(l, '//');
    l = replaceAllFast(l, '@@#', '//#');
    l = replaceAllFast(l, ':@@', '://');
  }
  if (l.trim().endsWith('*/')) l = stringBefore(l, '/*');
  return l;
}
function removeDOM(elem) { purge(elem); }
function removeDuplicates(keys, prop) {
  let di = {};
  let res = [];
  let items = keys.map(x => Syms[x]);
  for (const item of items) {
    if (isdef(di[item.best])) { continue; }
    res.push(item);
    di[item.key] = true;
  }
  return res.map(x => x.key);
}
function removeElem(elem) {
  removeAllEvents(elem);
  elem.remove();
}
function removeEmptyLines(x) {
  let lines = x.split('\n');
  lines = lines.filter(x => !isEmptyOrWhiteSpace(x));
  return lines.join('\n');
}
function removeEvents(elem) {
  for (const evname of arguments) {
    elem['on' + evname] = null;
  }
}
function removeFilterHighlight(ms) { ms.unhighC(); }
function removeFromArray(array, i) { return array.splice(i, 1)[0] }
function RemoveGUIPiece(sq) {
  $(".Piece").each(function (index) {
    if ((RanksBrd[sq] == 7 - Math.round($(this).position().top / 60)) && (FilesBrd[sq] == Math.round($(this).position().left / 60))) {
      $(this).remove();
    }
  });
}
function removeHoverHandlers(id) { let ms = UIS[id]; ms.removeHandlers(); }
function removeIf(arr, el) { removeInPlace(arr, el); }
function removeInPlace(arr, el) {
  arrRemovip(arr, el);
}
function removeInPlaceKeys(dict, keys) {
  for (const k of keys) {
    delete dict[k];
  }
}
function removeInteraction(id) { let ms = UIS[id]; ms.removeHandlers(); ms.unhighAll(); }
function removeItemFromArray(array, item) { return removeFromArray(array, array.indexOf(item)) }
function removeKeyHandler(k) {
  let f = lookup(DA, ['keyup', k]);
  if (lookup(DA, ['keyup', k])) {
    delete DA.keyup[k];
  }
  if (lookup(DA, ['keydown', k])) {
    delete DA.keydown[k];
  }
}
function removeLabel(item) {
  if (isdef(item.live.dLabel)) {
    item.live.dLabel.remove();
    delete item.live.dLabel;
  }
  return item;
}
function removeMarkers() {
  for (const m of Markers) {
    mRemoveGracefully(m);
  }
  Markers = [];
}
function removeNCardsFrom(deck, iFrom, n) {
  n = Math.min(getNumCards(deck), n);
  return deck.cards.splice(iFrom, n);
}
function removeNonAlphanum(s) {
  let res = '';
  let nonalphas = '';
  for (const l of s) {
    if (isAlphaNumeric(l)) res += l; else nonalphas += l;
  }
  return { alphas: res, whites: nonalphas };
}
function removeOidKey(oid, key, R) {
  let nodeInstances = lookup(R.rNodesOidKey, [oid, key]);
  if (!nodeInstances) {
    console.log('nothing to remove!', oid, key);
    return;
  }
  for (const uid of nodeInstances) {
    let n1 = R.rNodes[uid];
    recRemove(n1, R);
  }
}
function removeOuterDoors(house) {
  console.log(house.doors);
  for (const did of jsCopy(house.doors)) {
    console.log(did)
    let door = Items[did];
    iDiv(door).remove();
    console.log('door', door);
    for (const rid of door.rooms) { removeInPlace(Items[rid].doors, did); }
    removeInPlace(house.doors, did);
  }
  console.log(house.doors);
}
function removePeepFromCrowd(peep) {
  removeItemFromArray(crowd, peep)
  availablePeeps.push(peep)
}
function removePic(item) {
  let div = item.div;
  let newItem = getLbl(item.key, item.sz, item.bg, item.label);
  clearElement(div);
  mAppend(div, newItem.div.children[0]);
  delete item.pic;
  item.text = newItem.text;
}
function removePicture(pic, reorder = false) {
  removeInPlace(Pictures, pic);
  if (reorder) {
    iDiv(pic).remove();
    maLayout(Pictures, dTable);
  } else {
    iDiv(pic).style.opacity = 0;
  }
}
function removeRandomFromArray(array) { return removeFromArray(array, randomIndex(array)) }
function removeRobber(R) {
  let robberOid = firstCondDict(R._sd, x => x.o.obj_type == 'robber');
  if (nundef(robberOid)) {
    console.log('this test is not applicable!');
  }
  removeServerObject(robberOid, 'robber');
}
function removeRowNew(board, cClick) { return reduceBoard(board, board.rows - 1, board.cols, cClick); }
function removeServerObject(oid, label) {
  let o = R.getO(oid);
  if (nundef(o)) {
    console.log('object cannot be removed because not in R', oid);
    return;
  }
  if (isdef(label)) TV[label] = { oid: oid, o: o };
  let activate = R.isUiActive;
  if (activate) deactivateUis(R);
  delete sData[oid];
  completelyRemoveServerObjectFromRsg(oid, R);
  console.log('removed oid', oid);
  updateOutput(R);
  if (activate) activateUis(R);
}
function removeTopNCards(deck, n) {
  n = Math.min(getNumCards(deck), n);
  return deck.cards.splice(-n);
}
function removeTrailingComments(line) {
  let icomm = line.indexOf('//');
  if (icomm <= 0 || ':"`\''.includes(line[icomm - 1])) return line;
  if ([':', '"', "'", '`'].some(x => line.indexOf(x) >= 0 && line.indexOf(x) < icomm)) return line;
  return line.substring(0, icomm);
}
function render() {
  canvas.width = canvas.width
  cx.save()
  cx.scale(devicePixelRatio, devicePixelRatio)
  crowd.forEach((peep) => {
    peep.render(cx)
  })
  cx.restore()
}
function renderVisualStructures(ipal = 2) {
  for (const key in visualStructures) {
    let msList = visualStructures[key];
    let board = msList[0];
    board.setbg(getpal(ipal)).draw();
    ipal += 1;
    for (let i = 1; i < msList.length; i++) {
      msList[i].setbg(getpal(ipal)).draw();
    }
  }
}
function renewTimer(G, elem, onTimeOver = null) { if (nundef(GameTimer)) GameTimer = new TimerClass(G); GameTimer.restart(G, elem, onTimeOver); }
function repair_vars(superdi) {
  let varkeys = Object.keys(superdi.var);
  for (const varkey of varkeys) {
    if (['lifeView', 'exp', 'Deck', 'gridsize'].some(x => x == varkey)) { delete superdi.var[varkey]; continue; }
    let o = superdi.var[varkey];
    if (!o.sig.startsWith('var')) {
      o.sig = `var ${varkey}`
    }
    if (!o.code.startsWith('var')) {
      o.code = `var ${stringAfter(o.code, ' ')}`;
    }
    o.type = 'var';
  }
}
function repair_yaml_codebase() {
  let dir = 'C:\\xampp\\htdocs\\aroot\\basejs\\cb0\\';
  let superdi = get_current_superdi(dir);
  let [text, rejected, dinew] = assemble_consts(superdi);
  repair_vars(dinew);
  let dirout = 'C:\\xampp\\htdocs\\aroot\\basejs\\cb1\\';
  let [di2, justcode, history] = assemble_dicts(dinew);
  toYamlFile(di2, `${dirout}z_all${LG ? 'LG' : ''}.yaml`);
  toYamlFile(justcode, `${dirout}z_allcode${LG ? 'LG' : ''}.yaml`);
  toYamlFile(history, `${dirout}z_allhistory${LG ? 'LG' : ''}.yaml`);
}
function replace_jolly(key, j) {
  let jolly_idx = find_index_of_jolly(j);
  j[jolly_idx] = key;
}
function replaceAll(str, sSub, sBy) {
  let regex = new RegExp(sSub, 'g');
  return str.replace(regex, sBy);
}
function replaceAllFast(str, sSub, sBy) { return replaceAll(str, sSub, sBy); }
function replaceAllSafe(str, sSub, sBy) { return replaceAllSpecialChars(str, sSub, sBy); }
function replaceAllSpecialChars(str, sSub, sBy) { return str.split(sSub).join(sBy); }
function replaceALLTESTS(di, el) {
  let [key, code] = [el.key, el.code];
  delete di.const[key];
  let params = '';
  let body = stringAfter(code, '\r\n').trim();
  let text = `function ${key}(${params}) {\r\n`;
  text += `return {\r\n${body}\r\n}`;
  let o = el;
  o.code = text;
  o.sig = getFunctionSignature(stringBefore(text, '\r\n'), key);
  if (o.region == 'const') o.region = 'func'; //o.filename;
  o.type = 'func';
  di.func[key] = o;
  return di;
}
function replaceAllX(str, sSub, sBy) { return replaceAllSpecialChars(str, sSub, sBy); }
function replaceAtString(s, i, ssub) { return s.substring(0, i) + ssub + s.substring(i + 1); }
function replaceConstByFunc(di, el) {
  let [key, code] = [el.key, el.code];
  delete di.const[key];
  let params = stringBefore(code, '=>').trim();
  let body = stringAfter(code, '=>').trim();
  if (params.includes('(')) {
    params = stringBefore(params, ')');
    params = stringAfter(params, '(');
  } else params = '';
  let text = `function ${key}(${params}) {`;
  if (body.startsWith('{')) {
    text += stringAfter(body, '{');
    text = stringBeforeLast(text, '}') + '}';
  } else {
    text += 'return ' + body + '}';
  }
  let o = el;
  o.code = text;
  o.sig = getFunctionSignature(stringBefore(text, '\r\n'), key);
  if (o.region == 'const') o.region = 'func'; //o.filename;
  o.type = 'func';
  di.func[key] = o;
  return di;
}
function replaceEvery(w, letter, nth) {
  let res = '';
  for (let i = 1; i < w.length; i += 2) {
    res += letter;
    res += w[i];
  }
  if (w.length % 2) res += w[0];
  return res;
}
function replaceFractionOfWordBy(w, letter = 'w', fr = .5) {
  let len = Math.ceil(w.length * fr);
  let len1 = Math.floor(w.length * fr);
  let sub = letter.repeat(len);
  w = sub + w.substring(0, len1);
  return w;
}
function replaceIdName(sssname, R, workingSpec) {
  let newSpecNodeUids = {};
  for (const id of R.idarr) {
    let name = id.idName;
    if (name != sssname) continue;
    let spk = id.specKey;
    let idpath = id.ppath;
    let [key, obj] = findAddress(spk, workingSpec, idpath);
    let sub = [];
    for (const ref of R.refarr) {
      if (ref.idName != name) continue;
      let idnode = obj[key];
      let uid = getUID('sp');
      newSpecNodeUids[uid] = { uid: uid, ref: ref, id: id };
      let merged;
      if (isdef(idnode._merge) && idnode._merge == 'blend') {
        merged = merge1(ref.node, idnode);
        sub.push({ _NODE: uid });
      } else {
        merged = jsCopy(ref.node);
        let resultNode = jsCopy(idnode);
        resultNode._NODE = uid;
        delete resultNode._id;
        sub.push(resultNode);
      }
      delete merged._ref;
      delete merged._id;
      workingSpec[uid] = merged;
    }
    if (sub.length == 0) {
      if (isdef(R.lastSpec[name])) {
        obj[key]._NODE = name;
        delete obj[key]._id;
        alert('SPEC ERROR! =>please replace _id:' + name + ' by _NODE:', name);
      } else {
      }
    } else if (sub.length == 1) {
      if (isdef(obj[key]._NODE)) {
        let x = obj[key]._NODE;
        if (isList(x)) {
          x.unshift(sub[0]._NODE);
          obj[key]._NODE = jsCopy(x);
        } else {
          obj[key]._NODE = [x, sub[0]._NODE];
        }
      } else obj[key] = sub[0];
    } else {
      let res = obj[key];
      if (isdef(res._NODE)) {
        let x = res._NODE;
        for (let i = 0; i < sub.length; i++) sub[i]._NODE = [x, sub[i]._NODE];
        obj[key] = { sub: sub };
      } else obj[key] = { sub: sub };
    }
  }
  return newSpecNodeUids;
}
function replaceLabel(item, label) { }
function replaceNonEmptyByRandom(s, letters) {
  let res = '';
  for (const l of s) {
    if (l == ' ') res += ' '; else res += chooseRandom(letters);
  }
  return res;
}
function replacePic(item, key) { }
function replacePicAndLabel(item, key, label) {
  let div = item.div;
  let newItem = getPic(key, item.sz, item.bg, label);
  clearElement(div);
  mAppend(div, newItem.div.children[0]);
  mAppend(div, newItem.div.children[0]);
  item.pic = newItem.pic;
  item.text = newItem.text;
}
function replaceSol(sol, diop) {
  let rhs = stringBefore(sol, '=');
  let type = rhs.includes('*') ? rhs.includes('R') ? 'div' : 'mult' : rhs.includes('R') ? 'minus' : 'plus';
  let i = 0;
  while (i < rhs.length) {
    if (rhs[i] == 'R') { diop.R = getOperand(type); i += 1; }
    else if (rhs[i] == 'r' && !isLetter(rhs[i + 1])) { if (nundef(diop.r)) diop.r = getOperand(type); i += 1; }
    else if (rhs[i] == 'N') {
      i += 1;
      let inum = Number(rhs[i]);
      let k = 'N' + inum;
      if (nundef(diop[k])) diop[k] = getOperand(type);
      i += 1;
    } else if (rhs[i] == 'D') {
      i += 1;
      let inum = Number(rhs[i]);
      let k = 'D' + inum;
      i += 1;
      if (rhs[i] == '{') {
        let subs = rhs.substring(i);
        let inKlammern = stringBefore(subs, '}');
        rhs = rhs.substring(0, i) + stringAfter(subs, '}');
        i += inKlammern.length;
        let nums = allNumbers(inKlammern);
        diop[k] = chooseRandom(nums);
      } else if (nundef(diop[k])) {
        diop[k] = randomNumber(2, 9);
      }
    } else if (rhs[i] == 'F') {
      if (isdef(diop[rhs.substring(i, i + 2)])) { i += 2; continue; }
      let s_ab_i = rhs.substring(i);
      let s_vor_klammer_zu = stringBefore(s_ab_i, ')');
      let lenRaus = s_vor_klammer_zu.length + 1;
      let s_nach_fraction = stringAfter(s_ab_i, ')');
      let kFraction = s_ab_i.substring(0, 2);
      let kNum = s_ab_i.substring(3); kNum = stringBefore(kNum, ',');
      let kDenom = stringAfter(s_ab_i, ','); kDenom = stringBefore(kDenom, ')');
      rhs = rhs.substring(0, i) + 'math.fraction(' + kNum + ',' + kDenom + ')' + s_nach_fraction;
      let num = isNumber(kNum) ? Number(kNum) : isdef(diop[kNum]) ? diop[kNum] : null;
      let denom = isNumber(kDenom) ? Number(kDenom) : isdef(diop[kDenom]) ? diop[kDenom] : null;
      let fr = getRandomFraction(num, denom);
      diop[kFraction] = fr;
      if (!num) diop[kNum] = fr.n;
      if (!denom) diop[kDenom] = fr.d;
      i += 20;
    } else i += 1;
  }
  i = 0;
  while (i < rhs.length) {
    if (rhs[i] == 'n') {
      i += 1;
      let inum = Number(rhs[i]);
      let k = 'n' + inum;
      let kN = 'N' + inum;
      let x = diop[kN];
      if (nundef(diop[k])) diop[k] = randomNumber(2, x - 1);
      i += 1;
    } else i += 1;
  }
  let eq = rhs;
  for (const k in diop) {
    let val = diop[k];
    if (isFractionType(val)) val = `math.fraction(${val.n},${val.d})`;
    eq = eq.replace(k, val);
  }
  let result = eval(eq);
  let lhs = stringAfter(sol, '=').trim();
  if (isEmpty(lhs)) lhs = 'R';
  diop[lhs] = result;
  return [result, eq];
}
function replaceWhite(s, sby = '_') { let w = toWords(s); return w.join(sby); }
function report_poll(obj) {
  polling_shield_off();
  update_cur_table(obj);
  status_message_off();
  get_games();
}
function repositionCards(msCollection) {
  if (msCollection.numCards == 0) return;
  let dTitle = msCollection.parts.title;
  let dBody = msCollection.parts.hand;
  let dHand = msCollection.elem;
  let bTitle = getBounds(dTitle);
  let bBody = getBounds(dBody, true);
  let bHand = getBounds(dHand);
  let yBody = bTitle.height;
  let hHand = msCollection.hHand;
  let hAvailable = hHand - yBody;
  let wHand = bHand.width;
  let W = wHand;
  let H = hHand;
  let w = msCollection.wCard;
  let h = msCollection.hCard;
  let n = msCollection.numCards;
  let x, y, dx, padding;
  let offset = { x: 0, y: 0 };
  if (msCollection.adjustSize) {
    W = w + (n) * w / 4;
    H = h;
    padding = 0;
    msCollection.setSize(W + 2 * padding + yBody, H);
    x = padding + offset.x;
    y = padding + offset.y;
  } else {
    padding = x = y = 0;
  }
  dx = n > 1 ? (W - w) / (n - 1) : 0;
  if (dx > w) dx = w;
  let i = 0;
  for (const oidCard of msCollection.cards) {
    let id = getMainId(oidCard);
    let c = UIS[id];
    c.zIndex = c.elem.style.zIndex = i;
    i += 1;
    c.setPos(x, y);
    x += dx;
  }
}
function reset_context() { CONTEXT = null; }
function reset_db_values() {
  reset_winnerlist_for_all_games();
  reset_game_values_for_all_users();
}
function reset_elo(user, game) { set_elo(user, game, 100); }
function reset_game_values_for_all_users() { for (const uname in DB.users) { reset_game_values_for_user(uname); } }
function reset_game_values_for_user(user) {
  let defaults = {
    'gul': { gSpotit: { startlevel: 0 }, gMaze: { startlevel: 0 }, gAnagram: { startlevel: 0 } },
    'nasi': { gSpotit: { startlevel: 0 }, gMaze: { startlevel: 0 }, gAnagram: { startlevel: 0 } },
    'felix': { gSpotit: { startlevel: 5 }, gMaze: { startlevel: 5 }, gAnagram: { startlevel: 3 } },
    'lauren': { gSpotit: { startlevel: 5 }, gMaze: { startlevel: 5 }, gAnagram: { startlevel: 5 } },
    'mimi': { gSpotit: { startlevel: 0 }, gMaze: { startlevel: 0 }, gAnagram: { startlevel: 0 } },
  };
  let norm = {};
  for (const g in DB.games) {
    norm[g] = { startlevel: DB.games[g].def_startlevel };
  }
  lookupSetOverride(DB.users, [user, 'games'], valf(defaults[user], norm));
}
function reset_settings() {
  for (const k in settings) { settings[k] = defaults[k]; }
  show_settings();
}
function reset_winnerlist_for_all_games() { for (const gname in DB.games) { reset_winnerlist_for_game(gname); } }
function reset_winnerlist_for_game(game) { lookupSetOverride(DB.games, [game, 'winnerlist'], []); }
function reset_zoom_on_resize() {
  window.onresize = null;
  bodyZoom = 1.0;
  document.body.style.transform = 'none';
}
function resetActiveButton() {
  if (ActiveButton != null) {
    let ba = ActiveButton;
    mStyleX(ba, { bg: 'white', fg: 'black' });
    let caption = ba.id.substring(2);
    caption = separateAtCapitals(caption);
    ba.innerHTML = caption;
    ActiveButton = null;
  } else {
  }
}
function ResetBoard() {
  var index = 0;
  for (index = 0; index < BRD_SQ_NUM; ++index) {
    brd_pieces[index] = SQUARES.OFFBOARD;
  }
  for (index = 0; index < 64; ++index) {
    brd_pieces[SQ120(index)] = PIECES.EMPTY;
  }
  for (index = 0; index < 14 * 120; ++index) {
    brd_pList[index] = PIECES.EMPTY;
  }
  for (index = 0; index < 2; ++index) {
    brd_material[index] = 0;
  }
  for (index = 0; index < 13; ++index) {
    brd_pceNum[index] = 0;
  }
  brd_side = COLOURS.BOTH;
  brd_enPas = SQUARES.NO_SQ;
  brd_fiftyMove = 0;
  brd_ply = 0;
  brd_hisPly = 0;
  brd_castlePerm = 0;
  brd_posKey = 0;
  brd_moveListStart[brd_ply] = 0;
}
function resetPeep({ stage, peep }) {
  const direction = Math.random() > 0.5 ? 1 : -1
  const offsetY = 100 - 250 * gsap.parseEase('power2.in')(Math.random())
  const startY = stage.height - peep.height + offsetY
  let startX
  let endX
  if (direction === 1) {
    startX = -peep.width
    endX = stage.width
    peep.scaleX = 1
  } else {
    startX = stage.width + peep.width
    endX = 0
    peep.scaleX = -1
  }
  peep.x = startX
  peep.y = startY
  peep.anchorY = startY
  return {
    startX,
    startY,
    endX
  }
}
function resetPlayerCards() {
  for (const plid in serverData.players) {
    let pl = serverData.players[plid];
    if (GAME == 'catan') pl.devcards = { _set: [] }; else pl.hand = { _set: [] };
  }
}
function resetRound() {
  clearTimeouts();
  clearFleetingMessage();
  clearTable();
}
function resetScore() {
  Score = { gameChange: true, levelChange: true, nTotal: 0, nCorrect: 0, nCorrect1: 0, nPos: 0, nNeg: 0, labels: true };
}
function resetState() {
  clearTimeouts();
  pauseSound();
  onkeydown = null; onkeypress = null; onkeyup = null;
  lastPosition = 0;
  DELAY = 1000;
  setBackgroundColor();
}
function resetUIDs() { UIDCounter = 0; FRUIDCounter = -1; }
function resetUIS() {
  UIS = {};
  IdOwner = {};
  id2oids = {};
  oid2ids = {};
  id2uids = {};
}
function resize() {
  stage.width = canvas.clientWidth
  stage.height = canvas.clientHeight
  canvas.width = stage.width * devicePixelRatio
  canvas.height = stage.height * devicePixelRatio
  crowd.forEach((peep) => {
    peep.walk.kill()
  })
  crowd.length = 0
  availablePeeps.length = 0
  availablePeeps.push(...allPeeps)
  initCrowd()
}
function resizeBoard(nuiBoard, R) {
  let uidBoard = nuiBoard.uid;
  let sz = updateSizes(nuiBoard);
  nuiBoard.params.sizes = sz.sNew;
  let params = nuiBoard.params;
  let gap = params.field_spacing - sz.sOrig.f;
  params.field_spacing = sz.sNew.f + gap;
  for (const name of ['fields', 'edges', 'corners']) {
    let group = nuiBoard.bi[name];
    for (const oid in group) {
      let elSize_old = sz.sOrig[name[0]];
      let elSize = sz.sNew[name[0]];
      if (elSize_old == elSize) { continue; }
      let uid = R.getUidWithParent(oid, uidBoard);
      let n = R.uiNodes[uid];
      let ui = n.ui;
      let info = n.info;
      let shape = n.info.shape;
      n.info.size = elSize;
      n.size = { w: elSize, h: elSize };
      n.sizeMeasured = jsCopy(n.size);
      gSize(ui, elSize, elSize, shape);
      n.typParams.size = n.params.size = elSize;
    }
  }
  gridLayout(nuiBoard, R);
}
function resplay_container(targetgroup, ovpercent) {
  let d = iDiv(targetgroup);
  let card = Items[targetgroup.ids[0]];
  let ov = valf(targetgroup.ov, .1222)
  mContainerSplay(d, 2, card.w, card.h, arrChildren(d).length, ov * card.w);
  let items = arrChildren(d).map(x => Items[x.id]);
  ui_add_cards_to_hand_container(d, items);
}
function rest() { }
function restart_selection_process() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  if (Z.game != 'ferro') {
    console.log('attempt to restart selection process in non-ferro game!!!');
    return;
  }
  A.selectedCards.map(x => ari_make_unselected(x));
  mClear('dSelections0');
  Z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null, breadcrumbs: [], sib: [], command: null };
  Z.stage = 'card_selection';
  ferro_pre_action();
}
async function restartGame() {
  await sendRestart();
  d3.select('button').text('NEXT MOVE').on('click', interaction);
  gameStep();
}
function restartHost(callback) { let route = '/restart'; _sendRouteJS(route, callback); }
function restartQ() {
  QReset();
  console.log('===>RESET', QCounter, Q, AkQ);
}
function restartTime(elem) { TimestampStarted = msNow(); TimeElapsed = 0; startTime(elem); }
function restoreBehaviors() {
  PLAYER_UPDATE = {};
  TABLE_UPDATE = {};
  FUNCS = {};
  PLAYER_CREATE = {};
  TABLE_CREATE = {};
  V = {};
}
function restoreServerData() {
  resetPlayerCards();
  let opt = serverData.options;
  if (opt) {
    let keys = Object.keys(opt);
    let firstKey = keys[0];
    let actions = opt[firstKey].actions._set[0]._tuple[0]._set;
    removedActions.map(x => actions.push(x));
    removedActions = [];
  }
}
function retrieveState(prefix = '') {
  let pack = localStorage.getItem(prefix + '_pack');
  if (isdef(pack)) {
    pack = JSON.parse(pack);
    console.log('retrieved settings (baseColor)', pack.settings.baseColor);
    G.settings = pack.settings;
    Socket.emit('state', pack);
  } else {
    alert(`no settings ${prefix} in localStorage!`);
  }
}
function return_elem_to_deck_from(el, arr, deck) { elem_from_to(el, arr, deck); }
function reveal_church_cards() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  let uichurch = UI.church;
  let dOpenTable = UI.dOpenTable;
  let church_cards = uichurch.items;
  uichurch.container.remove();
  UI.church = uichurch = ui_type_market(fen.church, dOpenTable, { maleft: 25 }, 'church', 'church');
}
function reverse(x) {
  if (isString(x)) {
    var newString = "";
    for (var i = x.length - 1; i >= 0; i--) {
      newString += x[i];
    }
    return newString;
  }
  if (isList(x)) return x.reverse();
  if (isDict(x)) return dict2list(x, 'value').reverse();
  return x;
}
function reverseString(s) {
  return toLetterList(s).reverse().join('');
}
function rFloat(min = -1, max = 1) { return Math.random() * (max - min) + min; }
function rGaussian(min, max, int = false) {
  function rGauss() {
    var rand = 0;
    for (var i = 0; i < 6; i += 1) { rand += Math.random(); }
    return rand / 6;
  }
  return int ? Math.floor(min + rGauss() * (max - min + 1)) : min + rGauss() * (max - min);
}
function rgb2float(rgba) {
  return [
    rgba[0] / 255,
    rgba[1] / 255,
    rgba[2] / 255,
    rgba[3]
  ]
}
function rgb2hex(rgba) {
  var dig, hex = '#';
  for (var i = 0; i < 3; ++i) {
    dig = rgba[i];
    dig = dig.toString(16);
    hex += ('00' + dig).substr(dig.length);
  }
  return hex;
}
function rgb2hsl(r, g, b) {
  (r /= 255), (g /= 255), (b /= 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return [h, s, l];
}
function rgb2hsv(r, g, b) {
  let v = Math.max(r, g, b);
  let n = v - Math.min(r, g, b);
  let h = n && (v == r ? (g - b) / n : v == g ? 2 + (b - r) / n : 4 + (r - g) / n);
  h = 60 * (h < 0 ? h + 6 : h);
  s = v && n / v;
  return {
    h: h,
    s: s * 100,
    v: (v * 100) / 255
  };
}
function rgbaStr(rgba) {
  return 'rgba(' + rgba.join(',') + ')';
}
function RGBAToHex9(rgba) {
  let n = allNumbers(rgba);
  if (n.length < 3) {
    return randomHexColor();
  }
  let a = n.length > 3 ? n[3] : 1;
  let sa = alphaToHex(a);
  if (rgba.includes('%')) {
    n[0] = Math.round((n[0] * 255) / 100);
    n[1] = Math.round((n[1] * 255) / 100);
    n[2] = Math.round((n[2] * 255) / 100);
  }
  return '#' + ((1 << 24) + (n[0] << 16) + (n[1] << 8) + n[2]).toString(16).slice(1) + sa;
}
function RGBAToHSLA(rgba) {
  let ex = /^rgba\((((((((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5]),\s?)){3})|(((([1-9]?\d(\.\d+)?)|100|(\.\d+))%,\s?){3}))|(((((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5])\s){3})|(((([1-9]?\d(\.\d+)?)|100|(\.\d+))%\s){3}))\/\s)((0?\.\d+)|[01]|(([1-9]?\d(\.\d+)?)|100|(\.\d+))%)\)$/i;
  if (ex.test(rgba)) {
    let sep = rgba.indexOf(',') > -1 ? ',' : ' ';
    rgba = rgba
      .substr(5)
      .split(')')[0]
      .split(sep);
    if (rgba.indexOf('/') > -1) rgba.splice(3, 1);
    for (let R in rgba) {
      let r = rgba[R];
      if (r.indexOf('%') > -1) {
        let p = r.substr(0, r.length - 1) / 100;
        if (R < 3) {
          rgba[R] = Math.round(p * 255);
        }
      }
    }
    let r = rgba[0] / 255,
      g = rgba[1] / 255,
      b = rgba[2] / 255,
      a = rgba[3],
      cmin = Math.min(r, g, b),
      cmax = Math.max(r, g, b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;
    if (delta == 0) h = 0;
    else if (cmax == r) h = ((g - b) / delta) % 6;
    else if (cmax == g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    if (h < 0) h += 360;
    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';
  } else {
    return 'Invalid input color';
  }
}
function RGBtoHCV(RGB) {
  let P = RGB.g < RGB.b ? float4(RGB.bg, -1.0, 2.0 / 3.0) : float4(RGB.gb, 0.0, -1.0 / 3.0);
  let Q = RGB.r < P.x ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
  let C = Q.x - min(Q.w, Q.y);
  let H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);
  return float3(H, C, Q.x);
}
function rgbToHex(rgbStr) { return rgbStr && '#' + rgbStr.slice(4, -1).split(',').map(x => (+x).toString(16).padStart(2, '0')).join(''); }
function RGBToHex7(c) {
  let n = allNumbers(c);
  if (c.includes('%')) {
    n[0] = Math.round((n[0] * 255) / 100);
    n[1] = Math.round((n[1] * 255) / 100);
    n[2] = Math.round((n[2] * 255) / 100);
  }
  return '#' + ((1 << 24) + (n[0] << 16) + (n[1] << 8) + n[2]).toString(16).slice(1);
}
function rgbToHexCOOL(pixel) {
  const componentToHex = (c) => {
    const hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  };
  return (
    "#" +
    componentToHex(pixel.r) +
    componentToHex(pixel.g) +
    componentToHex(pixel.b)
  ).toUpperCase();
}
function RGBToHSL(rgb) {
  let ex = /^rgb\((((((((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5]),\s?)){2}|((((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5])\s)){2})((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5]))|((((([1-9]?\d(\.\d+)?)|100|(\.\d+))%,\s?){2}|((([1-9]?\d(\.\d+)?)|100|(\.\d+))%\s){2})(([1-9]?\d(\.\d+)?)|100|(\.\d+))%))\)$/i;
  if (ex.test(rgb)) {
    let sep = rgb.indexOf(',') > -1 ? ',' : ' ';
    rgb = rgb
      .substr(4)
      .split(')')[0]
      .split(sep);
    for (let R in rgb) {
      let r = rgb[R];
      if (r.indexOf('%') > -1) rgb[R] = Math.round((r.substr(0, r.length - 1) / 100) * 255);
    }
    let r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      cmin = Math.min(r, g, b),
      cmax = Math.max(r, g, b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;
    if (delta == 0) h = 0;
    else if (cmax == r) h = ((g - b) / delta) % 6;
    else if (cmax == g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    if (h < 0) h += 360;
    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return 'hsl(' + h + ',' + s + '%,' + l + '%)';
  } else {
    return 'Invalid input color';
  }
}
function rgbToHsl(r, g, b) {
  (r /= 255), (g /= 255), (b /= 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return [h, s, l];
}
function rgbToHsv(r, g, b) {
  let v = Math.max(r, g, b);
  let n = v - Math.min(r, g, b);
  let h = n && (v == r ? (g - b) / n : v == g ? 2 + (b - r) / n : 4 + (r - g) / n);
  h = 60 * (h < 0 ? h + 6 : h);
  s = v && n / v;
  return {
    h: h,
    s: s * 100,
    v: (v * 100) / 255
  };
}
function Rgen(R, cycle) {
  if (cycle > 10) { console.log('MAX!!!!!!!!!'); return; }
  let workingSpec = jsCopy(R.lastSpec);
  RgenIdRef(R);
  RgenArrays(R);
  let name = RsortIds(workingSpec, R);
  let genKey = 'G';
  R.gens[genKey].push(workingSpec);
  R.lastSpec = workingSpec;
  R.ROOT = R.lastSpec.ROOT;
  if (name && !isEmpty(R.allIdRefNames)) Rgen(R, cycle + 1);
}
function RgenArrays(R) {
  R.idarr = [];
  R.refarr = [];
  for (const name in R.places) {
    let idByName = R.places[name];
    for (const spk in idByName) {
      let placelist = idByName[spk];
      for (const el of placelist) {
        R.idarr.push(el);
      }
    }
  }
  for (const name in R.refs) {
    let refByName = R.refs[name];
    for (const spk in refByName) {
      let refslist = refByName[spk];
      for (const el of refslist) {
        R.refarr.push(el);
      }
    }
  }
  R.idByNode = {};
  R.idByName = {};
  for (const name in R.places) {
    let idByName = R.places[name];
    for (const spk in idByName) {
      let list = idByName[spk];
      for (const el of list) {
        lookupAddToList(R.idByNode, [spk], el);
        lookupAddToList(R.idByName, [name], el);
      }
    }
  }
  R.refByNode = {};
  R.refByName = {};
  for (const name in R.refs) {
    let refByName = R.refs[name];
    for (const spk in refByName) {
      let list = refByName[spk];
      for (const el of list) {
        lookupAddToList(R.refByNode, [spk], el);
        lookupAddToList(R.refByName, [name], el);
      }
    }
  }
  for (const id of R.idarr) {
  }
  if (nundef(R.allIdRefNames)) R.allIdRefNames = intersection(Object.keys(R.idByName), Object.keys(R.refByName));
}
function RgenIdRef(R, genKey = 'G') {
  let gen = R.lastSpec;
  if (nundef(R.orig_places) && !isEmpty(R.places)) R.orig_places = R.places;
  if (nundef(R.orig_refs) && !isEmpty(R.refs)) R.orig_refs = R.refs;
  R.places = {};
  R.refs = {};
  for (const k in gen) {
    let n = gen[k];
    R.check_ref(k, n);
  }
  for (const k in gen) {
    let n = gen[k];
    R.check_id(k, n, R);
  }
}
function rHue() { return (rNumber(0, 36) * 10) % 360; }
function rInc(o, prop, min, max) { o[prop] += rNumber(min, max); return o[prop]; }
function rLetter(except) { return rLetters(1, except)[0]; }
function rLetters(n, except = []) {
  let all = 'abcdefghijklmnopqrstuvwxyz';
  for (const l of except) all = all.replace(l, '');
  console.log('all', all, except)
  return rChoose(toLetters(all), n);
}
function rMappings() {
  mappings = SPEC.mappings;
  if (nundef(mappings)) return false;
  let lst = odict2olist(mappings);
  console.log('_______________', mappings, lst);
  mappings = odict2olist(mappings).map(x => { let k = stringBefore(x.id, '.'); mappingTypes[k] = x[k] = true; return x; });
  console.log('mappings', mappings, mappingTypes);
}
function rMergeSpec() {
  SPEC = deepmerge(defaultSpec, userSpec, { arrayMerge: overwriteMerge });
  if (userSpec.layout_alias) { SPEC.areas = userSpec.layout_alias; }
  if (userSpec.areas) { SPEC.areas = userSpec.areas; }
  delete SPEC.layout_alias;
  delete SPEC.asText;
  if (SHOW_SPEC) mById('SPEC').innerHTML = '<pre>"' + jsonToYaml(SPEC) + '"</pre>';
  _initAutoplayToActionButtons();
  _initCheatButtons();
  _initScenarioButtons();
}
function rName(n = 1) { let arr = MyNames; return rChoose(arr, n); }
function rNoise(channel, min, max, speed = 0.02) {
  if (nundef(Perlin.channels[channel])) Perlin.channels[channel] = rNumber(0, 10000);
  let lastx = Perlin.channels[channel];
  if (nundef(speed)) speed = Perlin.speed;
  lastx += speed;
  Perlin.channels[channel] = lastx;
  let r01 = rPerlin(lastx);
  let n = map_range(r01, 0, 1, min, max);
  return n;
}
function rnPosition(o, speed) {
  let [xoff, yoff] = isdef(o.origin) ? [-o.origin.x, -o.origin.y] : [0, 0];
  return [o.x, o.y] = [rNoise('x', 0, o.w, speed) + xoff, rNoise('y', 0, o.h, speed) + yoff];
}
function rNumber(min = 0, max = 100) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function robbedDescInBoats() {
  for (const id of IdOwner.a) {
    let boat = UIS[id];
    let desc = boat.desc;
    if (desc == 'robbed') {
      console.log('skip robbed!');
      return true;
    }
  }
  return false;
}
function rollback() {
  if (isdef(DA.snapshot)) {
    Z.fen = DA.snapshot.fen;
    Z.stage = DA.snapshot.stage;
    Z.round = DA.snapshot.round;
    Z.phase = DA.snapshot.phase;
    Z.turn = DA.snapshot.turn;
  }
}
function roomAdjacency(house) {
  let rooms = house.rooms.map(x => Items[x]);
  for (let i = 0; i < rooms.length; i++) {
    for (let j = i + 1; j < rooms.length; j++) {
      let [r1, r2] = [rooms[i], rooms[j]];
      let [e1, e2] = [r1.rect, r2.rect];
      let rhoeher = e1.t < e2.t ? r1 : r2;
      let rleft = e1.x < e2.x ? r1 : r2;
      let rniedriger = (rhoeher == r1 ? r2 : r1);
      let rright = (rleft == r1 ? r2 : r1);
      let diff = 2 * house.wallWidth;
      let y1 = Math.max(e1.t, e2.t);
      let y2 = Math.min(e1.b, e2.b);
      let dCommony = y2 - y1;
      if (dCommony > diff && isCloseTo(rright.rect.l, rleft.rect.r)) {
        let dr = {
          x: rleft.rect.r - house.rect.l,
          y: rniedriger.rect.t - house.rect.t,
          w: rright.rect.l - rleft.rect.r,
          h: dCommony,
        };
        extendRect(dr);
        addAdjacencyFromTo(rleft, rright, 'e', dr);
      }
      let x1 = Math.max(e1.l, e2.l);
      let x2 = Math.min(e1.r, e2.r);
      let dCommonx = x2 - x1;
      if (dCommonx > diff && isCloseTo(rniedriger.rect.t, rhoeher.rect.b)) {
        let dr = {
          x: rright.rect.l - house.rect.l,
          y: rhoeher.rect.b - house.rect.t,
          w: dCommonx,
          h: house.wallWidth
        };
        extendRect(dr);
        addAdjacencyFromTo(rhoeher, rniedriger, 's', dr);
      }
    }
  }
  for (let i = 0; i < rooms.length; i++) {
    let r = rooms[i];
    if (isCloseTo(r.rect.l, house.rect.l)) {
      let wallRect = { x: house.rect.l, y: r.rect.t, w: house.wallWidth, h: r.rect.h };
      extendRect(wallRect);
      addAdjacencyFromTo(r, null, 'w', wallRect);
    }
    if (isCloseTo(r.rect.r, house.rect.r)) {
      let wallRect = { x: r.rect.r, y: r.rect.t, w: house.wallWidth, h: r.rect.h };
      extendRect(wallRect);
      addAdjacencyFromTo(r, null, 'e', wallRect);
    }
    if (isCloseTo(r.rect.t, house.rect.t)) {
      let wallRect = { x: r.rect.l, y: house.rect.t, w: r.rect.w, h: house.wallWidth };
      extendRect(wallRect);
      addAdjacencyFromTo(r, null, 'n', wallRect);
    }
    if (isCloseTo(r.rect.b, house.rect.b)) {
      let wallRect = { x: r.rect.l, y: r.rect.b, w: r.rect.w, h: house.wallWidth };
      extendRect(wallRect);
      addAdjacencyFromTo(r, null, 's', wallRect);
    }
  }
}
function root(areaName) {
  setTableSize(areaName, 400, 300);
  UIROOT = jsCopy(SPEC.staticSpec.root);
  for (const k in AREAS) delete AREAS[k];
  PROTO = {};
  INFO = {};
  staticArea(areaName, UIROOT);
  addAREA('root', UIROOT);
}
function round_change_animation(n = 2) {
  let [stage, A, fen, plorder, uplayer, deck] = [Z.stage, Z.A, Z.fen, Z.plorder, Z.uplayer, Z.deck];
  let pl = fen.players[uplayer];
  if (pl.roundchange) {
    let d = mBy('dTitleLeft');
    mStyle(d, { 'transform-origin': '0% 0%' });
    mPulse(d, n * 1000);
    show_special_message(`${fen.round_winner} won round ${Z.round - 1}!!!`)
    delete pl.roundchange;
  }
}
function roundEven(n) {
  let res = Math.round(n);
  return res % 2 != 0 ? res - 1 : res;
}
function roundNumber(x, n) { return x.toFixed(n); }
async function route_allGames() {
  let gameNames = await route_server_js('/game/available');
  let res = {};
  for (const name of gameNames) {
    if (USE_ALL_GAMES_ROUTE) {
      res[name] = await route_server_js('/game/info/' + name);
    } else {
      let url = '/games/' + name + '/info.yaml';
      res[name] = await route_path_yaml_dict(url);
    }
  }
  return res;
}
async function route_begin_status(username, seed = SEED) {
  await fetch_wrapper(SERVER + '/begin/' + seed);
  let data = await route_status(username);
  return data;
}
async function route_c52() {
  return await route_rsg_asset('c52_blackBorder', 'yaml');
}
async function route_iconChars() {
  let gaIcons = await route_rsg_asset('gameIconCodes');
  let faIcons = await route_rsg_asset('faIconCodes');
  let dIcons = {};
  for (const k in faIcons) {
    dIcons[k] = faIcons[k];
  }
  for (const k in gaIcons) {
    dIcons[k] = gaIcons[k];
  }
  return dIcons;
}
async function route_initGame(game, gc, username, seed = SEED) {
  await fetch_wrapper(SERVER + '/restart');
  await fetch_wrapper(SERVER + '/game/select/' + game);
  let nPlayers = gc.numPlayers;
  for (plid in gc.players) {
    let plInfo = gc.players[plid];
    let isAI = plInfo.agentType !== null;
    if (isAI) {
      await postData(SERVER + '/add/client/agent/' + plInfo.username, { agent_type: plInfo.agentType, timeout: null });
    }
    await fetch_wrapper(SERVER + '/add/player/' + plInfo.username + '/' + plInfo);
  }
  return await route_begin_status(username, seed);
}
async function route_path_asText_dict(url) {
  let data = await fetch_wrapper(url);
  let res = {};
  res.asText = await data.text();
  return res;
}
async function route_path_json(url) {
  let data = await fetch(url);
  let o = await data.json();
  return o;
}
async function route_path_json_dict(url) {
  let data = await fetch_wrapper(url);
  let json = await data.json();
  return json;
}
async function route_path_text(url) {
  let data = await fetch(url);
  let text = await data.text();
  return text;
}
async function route_path_yaml_dict(url) {
  let data = await fetch(url);
  let text = await data.text();
  let dict = jsyaml.load(text);
  return dict;
}
function route_post_json(url, o, callback) { post_json(url, o, callback); }
async function route_rsg_asset(filename, ext = 'yml') {
  let url = '/assets/' + filename + '.' + ext;
  let response = await route_path_yaml_dict(url);
  return response;
}
async function route_rsg_raw_asset(filename, ext = 'yml') {
  let url = '/assets/raw/' + filename + '.' + ext;
  let response = await route_path_yaml_dict(url);
  return response;
}
async function route_server(url) { await fetch_wrapper(SERVER + url); }
async function route_server_js(url) {
  let data = await fetch_wrapper(SERVER + url);
  return await data.json();
}
async function route_server_text(url) {
  let data = await fetch_wrapper(SERVER + url);
  let text = await data.text();
  return text;
}
async function route_status(username) { return await route_server_js('/status/' + username); }
async function route_svgDict(filename = 'svgDict') {
  let url = '/assets/' + filename + '.yaml';
  let response = await route_path_yaml_dict(url);
  return response;
}
async function route_symbolDict(filename = 'symbolDict') {
  let url = '/assets/' + filename + '.yaml';
  let response = await route_path_yaml_dict(url);
  return response;
}
async function route_test_userSpec(url) {
  try {
    let text = await route_path_text(url);
    let spec = jsyaml.load(text);
    spec.asText = text;
    return spec;
  } catch (error) {
    return { asText: '' };
  }
}
async function route_userCode(game, fname) {
  try {
    let url = '/RSG/' + game + (isdef(fname) ? '/' + fname : '');
    let text = await route_server_text(url);
    return { asText: text };
  } catch (error) { return {}; }
}
async function route_userSpec(game, fname) {
  try {
    let url = '/spec/' + game + (isdef(fname) ? '/' + fname : '');
    let text = await route_server_text(url);
    let spec = jsyaml.load(text);
    spec.asText = text;
    return spec;
  } catch (error) {
    return { asText: '' };
  }
}
async function rParse(source, context) {
  R = await generateTree(source, context);
  timit.show('present');
  await presentTree(R.root, R);
  showSetSizes(R.root, R);
  adjustTableSize(R);
  if (ACTIVATE_UI) {
    activateUis(R);
  }
  timit.show('done!')
  updateOutput(R);
  if (source == 'main') testEngine.verify(R);
}
function rPassword(n) { return rChoose(toLetters('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!.?*&%$#@:;_'), n).join(''); }
function rPerlin(x, y = 0, z = 0) {
  Perlin.lastx = x;
  if (Perlin.perlin == null) {
    Perlin.perlin = new Array(Perlin.PERLIN_SIZE + 1);
    for (let i = 0; i < Perlin.PERLIN_SIZE + 1; i++) {
      Perlin.perlin[i] = Math.random();
    }
  }
  if (x < 0) { x = -x; }
  if (y < 0) { y = -y; }
  if (z < 0) { z = -z; }
  let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
  let xf = x - xi;
  let yf = y - yi;
  let zf = z - zi;
  let rxf, ryf;
  let r = 0;
  let ampl = 0.5;
  let n1, n2, n3;
  for (let o = 0; o < Perlin.perlin_octaves; o++) {
    let of = xi + (yi << Perlin.PERLIN_YWRAPB) + (zi << Perlin.PERLIN_ZWRAPB);
    rxf = Perlin.scaled_cosine(xf);
    ryf = Perlin.scaled_cosine(yf);
    n1 = Perlin.perlin[of & Perlin.PERLIN_SIZE];
    n1 += rxf * (Perlin.perlin[(of + 1) & Perlin.PERLIN_SIZE] - n1);
    n2 = Perlin.perlin[(of + Perlin.PERLIN_YWRAP) & Perlin.PERLIN_SIZE];
    n2 += rxf * (Perlin.perlin[(of + Perlin.PERLIN_YWRAP + 1) & Perlin.PERLIN_SIZE] - n2);
    n1 += ryf * (n2 - n1);
    of += Perlin.PERLIN_ZWRAP;
    n2 = Perlin.perlin[of & Perlin.PERLIN_SIZE];
    n2 += rxf * (Perlin.perlin[(of + 1) & Perlin.PERLIN_SIZE] - n2);
    n3 = Perlin.perlin[(of + Perlin.PERLIN_YWRAP) & Perlin.PERLIN_SIZE];
    n3 += rxf * (Perlin.perlin[(of + Perlin.PERLIN_YWRAP + 1) & Perlin.PERLIN_SIZE] - n3);
    n2 += ryf * (n3 - n2);
    n1 += Perlin.scaled_cosine(zf) * (n2 - n1);
    r += n1 * ampl;
    ampl *= Perlin.perlin_amp_falloff;
    xi <<= 1;
    xf *= 2;
    yi <<= 1;
    yf *= 2;
    zi <<= 1;
    zf *= 2;
    if (xf >= 1.0) { xi++; xf--; }
    if (yf >= 1.0) { yi++; yf--; }
    if (zf >= 1.0) { zi++; zf--; }
  }
  return r;
};
function rPlayerOrder(players) { return shuffle(jsCopy(players)); }
function rPlayerStatsAreas() {
  if (nundef(serverData.players)) return;
  if (nundef(SPEC.playerStatsAreas)) return;
  let loc = SPEC.playerStatsAreas.loc;
  let dOthers = mById(loc);
  if (nundef(dOthers)) return;
  let func = SPEC.playerStatsAreas.type;
  let objects = [];
  for (const plid in serverData.players) {
    let o = serverData.players[plid];
    if (plid != GAMEPLID) {
      o.id = plid;
      objects.push(o)
    }
  }
  let areaNames = objects.map(x => x.name);
  let structObject = window[func](areaNames, loc);
}
function rPosition(o) {
  let [xoff, yoff] = isdef(o.origin) ? [-o.origin.x, -o.origin.y] : [0, 0];
  return [o.x, o.y] = [rNumber(0, o.w) + xoff, rNumber(0, o.h) + yoff];
}
function rPresentDefault() {
  for (const kPool of ['table', 'players']) {
    let pool = serverData[kPool];
    let isTable = kPool == 'table';
    for (const oid in pool) {
      let o = pool[oid];
      let otype = o.obj_type;
      let mk = getVisual(oid);
      let mkDefault = getDefaultVisual(oid);
      if (!mk) {
        if ('loc' in o && SPEC.useLocPropertyForPlacement) mk = makeMainBoardElementVisual(oid, o);
      }
      if (!mk && !mkDefault && SPEC.table && SPEC.table.createDefault != false) {
        let loc = SPEC[kPool] && SPEC[kPool].defaultArea ? SPEC[kPool].defaultArea : 'a_d_objects';
        mkDefault = makeDefaultObject(oid, o, loc);
      }
      if (mkMan.getDone(oid)) continue;
      if (mk) {
        if (o.loc && SPEC.useLocPropertyForPlacement) _presentLocationChange(oid, o, mk, isTable);
        if (otype in mappingTypes && SPEC.ignoreStructureTypesInPresentation) continue;
        presentMain(oid, o, mk);
      }
      if (mkDefault) {
        presentDefault(oid, o, mkDefault, isTable);
      }
    }
  }
}
function rPresentMappings() {
  if (isdef(serverData.players)) {
    presentMappings(GAMEPLID, serverData.players[GAMEPLID]);
  }
  for (const plid in serverData.players) {
    if (plid != GAMEPLID) presentMappings(plid, serverData.players[plid]);
  }
  for (const oid in serverData.table) { presentMappings(oid, serverData.table[oid]); }
}
function rPrimaryColor() { let c = '#' + rChoose(['ff', '00']) + rChoose(['ff', '00']); c += c == '#0000' ? 'ff' : c == '#ffff' ? '00' : rChoose(['ff', '00']); return c; }
function rRank(ranks = 'A23456789TJQK') { return rChoose(ranks); }
function rrto(r1, r2) {
  let r = jsCopy(r1);
  r.x -= r2.x; r.l -= r2.x; r.r -= r2.x;
  r.y -= r2.y; r.t -= r2.y; r.b -= r2.y;
  return r;
}
function RsortIds(workingSpec, R) {
  let hasid = {};
  let noid = {};
  let cycles1 = 0; let max1 = 2;
  let cycles2 = 0; let max2 = 2;
  for (const name in R.idByName) {
    let reflist = R.refByName[name];
    for (const ref of reflist) {
      let nref = ref.node;
      let akku = {};
      recFindProp(nref, '_id', 'self', akku);
      if (isEmpty(akku)) {
        ref.hasid = false;
        if (nundef(noid[name])) noid[name] = [];
        noid[name].push(ref);
      } else {
        ref.hasid = true;
        ref.idOccurrences = jsCopy(akku);
        if (nundef(hasid[name])) hasid[name] = []; hasid[name].push(ref);
      }
    }
  }
  if (isEmpty(noid)) {
    return null;
  } else {
    let name = Object.keys(noid)[0];
    let newSpecUids = replaceIdName(name, R, workingSpec);
    if (nundef(R.namesReplaced)) R.namesReplaced = [];
    R.namesReplaced.push(name);
    removeInPlace(R.allIdRefNames, name);
    return name;
  }
  return null;
}
function rSuit(suit = 'HSDC') { return rChoose(suit); }
function rumor_playerdata_complete() {
  for (const pldata of Z.playerdata) {
    if (isEmpty(pldata.state) || !isEmpty(pldata.state.remaining)) return false;
  }
  return true;
}
function rumor_update_playerdata(data, receiver, rumor) {
  let remaining = arrMinus(data.state.remaining, rumor.key);
  lookupAddToList(data, ['state', 'di', receiver], rumor.key);
  lookupAddToList(data, ['state', 'receivers'], receiver);
  lookupSetOverride(data, ['state', 'remaining'], remaining);
  Z.state = data.state;
}
function run_for_seconds(secs, f, interval = 50) {
  DA.start = get_now(); doit(secs, f, interval);
}
function run03(sp, defaults, sdata) {
  R = new RSG(sp, defaults, sdata);
  console.log('before gen10 habe', R.gens.G.length, R.getSpec());
  phase = 1013;
  R.gen10();
  R.gen11();
  R.gen12();
  R.gen13();
  phase = 14;
  R.gen14();
  phase = 21;
  R.gen21('table');
  presentRoot_dep(R.getSpec().ROOT, 'tree');
}
function run04(sp, defaults, sdata) {
  WR.G = R1 = new RSG(sp, defaults, sdata);
  genG('table', R1);
  setTimeout(() => binding01(WR.G), 500);
}
function run05(sp, defaults, sdata) {
  WR.inc = R = new RSG(sp, defaults, sdata);
  ensureRtree(R);
  generateUis('table', R);
  updateOutput(R);
}
function run06(sp, defaults, sdata) {
  WR.inc = T = R = new RSG(sp, defaults, sdata);
  ensureRtree(R);
  R.baseArea = 'table';
  createStaticUi(R.baseArea, R);
  updateOutput(R);
  addNewlyCreatedServerObjects(sdata, R);
  updateOutput(R);
  for (let i = 0; i < 5; i++) testAddObject(R);
  updateOutput(R);
  activateUis(R);
}
function run07() {
  let d = mDiv(mBy('table'));
  mSize(d, 400, 300);
  mColor(d, 'blue');
  let canvas = aSvgg(d);
  let svg = d.children[0];
  console.log('svg', svg);
  createfilter(svg, "-50%", "-50%", "200%", "200%", ["feGaussianBlur"], ["stdDeviation", "5"]);
  let g1 = agShape(canvas, 'circle', 50, 50, 'gold');
  let ci = g1.children[0];
  console.log(ci);
  addClass(d, 'blur')
}
function run08() {
  let d = mDiv(mBy('table'));
  mSize(d, 400, 300);
  mColor(d, 'blue');
  let canvas = aSvgg(d);
  let svg = d.children[0];
  let g1 = agShape(canvas, 'rect', 250, 250, 'gold');
  let text = agText(g1, 'hallo', 'black', '16px AlgerianRegular').elem;
  let ci = g1.children[0];
  var defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  var filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
  filter.setAttribute("id", "f1");
  var gaussianFilter = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
  gaussianFilter.setAttribute("stdDeviation", "2");
  filter.appendChild(gaussianFilter);
  defs.appendChild(filter);
  svg.appendChild(defs);
  text.setAttribute("filter", "url(#f1)");
}
function run09() {
  let paper = mDivG('table', 400, 300, 'blue');
  let svg = paper.parentNode;
  let u = `<use x="100" y="100" xlink:href="assets/svg/animals.svg#bird" />`;
  console.log(svg);
  return;
  let g = agShape(canvas, 'rect', 250, 250, 'gold');
}
function runAllTests() {
  iTEST = 0;
  startTestLoop();
}
function runAllTestSeries() {
  iTEST = 0;
  iTESTSERIES = 1;
  startTestSeries();
}
function runBEHAVIOR(oid, pool, behList, VisList) {
  let res = {};
  for (const functionPair of behList) {
    let doFilterFunc = functionPair[0];
    let doFunc = functionPair[1];
    let o = pool[oid];
    if (nundef(o) || !doFilterFunc(oid, o)) {
      continue;
    }
    for (const functionPair of VisList) {
      let visFilterFunc = functionPair[0];
      let visFunc = functionPair[1];
      console.log(o);
      if (visFilterFunc(oid, o)) {
        let params = doFunc(oid, o);
        visFunc(oid, o, ...params);
        for (const par of params) {
          if (isDict(par) && 'id' in par) res[par.id] = par;
        }
      }
    }
  }
  return res;
}
function runBEHAVIOR_new(oid, pool, behaviors) {
  let res = {};
  for (const name in behaviors) {
    let o = pool[oid];
    let todo = behaviors[name](oid, o, G.serverData.phase);
    if (isdef(todo)) {
      let params = isdef(todo.vis) ? todo.vis.map(x => getVisual(x)) : [];
      for (const vis of params) clearElement(vis.elem);
      let res = todo.f(oid, o, ...params);
    }
  }
  return res;
}
function runBehaviors(oid, pool, behaviors) {
  let res = [];
  for (const name in behaviors) {
    let o = pool[oid];
    let todo = behaviors[name](oid, o, G.serverData.phase);
    if (isdef(todo)) {
      let visualsToBeUpdated = isdef(todo.vis) ? todo.vis.map(x => getVisual(x)) : [];
      let updated = FUNCS[todo.f](oid, o, ...visualsToBeUpdated);
      if (updated) res.push(oid);
    }
  }
  return res;
}
function runBindings(oid, pool) {
  for (const k in BINDINGS) {
  }
}
function runClientTest() {
  imageFileTests();
}
function runcode(code, callback = null) {
  let x = eval(code);
  if (callback) callback(x);
  else {
    console.log('===>result:', x);
    if (isdef(dMessage)) dMessage.innerHTML = isDict(x) ? JSON.stringify(x) : isdef(x) ? x.toString() : x;
  }
}
function runderkreis(color, id) {
  return `<div id=${id} style='width:20px;height:20px;border-radius:50%;background-color:${color};color:white;position:absolute;left:0px;top:0px;'>` + '' + "</div>";
}
function rUniqueId(n) { return rChoose(toLetters('0123456789abcdefghijklmnopqABCDEFGHIJKLMNOPQRSTUVWXYZ_'), n).join(''); }
async function runNextSeries(listSeries, series, from, to) {
  let timeOUT = 500;
  if (isEmpty(listSeries)) {
    console.log('*** ALL TESTS COMPLETED! ***');
    hide('btnStop');
    isTraceOn = SHOW_TRACE;
    return;
  } else if (STOP) {
    STOP = false;
    isTraceOn = SHOW_TRACE;
    hide('btnStop');
    return;
  } else if (from >= to) {
    let series = testEngine.series;
    removeInPlace(listSeries, series);
    if (isEmpty(listSeries)) {
      console.log('*** ALL TESTS COMPLETED! ***');
      STOP = false;
      isTraceOn = SHOW_TRACE;
      hide('btnStop');
      return;
    }
    series = listSeries[0];
    let imax = await testEngine.loadSeries(series);
    setTimeout(async () => { await runNextSeries(listSeries, series, 0, imax); }, timeOUT * 2);
  } else {
    let series = listSeries[0];
    let index = from;
    await testEngine.loadTestCase(series, index);
    await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
    setTimeout(async () => { await runNextSeries(listSeries, series, from + 1, to); }, timeOUT);
  }
}
function runTest() {
  editLayoutTests();
}
function runToDevdeckAction() { onClickRunToAction('devdeck'); }
function rVowel(w, except = []) { let vowels = w ? getVowels(w, except) : toLetters('aeiouy'); return chooseRandom(vowels); }
function rWheel(n = 1, hue = null, sat = 100, bri = 50) {
  let d = 360 / n;
  let h = valf(hue, rHue());
  let arr = [];
  for (let i = 0; i < n; i++) {
    console.log('h', h)
    let r = colorFromHSL(h, sat, bri);
    h = (h + d) % 360;
    arr.push(r);
  }
  return arr;
}
function safeLoop(func, params) {
  let max = 100, i = 0;
  while (i < max) {
    i += 1;
    let res = func(...params);
    if (isdef(res)) return res;
  }
  console.log('safeLoop: max reached!!!!!!!!!');
  return null;
}
function safeMerge(a, b) {
  if (nundef(a) && nundef(b)) return {};
  else if (nundef(a)) return jsCopy(b);
  else if (nundef(b)) return jsCopy(a);
  else return mergeOverrideArrays(a, b);
}
function safeRecurse(o, func, params, tailrec) {
  ___enteredRecursion = 0;
  let arr = Array.from(arguments);
  arr = arr.slice(1);
  recAllNodes(o, func, params, tailrec, true);
  return ___enteredRecursion;
}
function sameCaseIn(s1, s2) {
  return s1.toLowerCase() == s2.toLowerCase();
}
function sameCaseIndep(s1, s2) {
  return s1.toLowerCase() == s2.toLowerCase();
}
function sameCaseInsensitive(s1, s2) {
  return s1.toLowerCase() == s2.toLowerCase();
}
function sameList(l1, l2) {
  if (l1.length != l2.length) return false;
  for (const s of l1) {
    if (!l2.includes(s)) return false;
  }
  return true;
}
function sameProps(o1, o2) {
  let diff = propDiffGSM(o1, o2);
  return !diff.hasChanged;
}
function sameStringify(o1, o2) {
  return JSON.stringify(o1) == JSON.stringify(o2);
}
function sat() {
  let R = T;
  let rtree = normalizeRTree(R);
  let sol = {};
  sol[testEngine.index] = rtree;
  downloadFile(sol, 'sol' + testEngine.index);
}
function satall() { testEngine.saveSolutions(); }
function save_all() {
  let data = [];
  for (const edit of DA.edits) {
    let rect = getRect(edit);
    let text = edit.innerHTML;
    let o = { x: rect.x, y: rect.y, text: text };
    data.push(o);
  }
  route_post_json('http://localhost:3000/post/json', { data: data, filename: 'page' }, response => {
  });
}
function save_image_at_server(id, uploadFilename) {
  if (nundef(uploadFilename)) uploadFilename = 'baustellenimage';
  window.scrollTo(0, 0);
  html2canvas(document.getElementById(id)).then(function (canvas) {
    let imgData = canvas.toDataURL("image/jpeg", 0.9);
    var ajax = new XMLHttpRequest();
    ajax.open("POST", "server/save_url_encoded_image.php", true);
    ajax.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    ajax.send("image=" + canvas.toDataURL("image/jpeg", 0.9) + "&filename=" + uploadFilename + ".jpg");
    ajax.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        let udata = get_current_userdata();
        if (!udata.image) { udata.image = true; db_save(); }
        get_login();
      }
    };
  });
}
function save_users(db_dirty = true) {
  if (isdef(G)) U.lastGame = G.id;
  if (!startsWith(Session.cur_user, 'test')) localStorage.setItem('user', Session.cur_user);
  DB.users[Session.cur_user] = U;
  if (db_dirty) db_save();
}
function saveAnswerStatistic() {
  let g = CurrentGameData;
  let items = last(g.levels).items;
  console.log(items);
  let correctAnswers = items.filter(x => x.isCorrect && x.answer == x.reqAnswer);
  console.log('correctAnswers', correctAnswers)
  let saveable = correctAnswers.map(x => {
    console.log(x); return { key: x.key, reqAnswer: x.reqAnswer, answer: x.answer };
  });
  saveable.map(x => console.log('correct:', x.key, x.reqAnswer, x.answer));
  downloadAsYaml({ correct: saveable }, 'CORRECT');
}
function saveEnv() {
  fiddleSave();
}
function saveFile(name, type, data) {
  if (data != null && navigator.msSaveBlob) return navigator.msSaveBlob(new Blob([data], { type: type }), name);
  var a = $("<a style='display: none;'/>");
  var url = window.URL.createObjectURL(new Blob([data], { type: type }));
  a.attr('href', url);
  a.attr('download', name);
  $('body').append(a);
  a[0].click();
  setTimeout(function () {
    window.URL.revokeObjectURL(url);
    a.remove();
  }, 500);
}
function saveFileAtClient(name, type, data) {
  if (data != null && navigator.msSaveBlob) return navigator.msSaveBlob(new Blob([data], { type: type }), name);
  let a = document.createElement('a');
  a.style.display = 'none';
  let url = window.URL.createObjectURL(new Blob([data], { type: type }));
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  simulateClick(a);
  setTimeout(function () {
    window.URL.revokeObjectURL(url);
    a.remove();
  }, 500);
}
function saveGame() { }
function saveJsonAtServer(jsonObject, filename) {
  event.preventDefault();
  var labels = ['hallo', 'das', 'ist'];
  $.ajax({
    url: '/postTest',
    type: 'POST',
    data: JSON.stringify(jsonObject),
    processData: false,
    contentType: 'application/json; charset=UTF-8',
    success: function (response) {
      testHelpers(response);
    },
    error: function (error) {
      testHelpers(error);
    }
  });
}
function saveListOfWords() {
  let phrases = Object.keys(DD);
  phrases.sort();
  let text = phrases.join('\n');
  downloadAsText(text, 'listOfWords');
}
function saveObject(o, name) { localStorage.setItem(name, JSON.stringify(o)); }
function saveSettings() { }
async function saveSIMA() {
  if (BlockServerSend) {
    setTimeout(saveSIMA, 1000);
  } else {
    let url = SERVERURL + 'speechGames';
    BlockServerSend = true;
    fetch(url, {
      method: 'PUT',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(DB)
    }).then(() => { BlockServerSend = false; });
  }
}
async function saveSolutions(series, solutions) {
  let keys = Object.keys(solutions);
  let n = firstNumber(keys[0]);
  keys.sort(x => Number(x)).reverse();
  let sortedObject = {};
  for (const k of keys) {
    let x = sortKeys(solutions[k]);
    sortedObject[' ' + k + ' '] = x;
  }
  downloadFile(sortedObject, 'solutions' + series);
}
function saveState(prefix = '') {
  let st = G.state;
  let state = { boardArr: st.boardArr, poolArr: st.poolArr, pool: {} };
  for (const k in st.pool) {
    let oNew = state.pool[k] = {};
    copyKeys(st.pool[k], oNew, {}, ['index', 'key']);
  }
  let pack = { settings: G.settings, state: state, randomIndices: G.randomIndices };
  localStorage.setItem(prefix + '_pack', JSON.stringify(pack));
  return pack;
}
function saveStateAndSettings() {
  onClickSaveState();
  console.assert(BaseColor == G.settings.baseColor, 'Colors do NOT match at saving state!!!')
  onClickSaveSettings();
}
function saveStats() {
  let g = lastCond(CurrentSessionData.games, x => x.name == 'gSayPicAuto');
  let xxx = last(g.levels).items
  let yyy = xxx.map(x => {
    let res = { key: x.goal.key, answer: x.goal.answer, req: x.goal.reqAnswer, conf: x.goal.confidence, isCorrect: x.isCorrect };
    return res;
  });
  downloadAsYaml({ data: yyy }, 'dataSIMPLE');
}
function saveSymbolDict() {
  let y = jsonToYaml(symbolDict);
  downloadTextFile(y, 'symbolDict', 'yaml');
}
function saveTable(sendToDB = false) { lookupSet(DB.tables, [Tablename], T); if (sendToDB) dbSave(); }
function saveToDownloads(data, fname) {
  json_str = JSON.stringify(data);
  saveFile(fname + '.json', 'data:application/json', new Blob([json_str], { type: '' }));
}
function saveUnit() { saveUser(); }
function saveUser() {
  U.lastGame = G.id;
  if (!startsWith(Username, 'test')) localStorage.setItem('user', Username);
  DB.users[Username] = U;
  dbSaveX();
}
function say(text, lang, callback, volume, rate, pitch) {
  function sayit(text, lang, callback, volume, rate, pitch) {
    var text = valf(text, 'Hello, world!');
    var msg = new SpeechSynthesisUtterance();
    var voices = DA.voicelist;
    let voice = voices.filter(x => x.lang.includes(lang));
    if (isEmpty(voice)) voice = voices.filter(x => x.name.toLowerCase().includes(lang));
    msg.voice = valf(rChoose(voice), rChoose(voices));
    if (isdef(volume)) msg.volume = volume;
    if (isdef(rate)) msg.rate = rate;
    if (isdef(pitch)) msg.pitch = pitch;
    msg.text = text;
    msg.onend = e => {
      if (callback) callback(); else console.log('ENDE', e.utterance, 'Finished in ' + e.elapsedTime + ' seconds.');
    };
    speechSynthesis.speak(msg);
  }
  if (!('speechSynthesis' in window)) { alert('speech not supported!!! connect to internet?'); return; }
  if (nundef(DA.voicelist)) {
    speechSynthesis.onvoiceschanged = function () {
      DA.voicelist = speechSynthesis.getVoices();
      sayit(text, lang, callback, volume, rate, pitch);
    }
  } else sayit(text, lang, callback, volume, rate, pitch);
}
function sayRandomVoice(e, g, voice = 'random') {
  if (arguments.length == 1) voice = 'random';
  let [r, p, v] = [.8, .9, 1];
  if (!G.silentMode) Speech.say(G.language == 'E' || nundef(g) ? e : g, r, p, v, voice);
}
function sayTryAgain() { sayRandomVoice('try again!', 'nochmal'); }
function Scene() {
  touchable = 'createTouch' in document;
  this.canvas = document.createElement("canvas");
  document.body.appendChild(this.canvas);
  this.context = this.canvas.getContext("2d");
  this.clear = function () {
    this.context.clearRect(0, 0, this.width, this.height);
  }
  this.start = function () {
    if (!touchable) {
      this.initKeys();
      document.onkeydown = this.updateKeys;
      document.onkeyup = this.clearKeys;
    }
    this.intID = setInterval(localUpdate, 1000 / FRAMERATE);
  }
  this.stop = function () {
    clearInterval(this.intID);
  }
  this.updateKeys = function (e) {
    currentKey = e.keyCode;
    keysDown[e.keyCode] = true;
  }
  this.clearKeys = function (e) {
    currentKey = null;
    keysDown[e.keyCode] = false;
  }
  this.initKeys = function () {
    for (keyNum = 0; keyNum < 256; keyNum++) {
      keysDown[keyNum] = false;
    }
  }
  this.setSizePos = function (height, width, top, left) {
    styleString = "";
    styleString += "position: absolute; \n";
    styleString += "height: " + height + "px;\n";
    styleString += "width: " + width + "px;\n";
    styleString += "top: " + top + "px;\n";
    styleString += "left: " + left + "px;\n";
    this.height = height;
    this.width = width;
    this.top = top;
    this.left = left;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.canvas.style.left = this.left;
    this.canvas.style.top = this.top;
  }
  this.setSize = function (width, height) {
    this.width = width;
    this.height = height;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
  }
  this.setPos = function (left, top) {
    this.left = left;
    this.top = top;
    this.canvas.style.left = left;
    this.canvas.style.top = top;
  }
  this.setBG = function (color) {
    this.canvas.style.backgroundColor = color;
  }
  this.setSize(SCENEWIDTH, SCENEHEIGHT);
  this.setPos(10, 100);
  this.setBG("lightgray");
}
function scoring(isCorrect) {
  Score.nTotal += 1;
  if (isCorrect) { Score.nCorrect += 1; if (G.trialNumber == 1) Score.nCorrect1 += 1; }
  percentageCorrect = Math.round(100 * Score.nCorrect / Score.nTotal);
  if (isCorrect) { Score.nPos += 1; Score.nNeg = 0; } else { Score.nPos = 0; Score.nNeg += 1; }
  let levelChange = 0;
  let gameChange = false;
  let nextLevel = G.level;
  let toggle = G.pictureLabels == 'toggle';
  let hasLabels = G.showLabels == true;
  let boundary = G.samplesPerGame;
  let pos = G.incrementLevelOnPositiveStreak;
  let posSeq = pos > 0 && Score.nPos >= pos;
  let halfposSeq = pos > 0 && Score.nPos >= pos / 2;
  let neg = G.decrementLevelOnNegativeStreak;
  let negSeq = neg > 0 && Score.nNeg >= neg;
  let halfnegSeq = neg > 0 && Score.nNeg >= neg / 2;
  let labelsNextRound = G.showLabels;
  if (halfposSeq && hasLabels && toggle) { labelsNextRound = false; }
  else if (posSeq) { levelChange = 1; nextLevel += 1; Score.nPos = 0; }
  if (halfnegSeq && !hasLabels && toggle) { labelsNextRound = true; }
  else if (negSeq) { levelChange = -1; if (nextLevel > 0) nextLevel -= 1; Score.nNeg = 0; }
  if (nextLevel != G.Level && nextLevel > 0 && nextLevel <= G.maxLevel) {
    userUpdate(['games', G.id, 'startLevel'], nextLevel);
  }
  if (Score.nTotal >= boundary) {
    gameChange = true; levelChange = false;
  }
  if (levelChange || gameChange) {
    if (toggle) labelsNextRound = true;
  } else if (!halfnegSeq && toggle && hasLabels && Score.nTotal >= G.samplesPerGame / 2) {
    labelsNextRound = false;
  }
  G.showLabels = labelsNextRound;
  Score.gameChange = gameChange;
  Score.levelChange = levelChange;
  return nextLevel;
}
function scoring_update(players, winners, game) {
  for (const p of players) {
    let info = lookupSet(DB.users, [p, 'games', game], {});
    let total = lookupSet(info, ['total'], 0);
    let wins = lookupSet(info, ['wins'], 0);
    lookupSetOverride(info, ['total'], total + 1);
  }
  for (const p of winners) {
    let info = lookup(DB.users, [p, 'games', game]);
    let wins = lookup(info, ['wins']);
    console.assert(isdef(info) && isdef(wins), 'SCORING DB INFO MISSING FOR ' + p);
    lookupSetOverride(info, ['wins'], wins + 1);
  }
}
function scrambleInputs(d) {
  let children = Array.from(d.children);
  shuffle(children);
  for (const ch of children) {
    mAppend(d, ch);
  }
}
function screen_transition(idnew, idold) {
  if (isdef(idold)) mFade(idold, 500, () => mClassReplace(idold, 'd-block', 'd-none'), 'linear');
  mAppear(idnew, 500, () => mClassReplace(idnew, 'd-none', 'd-block'), 'linear');
}
function scrollToTop() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
function search_end_point(f, min, max, lower, upper) {
  if (SICHERER-- < 0) { console.log('!!!!!!!!!!'); return 0; }
  let x = min + (max - min) / 2;
  let y = f(x);
  if (y > upper) { return search_end_point(f, x, max, lower, upper); }
  else if (y < lower) { return search_end_point(f, min, x, lower, upper); }
  else return x;
}
function SearchPosition() {
  var bestMove = NOMOVE;
  var bestScore = -INFINITE;
  var currentDepth = 0;
  var pvNum = 0;
  var line;
  ClearForSearch();
  if (GameController.BookLoaded == BOOL.TRUE) {
    bestMove = BookMove();
    if (bestMove != NOMOVE) {
      $("#OrderingOut").text("Ordering:");
      $("#DepthOut").text("Depth: ");
      $("#ScoreOut").text("Score:");
      $("#NodesOut").text("Nodes:");
      $("#TimeOut").text("Time: 0s");
      $("#BestOut").text("BestMove: " + PrMove(bestMove) + '(Book)');
      srch_best = bestMove;
      srch_thinking = BOOL.FALSE;
      return;
    }
  }
  for (currentDepth = 1; currentDepth <= srch_depth; ++currentDepth) {
    bestScore = AlphaBeta(-INFINITE, INFINITE, currentDepth, BOOL.TRUE);
    if (srch_stop == BOOL.TRUE) break;
    pvNum = GetPvLine(currentDepth);
    bestMove = brd_PvArray[0];
    line = ("Depth:" + currentDepth + " best:" + PrMove(bestMove) + " Score:" + bestScore + " nodes:" + srch_nodes);
    if (currentDepth != 1) {
      line += (" Ordering:" + ((srch_fhf / srch_fh) * 100).toFixed(2) + "%");
    }
    domUpdate_depth = currentDepth;
    domUpdate_move = bestMove;
    domUpdate_score = bestScore;
    domUpdate_nodes = srch_nodes;
    domUpdate_ordering = ((srch_fhf / srch_fh) * 100).toFixed(2);
  }
  $("#BestOut").text("BestMove: " + PrMove(bestMove));
  UpdateDOMStats();
  srch_best = bestMove;
  srch_thinking = BOOL.FALSE;
}
function select_action(r, action, uname, item) {
  uiActivated = false;
  r.selected = action;
  console.log('action selected:', r.key, uname, action, item);
  window[r.key + '_post'](Session.otree, r, uname, action, item);
}
function select_add_items(items, callback = null, instruction = null, min = 0, max = 100, prevent_autoselect = false) {
  let A = Z.A;
  select_clear_previous_level();
  A.level++; A.items = items; A.callback = callback; A.selected = []; A.minselected = min; A.maxselected = max;
  console.log('A.level', A.level)
  show_stage();
  let dInstruction = mBy('dSelections0');
  mClass(dInstruction, 'instruction');
  mCenterCenterFlex(dInstruction);
  dInstruction.innerHTML = (Z.role == 'active' ? `${get_waiting_html()}<span style="color:red;font-weight:bold;max-height:25px">You</span>` : `${Z.uplayer}`) + "&nbsp;" + instruction;
  if (too_many_string_items(A)) { mLinebreak(dInstruction, 4); }
  let has_submit_items = false;
  let buttonstyle = { maleft: 10, vmargin: 2, rounding: 6, padding: '4px 12px 5px 12px', border: '0px solid transparent', outline: 'none' }
  for (const item of A.items) {
    let type = item.itemtype = is_card(item) ? 'card' : isdef(item.o) ? 'container' : 'string';
    if (isdef(item.submit_on_click)) { has_submit_items = true; }
    let id = item.id = lookup(item, ['o', 'id']) ? item.o.id : getUID(); A.di[id] = item;
    if (type == 'string') {
      let handler = ev => select_last(item, isdef(item.submit_on_click) ? callback : select_toggle, ev);
      item.div = mButton(item.a, handler, dInstruction, buttonstyle, null, id);
    } else {
      let ui = item.div = iDiv(item.o);
      ui.onclick = ev => select_last(item, select_toggle, ev);
      ui.id = id;
    }
  }
  let show_submit_button = !has_submit_items && (A.minselected != A.maxselected || !A.autosubmit);
  if (show_submit_button) { mButton('submit', callback, dInstruction, buttonstyle, 'selectable_button', 'bSubmit'); }
  let show_restart_button = A.level > 1;
  if (show_restart_button) { mButton('restart', onclick_reload, dInstruction, buttonstyle, 'selectable_button', 'bReload'); }
  let dParent = window[`dActions${A.level}`];
  for (const item of A.items) { ari_make_selectable(item, dParent, dInstruction); }
  assertion(A.items.length >= min, 'less options than min selection!!!!', A.items.length, 'min is', min);
  if (A.items.length == min && !is_ai_player() && !prevent_autoselect) {
    for (const item of A.items) { A.selected.push(item.index); ari_make_selected(item); }
    if (A.autosubmit) {
      loader_on();
      setTimeout(() => { if (callback) callback(); loader_off(); }, 800);
    }
  } else if (is_ai_player()) {
    ai_move();
  } else if (TESTING && isdef(DA.test)) {
    if (DA.test.iter >= DA.auto_moves.length) {
      if (isdef(DA.test.end)) DA.test.end();
      activate_ui();
      return;
    }
    let selection = DA.auto_moves[DA.test.iter++];
    if (selection) {
      deactivate_ui();
      let numbers = [];
      for (const el of selection) {
        if (el == 'last') {
          numbers.push(A.items.length - 1);
        } else if (el == 'random') {
          numbers.push(rNumber(0, A.items.length - 1));
        } else if (isString(el)) {
          let commands = A.items.map(x => x.key);
          let idx = commands.indexOf(el);
          numbers.push(idx);
        } else numbers.push(el);
      }
      selection = numbers;
      A.selected = selection;
      if (selection.length == 1) A.command = A.items[A.selected[0]].key;
      A.last_selected = A.items[A.selected[0]];
      select_highlight();
      setTimeout(() => {
        if (A.callback) A.callback();
      }, 1000);
    } else { activate_ui(); }
  } else { activate_ui(); }
}
function select_clear_previous_level() {
  let A = Z.A;
  if (!isEmpty(A.items)) {
    console.assert(A.level >= 1, 'have items but level is ' + A.level);
    A.ll.push({ items: A.items, selected: A.selected });
    let dsel = mBy(`dSelections1`);
    mStyle(dsel, { display: 'flex', 'align-items': 'center', padding: 10, box: true, gap: 10 });
    for (const item of A.items) {
      ari_make_unselectable(item);
      if (A.keep_selection) continue;
      ari_make_unselected(item);
      if (!A.selected.includes(item.index)) continue;
      if (item.itemtype == 'card') {
        let d = iDiv(item);
        let card = item.o;
        let mini = mDiv(dsel, { bg: 'yellow', fg: 'black', hpadding: 2, border: '1px solid black' }, null, card.friendly);
      } else if (item.itemtype == 'container') {
        let list = item.o.list;
        let cards = list.map(x => ari_get_card(x, 30, 30 * .7));
        let cont2 = ui_make_hand_container(cards, dsel, { bg: 'transparent' });
        ui_add_cards_to_hand_container(cont2, cards, list);
      } else if (item.itemtype == 'string') {
        let db = mDiv(dsel, { bg: 'yellow', fg: 'black', border: 'black', hpadding: 4 }, item.id, item.a);
      }
    }
  }
}
function select_confirm_weiter(callback) {
  select_add_items(ui_get_string_items(['weiter']), callback, 'may click to continue', 1, 1, Z.mode == 'multi');
}
function select_error(msg, callback = null, stay = false) {
  let [A] = [Z.A];
  DA.callback = callback;
  if (A.maxselected == 1 && A.selected.length > 0) {
    let item = A.items[A.selected[0]];
    ari_make_unselected(item);
    A.selected = [];
  } else if (A.selected.length == 2) {
    let item = A.items[A.selected[1]];
    ari_make_unselected(item);
    A.selected = [A.selected[0]];
  }
  dError.innerHTML = msg;
  if (stay) {
    dError.innerHTML += '<br><button onclick="continue_after_error()">CLICK TO CONTINUE</button>';
  } else {
    TO.error = setTimeout(continue_after_error, 3000);
  }
}
function select_finalize(ev) {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  let A = z.A;
  let id = evToId(ev);
  let a = A.di[id];
  A.selected = [a.index];
  A.selected_key = A.items[a.index].key;
  mStyle(mBy(a.idButton), { bg: 'yellow' });
  if (isdef(a.idCard)) mClass(mBy(a.idCard), 'card_selected');
  if (A.callback) A.callback();
}
function select_goto_post() {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  ari_post_action();
}
function select_goto_pre() {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  ari_pre_action();
}
function select_highlight() { let A = Z.A; for (const i of A.selected) { let a = A.items[i]; ari_make_selected(a, true); } }
function select_last(item, callback, ev) {
  if (isdef(ev)) evNoBubble(ev);
  Z.A.last_selected = item; callback(item, ev);
}
function select_timer(ms, callback) {
  let d = mBy('dSelections0');
  let dtimer = mDiv(d, { w: 80, maleft: 10, fg: 'red', weight: 'bold' }, 'dTimer');
  if (isdef(DA.timer)) { DA.timer.clear(); DA.timer = null; }
  let timer = DA.timer = new SimpleTimer(dtimer, 1000, null, ms, callback);
  timer.start();
  return dtimer;
}
function select_toggle() {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  let A = Z.A;
  let item = A.last_selected;
  if (A.selected.includes(item.index)) {
    removeInPlace(A.selected, item.index);
    ari_make_unselected(item);
  } else {
    if (A.maxselected == 1 && !isEmpty(A.selected)) { ari_make_unselected(A.items[A.selected[0]]); A.selected = []; }
    A.selected.push(item.index);
    ari_make_selected(item);
    if (!DA.ai_is_moving && A.selected.length >= A.maxselected && A.autosubmit) {
      setTimeout(() => A.callback(), 100);
    }
  }
}
function selectBuyDeckcard() { onClickSelectTuple(null, strategicBoat(['devdeck'])); }
function selectColor(color) {
  document.getElementsByClassName(selected_color)[0].classList.remove('selected');
  document.getElementsByClassName(color)[0].classList.add('selected');
  selected_color = color;
}
function selectGame(callback) { let route = '/game/select/' + GAME; _sendRouteJS(route, callback); }
function selectStyle(feature) {
  const color = feature.get('COLOR') || '#eeeeee';
  selected.getFill().setColor(color);
  return selected;
}
function selectText(el) {
  if (el instanceof HTMLTextAreaElement) { el.select(); return; }
  var sel, range;
  if (window.getSelection && document.createRange) {
    sel = window.getSelection();
    if (sel.toString() == '') {
      window.setTimeout(function () {
        range = document.createRange();
        range.selectNodeContents(el);
        sel.removeAllRanges();
        sel.addRange(range);
      }, 1);
    }
  } else if (document.selection) {
    sel = document.selection.createRange();
    if (sel.text == '') {
      range = document.body.createTextRange();
      range.moveToElementText(el);
      range.select();
    }
  }
}
function selectTextOrig(id) {
  var sel, range;
  var el = document.getElementById(id);
  if (window.getSelection && document.createRange) {
    sel = window.getSelection();
    if (sel.toString() == '') {
      window.setTimeout(function () {
        range = document.createRange();
        range.selectNodeContents(el);
        sel.removeAllRanges();
        sel.addRange(range);
      }, 1);
    }
  } else if (document.selection) {
    sel = document.selection.createRange();
    if (sel.text == '') {
      range = document.body.createTextRange();
      range.moveToElementText(el);
      range.select();
    }
  }
}
function selectUid(uid, R) {
  console.log('user has selected', uid);
}
function selectWord(info, bestWordIsShortest, except = []) {
  let candidates = info.words.filter(x => x.length >= MinWordLength && x.length <= MaxWordLength);
  let w = bestWordIsShortest ? getShortestWord(candidates, false) : last(candidates);
  if (except.includes(w)) {
    let wNew = lastCond(info.words, x => !except.includes(w));
    if (wNew) w = wNew;
  }
  return w;
}
async function send_files() {
  const myFiles = document.getElementById('myFiles').files;
  const formData = new FormData();
  Object.keys(myFiles).forEach(key => {
    formData.append(myFiles.item(key).name, myFiles.item(key));
  })
  const response = await fetch(SERVERURL + '/upload', {
    method: 'POST',
    body: formData
  });
  const json = await response.json();
  const h2 = document.querySelector('h2');
  h2.textContent = `Status: ${json?.status}`;
  const h3 = document.querySelector('h3');
  h3.textContent = json?.message;
  console.log(json);
}
function send_image(files) {
  console.log('files', files);
  var filename = files[0].name;
  var ext_start = filename.lastIndexOf(".");
  var ext = filename.substr(ext_start + 1, 3);
  if (!(ext == "jpg" || ext == "JPG")) {
    alert("This file type is not allowed");
    return;
  }
  var xml = new XMLHttpRequest();
  xml.onload = function () {
    if (xml.readyState == 4 || xml.status == 200) {
      handle_result(xml.responseText, "send_image");
    }
  }
  let data = new FormData();
  data.append('file', files[0]);
  data.append('data_type', "send_image");
  data.append('sender', Username);
  data.append('receiver', CURRENT_CHAT_USER);
  xml.open("POST", "uploader.php", true);
  xml.send(data);
}
function send_message(e) {
  e.cancelBubble = true;
  var message_text = mBy("message_text");
  if (message_text.value.trim() == "") {
    alert("please type something to send");
    return;
  }
  get_data({
    message: message_text.value.trim(),
    username: CURRENT_CHAT_USER
  }, "send_message");
}
function send_move() {
  let me = Session.cur_players[Session.cur_user];
  if (me.player_status == 'lamov') me.player_status = 'done';
  let o = { tid: Session.cur_tid, player_status: me.player_status, score: me.score, state: me.state, uname: me.name };
  to_server(o, 'send_move');
}
function send_move_dep(game, uname, tid, step, move) {
  Session.cur_menu = 'games';
  let data = { game: game, uname: uname, tid: tid, step: step, move: move };
  to_server(data, "send_move");
}
function send_or_sim(o, cmd) {
  Counter.server += 1;
  phpPost(o, cmd);
}
function send_pause() { socket.emit('pause'); }
function send_reset() { socket.emit('reset'); }
function send_resume() { socket.emit('resume'); }
function send_timer_ticker() {
  let me = Session.cur_players[Session.cur_user];
  to_server({ tid: Session.cur_tid, score: me.score, state: me.state, uname: me.name }, 'ticker_status_send_receive');
}
async function sendAction(boat, username) {
  if (TESTING) {
    modifyServerDataRandom(username);
  } else {
    _syncUsernameOfSender(username);
    if (nundef(boat)) boat = chooseRandom(boats);
    let route = '/action/' + Username + '/' + serverData.key + '/' + boat.desc + '/';
    let t = boat.tuple;
    route += t.map(x => _pickStringForAction(x)).join('+');
    let result = await route_server_js(route);
    prevServerData = serverData;
    serverData = result;
  }
}
function sendAction_old(player, tuple, callback, ms = 30) {
  setTimeout(() => {
    testOutput({ 1: ['sending action:' + player + tuple + callback.name] });
    testOutput({ 0: [player + ' selects:' + tuple] });
    let chain = ['action/' + player + '/' + tuple.join('+'), 'info/' + player, 'status/' + player];
    sender.chainSend(chain, player, callback);
  }, ms);
}
function sendChangePlayer(data, callback) {
  player = data.waiting_for.set[0];
  if (!assets.factionNames.includes(player)) {
    logFormattedData(data, msgCounter, 'ERROR: waiting_for data corrupt!!!' + player);
  } else {
    let chain = ['info/' + player, 'status/' + player];
    sender.chainSend(chain, player, callback);
  }
}
function sendChangeToPlayer(nextPlayer, callback) {
  let chain = ['info/' + nextPlayer, 'status/' + nextPlayer];
  sender.chainSend(chain, nextPlayer, callback);
}
function sendEditAction(player, tuple, callback, ms = 30) {
  setTimeout(() => {
    testOutput({ 1: ['sending action:' + player + tuple + callback.name] });
    testOutput({ 0: [player + ' selects:' + tuple] });
    sender.send('edit/' + player + '/' + tuple.join('+'), callback);
  }, ms);
}
function sendEmptyAction(player, callback) {
  testOutput({ 1: ['sending empty action!!!'] });
  sendAction(player, ['none'], callback);
}
async function sendfen(o, plname) {
  let gamerec = await post_test2(o, '/post');
  let oldrec = firstCond(Serverdata.games, x => x.name == gamerec.name);
  if (oldrec) arrRemovip(Serverdata.games, oldrec);
  Serverdata.games.unshift(gamerec);
  processServerdata();
  console.log('Serverdata', Serverdata);
  DA.gameItems = show_gametable(mBy('dAllTables'));
  let turn = gamerec.fen.turn;
  let uname = isdef(plname) ? plname : isdef(U) ? U.name : turn[0];
  show_table_for(gamerec, dParent, uname);
  if (Pollmode == 'auto') TO.poll = setTimeout(poll, 5000);
}
function sendFilename(msg) { logClientSend('filename', msg); Socket.emit('filename', { msg }); }
function sendgameover(plname, friendly, fen, scoring) {
  let o = { winners: plname, friendly: friendly, fen: fen, scoring: scoring };
  phpPost(o, 'gameover');
}
function sendGetGameInfo() {
  timit.showTime('sending select game');
  _sendRoute('/game/select/' + S.settings.game, d2 => {
    timit.showTime('sending game info');
    _sendRoute('/game/info/' + S.settings.game, d4 => {
      console.log('gameInfo', d4, getTypeOf(d4));
      S.gameInfo = JSON.parse(d4);
      console.log(S.gameInfo);
      _sendRoute('/game/players', d5 => {
        console.log('players', d5, getTypeOf(d5));
        S.gameInfo = JSON.parse(d5);
        console.log(S.gameInfo);
        waitForLogin();
      });
    });
  });
}
function sendHtml(id, filename) {
  window.scrollTo(0, 0);
  html2canvas(document.getElementById(id)).then(function (canvas) {
    let imgData = canvas.toDataURL("image/jpeg", 0.9);
    var profile_image = mBy("profile_image");
    profile_image.src = imgData;
    mBy('imgPreview').src = imgData;
    var ajax = new XMLHttpRequest();
    ajax.open("POST", "server/save_url_encoded_image.php", true);
    ajax.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    ajax.send("image=" + canvas.toDataURL("image/jpeg", 0.9) + "&filename=" + filename + ".jpg");
    ajax.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        let udata = get_current_userdata();
        if (!udata.image) { udata.image = true; db_save(); }
        get_login();
      }
    };
  });
}
function sendHtml_dep(id, filename) {
  window.scrollTo(0, 0);
  html2canvas(document.getElementById(id)).then(function (canvas) {
    let imgData = canvas.toDataURL("image/jpeg", 0.9);
    var profile_image = mBy("profile_image");
    profile_image.src = imgData;
    mBy('imgPreview').src = imgData;
    var ajax = new XMLHttpRequest();
    ajax.open("POST", "server/save_url_encoded_image.php", true);
    ajax.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    ajax.send("image=" + canvas.toDataURL("image/jpeg", 0.9) + "&filename=" + filename + ".jpg");
    ajax.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        console.log('RESPONSE IMAGE UPLOAD!!!!!!!', this.responseText);
        window.location.replace('index.html');
      }
    };
  });
}
function sendInit() {
  timit.showTime('sending status');
  _sendRouteJS('/status/' + USERNAME, d7 => {
    data = d7.response;
    if (S.settings.playMode == 'multiplayer') {
      if ('players' in data) {
        for (const id in data.players) {
          let pl = data.players[id];
          if (pl.obj_type == 'GamePlayer') {
            if (pl != G.player) {
              if (!(id in S.plAddedByMe)) {
                enterWaitingLoop(); return;
              }
            }
          }
        }
      }
    }
    processData(data);
    specAndDOM([gameStep]);
  });
}
function sendInit_old(player, callback, seed = 1) {
  var chain = ['init/hotseat/' + player + '/' + seed, 'info/' + player, 'status/' + player];
  sender.chainSend(chain, player, callback);
}
function sendInitNewGame() {
  timit.showTime('sending restart');
  _sendRoute('/restart', d0 => {
    timit.showTime('sending select game');
    _sendRoute('/game/select/' + S.settings.game, d2 => {
      timit.showTime('sending game info');
      _sendRoute('/game/info/' + S.settings.game, d4 => {
        S.gameInfo = JSON.parse(d4);
        let chain = [];
        let i = 0;
        S.gameInfo.userList = [];
        for (const pl of S.gameInfo.player_names) {
          let user = i > 0 ? USERNAME + i : USERNAME;
          let cmd = '/add/player/' + user + '/' + pl;
          S.gameInfo.userList.push(user);
          i += 1;
          chain.push(cmd);
        }
        timit.showTime('sending player logins');
        chainSend(chain, d5 => {
          _sendRoute('/begin/1', d6 => {
            let user = S.gameInfo.userList[0];
            timit.showTime('sending status');
            _sendRoute('/status/' + user, d7 => {
              let data = JSON.parse(d7);
              processData(data);
              specAndDOM([gameStep]);
            });
          });
        });
      });
    });
  });
}
function sendInitSeed(player, seed, callback) {
  let url = 'init_test/hotseat/' + player;
  if (seed != null) url += '/' + seed;
  unitTestSender('url:', url);
  sender.send(url, dInit => {
    unitTestSender('dInit:', dInit);
    dInit.info.game.player = player;
    callback(dInit);
  });
}
function sendInitSeed_old(player, seed, callback) {
  sender.send('init/hotseat/' + player + '/' + seed, dInit => {
    sender.send('info/' + player, dInfo => {
      dInit = extend(true, dInit, dInfo);
      dInit.game.player = player;
      callback(dInit);
    });
  });
}
function sendLoading(player, filename, callback) {
  unitTestLoad('loading', filename);
  var sData = {};
  sender.send('myload/' + filename + '.json', d1 => {
    unitTestLoad('myload response:', d1);
    sender.send('refresh/' + player, d2 => {
      unitTestLoad('refresh response:', d2);
      sData.created = d2;
      sender.send('status_test/' + player, d3 => {
        sData = augment(sData, d3);
        unitTestLoad('status_test response:', d3, 'akku:', sData, 'player', player);
        actionOrWaiting(player, sData, callback);
      });
    });
  });
}
function sendLoading_old(filename, player, callback, outputOption = 'none') {
  execOptions.output = outputOption;
  var sData = {};
  sender.send('myload/' + filename + '.json', data => {
    sender.send('refresh/' + player, data => {
      sData.created = data;
      let chain = ['info/' + player, 'status/' + player];
      sender.chainSend(chain, player, data => {
        sData = augment(sData, data);
        sData.created = augment(sData.created, sData.updated);
        if ('waiting_for' in data && empty(getSet(data, 'waiting_for'))) {
          sender.send('action/' + player + '/none', data => {
            sData = augment(sData, data);
            if (callback) callback(sData);
          });
        } else {
          if (callback) callback(sData);
        }
      });
    });
  });
}
function sendLoadScenario(player, filename, callback) {
  unitTestScenario('loading', filename);
  var sData = {};
  sender.send('myloadScenario/' + filename + '.json', d1 => {
    unitTestScenario('myloadScenario response:', d1);
    callback(d1);
  });
}
function sendLoadScenario2(player, filename, callback) {
  unitTestScenario('_____________________loading scenario', filename);
  var sData = {};
  sender.send('myloadScenario2/' + filename + '.yml', d1 => {
    unitTestScenario('server response:', d1);
    callback(d1);
  });
}
function sendLogin(username) { logClientSend('login', username); Socket.emit('login', { data: username }); }
function sendMousePosition(ev) {
  if (nundef(Socket)) return;
  if (!ev.altKey || ev.ctrlKey) return;
  let [x, y] = [ev.pageX, ev.pageY];
  x = (ev.pageX - $('#dFieldArea').offset().left);
  y = (ev.pageY - $('#dFieldArea').offset().top);
  if (Math.abs(x - LastPositionX) > MOUSED || Math.abs(y - LastPositionY) > MOUSED) {
    LastPositionX = x; LastPositionY = y;
    MouseMoveCounter = 0;
    Socket.emit('mouse', { username: Username, x: x, y: y });
  } else MouseMoveCounter += 1;
}
function sendmove(plname, fen, action, expected, step) {
  pollStop();
  let o = { type: 'move', uname: plname, game: G.name, fen: fen, action: action, expected: expected, step: step };
  sendfen(o, plname);
}
function sendMoveField(f) {
  let data = { dxy: f.item.dxy, iField: f.index, username: Username };
  logClientSend('moveField', data);
  Socket.emit('moveField', data);
}
function sendMovePerle(perle, fFrom, fTo, dis) {
  let data = { dxy: perle.dxy, iPerle: perle.index, iFrom: fFrom.index, iTo: fTo.index, displaced: isdef(dis) ? dis.index : null, username: Username };
  logClientSend('movePerle', data);
  Socket.emit('movePerle', data);
}
function sendPlacePerle(perle, field, dis) {
  let data = { dxy: perle.dxy, iPerle: perle.index, iField: field.index, displaced: isdef(dis) ? dis.index : null, username: Username };
  logClientSend('placePerle', data);
  Socket.emit('placePerle', data);
}
function sendRandom(G, n, callback) { }
function sendRelayout(rows, cols, boardArr, poolArr) {
  let data = { rows: rows, cols: cols, boardArr: boardArr, username: Username };
  if (isdef(poolArr)) data.poolArr = poolArr;
  logClientSend('relayout', data);
  Socket.emit('relayout', data);
}
function sendRemovePerle(perle, fFrom) {
  let data = { iPerle: perle.index, iFrom: fFrom.index, username: Username };
  logClientSend('removePerle', data);
  Socket.emit('removePerle', data);
}
function sendReset(settings) { logClientSend('reset', Username); Socket.emit('reset', { settings: settings, username: Username }); }
async function sendRestart(username) {
  _syncUsernameOfSender(username);
  if (TESTING) serverData = await loadInitialServerData(Username);
  else serverData = await route_begin_status(Username);
}
function sendSettings() {
  logClientSend('settings', G.settings);
  console.assert(G.settings == Settings.o, "wrong settings object!!!!!!!")
  Socket.emit('settings', { settings: G.settings, nFields: calcNFields(G.settings) });
}
function sendSettingsWithBoardImage(pack) {
  logClientSend('sendSettingsWithBoardImage', pack.filename);
  console.log('pack', pack);
  Socket.emit('settingsWithBoardImage', pack);
}
function sendSIMSIM(o, exclusive = false, saveFromZ = false) {
  o = data_from_client(o);
  let result = apiphp(o, saveFromZ);
  if (TESTING && o.cmd == 'startgame') { for (const func of DA.test.mods) func(result.table); }
  let res = JSON.stringify(result);
  if (exclusive) { if_hotseat_autoswitch(result); handle_result(res, o.cmd); } else { console.log('sendSIMSIM testresult', result); }
}
function sendStartOrJoinPerlenGame() {
  if (STARTED) {
    if (isdef(G)) { saveStateAndSettings(); }
    console.log('SERVER RESTART?!?!?!!!');
    return;
  }
  STARTED = true;
  let data = Username;
  logClientSend('startOrJoinPerlen', data);
  Socket.emit('startOrJoinPerlen', data);
  window.onkeydown = keyDownHandler;
  window.onkeyup = keyUpHandler;
  mBy('sidebar').ondblclick = () => { closeAux(); hide('sidebar') };
  G = new SimpleClass7();
  startingSetup();
}
async function sendStatus(username) {
  _syncUsernameOfSender(username);
  if (!TESTING) serverData = await route_status(Username);
}
function sendToBack(ui) {
  ui.style.zIndex = 0;
}
function sendUserMessage(data) { logClientSend('userMessage', data.username); Socket.emit('userMessage', { data: data }); }
function separateAtCapitals(s) {
  let sNew = '';
  for (let i = 0; i < s.length; i++) {
    let ch = s[i];
    if (ch.toUpperCase() != ch) sNew += ch;
    else sNew += ' ' + ch.toLowerCase();
  }
  return sNew;
}
function sepWordListFromString(s, seplist) {
  let words = multiSplit(s, seplist);
  return words.map(x => x.replace('"', '').trim());
}
function sepWords(text, voiceKey, s = '') {
  text = text.toLowerCase();
  if (voiceKey == 'zira') {
    return text;
  } else if (startsWith(voiceKey, 'u')) { return text; }
  let words = text.split(' ');
  text = words.join(' '); text += s;
  return text;
}
function serialize_all() {
  let list = [];
  for (const id in Items) {
    let res = default_item_serializer(Items[id]);
    list.push(res);
  }
  console.log('list', list)
  downloadAsYaml(list, '_all');
  toLocalStorage(list);
}
function server_offline(req, type) {
  if (type == 'user_info') console.log('_______to server offline!', 'req', req, 'type', type, 'Session.cur_user', Session.cur_user);
  let response = {};
  switch (type) {
    case 'user_info':
    case 'account':
      if (nundef(req.user)) req.user = Session.cur_user;
      let u = response.message = DB.users[req.user];
      console.log('udata', u);
      response.name = u.name;
      break;
    case 'contacts':
      let usernames = get_user_names().filter(x => x != Session.cur_user);
      response.users = usernames.map(x => DB.users[x]);
      break;
  }
  response.type = type;
  from_server(JSON.stringify(response), type);
}
function server_online(req, type) {
  var xml = new XMLHttpRequest();
  var loader_holder = mBy("loader_holder");
  loader_holder.className = "loader_on";
  xml.onload = function () {
    if (xml.readyState == 4 || xml.status == 200) {
      loader_holder.className = "loader_off";
      from_server(xml.responseText, type);
    }
  }
  var data = { req: req, type: type };
  data = JSON.stringify(data);
  xml.open("POST", "./server/apisi.php", true);
  xml.send(data);
}
function serverGet(cmd, { game = 'catan', iTuple = 0 }, callback) {
  S.count.msg += 1;
  let url = SERVER_URL + (cmd == 'init' ? 'init/' + game : cmd == 'action' ? 'action/' + G.player + '/' + iTuple : 'status/' + G.player);
  $.ajax({
    url: url,
    type: 'GET',
    success: response => {
      if (response[0] != '{') {
        error('server response is NOT JSON string!!!... transforming...');
        if (callback) callback(JSON.parse('{"response":"' + response + '"}'));
      } else {
        let data = JSON.parse(response);
        if ('error' in data) {
          error(data);
          alert(JSON.stringify(data.error));
        } else {
          if (callback) callback(data);
        }
      }
    },
    error: err => {
      error(err);
      alert(err);
    },
  });
}
async function serverTest00_postData() {
  console.log('hallo');
  let o = { liste: [1, 2, 3], hut: 'hutX' };
  let path = './DATA/file.yaml';
  let resp = await postData('http://localhost:3000/db', { obj: o, path: path });
  console.log('response', resp); return;
}
async function SessionStart() {
  await loadCorrectWords(); await loadAssets(); ensureSymBySet(); makeHigherOrderGroups();
  initTable();
  initSidebar();
  initSettingsP0();
  CurrentSessionData = { user: currentUser, games: [] };
  if (immediateStart && IS_TESTING) { hide('freezer'); show('divControls'); startGame(); }
  else if (immediateStart) { show('freezer'); hide('divControls'); }
  else { hide('freezer'); hide('divControls'); openSettings(); }
}
function set_auction_phase(o) {
  fen = o.fen;
  fen.phase = o.phase = 'jack';
  fen.turn = [fen.plorder[0]];
  fen.stage = 12;
  ensure_market(fen, 3);
}
function set_background_color(color, elem) { if (nundef(elem)) elem = mBy('md').parentNode; mStyle(elem, { bg: getColorDictColor(color) }); }
function set_bar(id, val, speed) {
  let bar = DA.bars[id];
  let goal = Math.min(100, Math.max(0, val));
  if (goal == bar.w) return;
  let i = goal > bar.w ? speed : -speed;
  clearInterval(bar.ti);
  bar.ti = setInterval(() => anim(bar, i, goal), 10);
  function anim(bar, i, goal) {
    if (i < 0 && bar.w <= goal || i > 0 && bar.w >= goal) {
      clearInterval(bar.ti);
    } else {
      bar.w += i;
      bar.div.style.width = bar.w + '%';
    }
  }
}
function set_blackmail_owner_stage(o) {
  set_queen_phase(o);
  let fen = o.fen;
  let uplayer = fen.turn[0];
  console.log('blackmailed is', uplayer)
  give_various_buildings_to(o, uplayer);
  let other = firstCond(fen.plorder, (p) => p != uplayer);
  let building = get_building_with_rumor(o.fen, uplayer);
  let payment = { o: null, a: 'coin', key: 'coin', friendly: 'coin', path: null };
  fen.blackmail = { blackmailer: other, blackmailed: uplayer, payment: payment, building_path: building.path };
  building.isblackmailed = true;
  fen.stage = o.stage = 33;
}
function set_blackmail_owner_stage_defend(o) {
  set_blackmail_owner_stage(o);
  console.log('==>blackmailed is', o.fen.turn[0])
  let fen = o.fen;
  let uplayer = fen.turn[0];
  console.log('==>blackmailed is', uplayer)
  let building = path2fen(fen, fen.blackmail.building_path);
  let lead = building.lead;
  fen.players[uplayer].rumors.push(`${lead[0]}Cr`);
  let plname = fen.blackmail.blackmailed;
  let rumors = fen.players[plname].rumors;
  console.log('lead', lead, 'blackmailed rumors', rumors);
}
function set_boa_score(inc) { S.score += inc; if (S.score < 0) S.score = 0; boa_save(); }
function set_card_border(item, thickness = 1, color = 'black', dasharray) {
  let d = iDiv(item);
  let rect = lastDescendantOfType('rect', d);
  assertion(rect, 'NO RECT FOUND IN ELEM', d);
  if (rect) {
    rect.setAttribute('stroke-width', thickness);
    rect.setAttribute('stroke', color);
    if (isdef(dasharray)) rect.setAttribute('stroke-dasharray', dasharray);
  }
}
function set_card_constants(w, h, ranks, suits, deckletters, numjokers = 0, ovdeck = .25, ovw = '20%', ovh = '20%') {
  Card = {};
  Card.sz = valf(h, 300);
  Card.h = h;
  Card.w = isdef(w) ? w : Card.sz * .7;
  Card.gap = Card.sz * .05;
  Card.ovdeck = ovdeck;
  Card.ovw = isString(ovw) ? Card.w * firstNumber(ovw) / 100 : ovw;
  Card.ovh = isString(ovh) ? Card.h * firstNumber(ovh) / 100 : ovh;
  Card.ranks = valf(ranks, '23456789TJQKA');
  Card.suits = valf(suits, 'SHDC');
  Card.decks = valf(deckletters, 'rb');
  Card.numdecks = deckletters.length;
  Card.numjokers = numjokers;
}
function set_card_style(item, styles = {}, className) {
  console.log('set_card_style', item, styles);
  let d = iDiv(item);
  let svg = findDescendantOfType('svg', d);
  let rect = findDescendantOfType('rect', svg);
  if (isdef(styles.shadow)) {
    let shadow = styles.shadow;
    delete styles.shadow;
    let hexcolor = colorFrom(styles.shadow);
    svg.style.filter = `drop-shadow(4px 5px 2px ${hexcolor})`;
  }
  if (isdef(styles.bg)) {
    let hexcolor = colorFrom(styles.bg);
    rect.setAttribute('stroke-width', 14); rect.setAttribute('stroke', hexcolor);
  }
  assertion(rect, 'NO RECT FOUND IN ELEM', d);
  mStyle(d, styles);
  if (isdef(className)) mClass(svg, className);
}
function set_card_style_works(c, styles, className) {
  let d = iDiv(c);
  mStyle(d, styles);
  d.firstChild.setAttribute('class', className);
}
function set_context(item) {
  CONTEXT = isDict(item) ? item
    : isString(item) && isdef(Items[item]) ? Items[item]
      : isNumber(item) && isdef(Items[`_${item}`]) ? Items[`_${item}`]
        : get_values(Items)[0];
}
function set_cur_tid_for_game() {
  console.assert(isdef(Session.tables_by_game) && isdef(Session.cur_game), "set_cur_tid_for_game");
  let tables = Session.tables_by_game;
  let game = Session.cur_game;
  if (!isEmpty(tables[game])) Session.cur_tid = tables[game][0].id;
  else Session.cur_tid = null;
}
function set_elo(user, game, val) { lookupSetOverride(DB.users, [user, 'games', game, 'elo'], val); }
function set_g_index(i) { G.i = i; call_question(i); }
function set_hover_card(b, d, val = 'silver', prop = 'fill') {
  b.onmouseenter = () => {
    let rs = Array.from(d.getElementsByTagName('rect'));
    let r = arrLast(rs);
    b[prop] = r.getAttribute(prop);
    r.setAttribute(prop, val);
  }
  b.onmouseleave = () => {
    let rs = Array.from(d.getElementsByTagName('rect'));
    let r = arrLast(rs);
    r.setAttribute(prop, b[prop]);
  }
}
function set_hover_div(b, d, val, prop) {
  b.onmouseenter = () => {
    d[prop] = mGetStyleX(d, prop);
    let style = {}; style[prop] = val; mStyle(d, style);
  }
  b.onmouseleave = () => {
    let style = {}; style[prop] = d.bg; mStyle(d, style);
  }
}
function set_hover_ui(b, item) {
  let isCard = isdef(item.c52key);
  let d = iDiv(item);
  b.onmouseenter = () => {
    if (isCard) {
      let rs = Array.from(d.getElementsByTagName('rect'));
      let r = arrLast(rs);
      let fill = b.fill = r.getAttribute('fill');
      r.setAttribute('fill', 'silver');
    } else {
      let hallo = mGetStyle(d, 'bg');
      let bg = isEmpty(hallo) ? 'transparent' : valf(mGetStyle(d, 'bg'), 'transparent');
      d.setAttribute('bg', bg);
      mStyle(d, { bg: 'silver' });
    }
  }
  b.onmouseleave = () => {
    if (isCard) {
      let rs = Array.from(d.getElementsByTagName('rect'));
      let r = arrLast(rs);
      r.setAttribute('fill', b.fill);
    } else {
      let bg = d.getAttribute('bg');
      mStyle(d, { bg: bg });
    }
  }
}
function set_image_as_background(id, elem) {
  window.scrollTo(0, 0);
  html2canvas(document.getElementById(id)).then(function (canvas) {
    console.log('haaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
    let imgData = canvas.toDataURL("image/jpeg", 0.9);
    const rgbArray = buildRgb(imageData.data);
    const quantColors = quantization(rgbArray, 0);
    buildPalette(quantColors);
  });
}
function set_journey_or_stall_stage(fen, options, phase) {
  let pljourney = exp_journeys(options) ? find_players_with_potential_journey(fen) : [];
  let stage, turn;
  if (isEmpty(pljourney)) { delete fen.passed; turn = [fen.plorder[0]]; ari_ensure_deck(fen, phase == 'jack' ? 3 : 2); stage = 3; }
  else { turn = [pljourney[0]]; stage = 1; }
  return [stage, turn];
}
function set_king_phase(o) { set_queen_phase(o); o.phase = o.fen.phase = 'king'; }
function set_language(lang = 'E', update_ui = true) {
  console.log('lang', lang);
  if (isdef(G)) {
    G.language = G.lang = lang; lookupSetOverride(U.games, [G.id, 'language'], lang);
    Speech.setLanguage(lang);
  }
}
function set_most_recent_table_as_cur_tid(tables) { if (!isEmpty(tables)) Session.cur_tid = tables[0].id; }
function set_new_goal(id, goal, speed = .1) {
  let bar = DA.bars[id];
  goal = Math.min(100, Math.max(0, goal));
  if (goal == bar.w) return;
  let i = goal > bar.w ? speed : -speed;
  clearInterval(bar.ti);
  bar.ti = setInterval(() => anim(bar, i, goal), 10);
  function anim(bar, i, goal) {
    if (i < 0 && bar.w <= goal || i > 0 && bar.w >= goal) {
      clearInterval(bar.ti);
    } else {
      bar.w += i;
      bar.div.style.width = bar.w + '%';
    }
  }
}
function set_new_password() {
  let len = Math.min(20, S.master_password.length + 1);
  let pnew = rPassword(len);
  console.log('new password: ', pnew);
  S.master_password = pnew;
  S.score = 0;
  boa_save();
}
function set_palette(hue = 0, nHues = 2, sat = 100, a = 1) {
  palette = gen_palette(hue, nHues, sat, a);
  return palette;
}
function set_player(name, fen) {
  if (isdef(PL) && PL.name != name) { Z.prev.pl = PL; Z.prev.uplayer = PL.name; }
  PL = Z.pl = firstCond(Serverdata.users, x => x.name == name);
  copyKeys(fen.players[name], PL);
  Z.uplayer = name;
}
function set_player_strategy(val) {
  Z.strategy = Clientdata.strategy = Z.pl.strategy = val;
  mRemove('dOptions')
}
function set_player_tides(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let min = 1000, minplayer = null;
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    let hkey = pl.hand[0];
    let val = ari_get_card(hkey).val;
    pl.tides = { keys: [hkey], val: val };
    if (val < min) { min = val; minplayer = plname; }
    console.log('player', plname, 'tides', pl.tides);
  }
  let sorted = sortByDescending(fen.plorder, x => fen.players[x].tides.val);
  fen.church_order = jsCopy(fen.plorder);
  fen.tide_minimum =
    fen.stage = 21;
}
function set_player_tithes(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let min = 1000, minplayer = null;
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    let hkey = pl.hand[0];
    let val = ari_get_card(hkey).val;
    pl.tithes = { keys: [hkey], val: val };
    if (val < min) { min = val; minplayer = plname; }
    console.log('player', plname, 'tithes', pl.tithes);
  }
  let sorted = sortByDescending(fen.plorder, x => fen.players[x].tithes.val);
  fen.church_order = jsCopy(fen.plorder);
  fen.tithe_minimum =
    fen.stage = 21;
}
function set_preferred_lang(uname, val) { val = val.toUpperCase(); if ('EDSFC'.indexOf(val) >= 0) return lookupSetOverride(DB.users, [uname, 'lang'], val); }
function set_queen_phase(o) {
  fen = o.fen;
  fen.phase = o.phase = 'queen';
  arisim_stage_3(fen);
  arisim_stage_4_all(fen, 3, false);
  ensure_actions(fen);
  fen.turn = [fen.plorder[0]];
}
function set_run_state(singleclient = true, sockets = false, port = 3000, localhost = true, testing = true, liveserver = true, nodejs = true) {
  SERVER = localhost ? '127.0.0.1' : '216.250.112.218';
  PORT = port;
  SERVERURL = `http:/` + `${SERVER}:${PORT}`;
  NODEJS = nodejs;
  LIVE_SERVER = liveserver;
  TESTING = testing;
  SINGLECLIENT = singleclient;
  if (sockets) {
    Socket = liveserver ? io(SERVERURL) : io();
    Socket.on('message', x => console.log('got message', x));
    Socket.on('disconnect', x => console.log('got disconnect', x));
    Socket.on('update', x => console.log('got update', x));
  }
  console.log('SERVER:' + SERVERURL, 'LIVE:' + LIVE_SERVER, 'Socket:' + Socket, TESTING ? 'TESTING' : '', SINGLECLIENT ? 'SINGLE' : '');
}
function set_run_state_local() {
  set_run_state(true, false, 3000, true, false, true, true);
}
function set_run_state_no_server() {
  set_run_state(true, false, 3000, true, true, true, false);
}
function set_run_state_vps() {
  set_run_state(false, false, 3000, false, false, false, true);
}
function set_seen(e) { SEEN_STATUS = true; }
function set_sound(silent = false) {
  let b = mBy('b_sound');
  if (silent) {
    b.className = 'statusbutton sym enabled off';
    b.innerHTML = '🔈️';
  } else {
    b.className = 'statusbutton sym enabled on';
    b.innerHTML = '🔊';
  }
}
function set_start_data_from_fen(fen, game) {
  let parts = fen.split(',');
  for (const p of parts) {
    let [name, startlevel, lang] = p.split(':');
    startlevel = Number(startlevel);
    set_startlevel(name, game, startlevel);
    set_preferred_lang(name, lang);
  }
}
function set_startlevel(user, game, val) { return lookupSetOverride(DB.users, [user, 'games', game, 'startlevel'], val); }
function set_state_numbers(otree) {
  let [step, stage, iturn, round, phase] = [valf(otree.step, 0), valf(otree.stage, 0), valf(otree.iturn, 0), valf(otree.round, []), valf(otree.phase, 'king')];
  otree.step = step;
  otree.stage = stage;
  otree.iturn = iturn;
  otree.round = round;
  otree.phase = phase;
  let plturn = otree.plturn = otree.plorder[iturn];
  return [step, stage, iturn, round, phase, plturn];
}
function set_style_from_options(layer, options = {}) {
  let style = isdef(options.colorfunc) ? get_style_func(options.colorfunc, valf(options.bg, 'lime'), valf(options.fg, 'orange'))
    : get_style(valf(options.bg, 'yellow'), valf(options.fg, 'yellow'));
  layer.setStyle(style);
}
function set_tables_by_game(obj, is_set_cur_id = true) {
  let tables = Session.tables = obj.tables;
  let bygame = Session.tables_by_game = {};
  if (isEmpty(tables)) {
    Session.cur_tid = null;
    Session.tables_by_game = {};
  } else {
    if (is_set_cur_id) {
      let t = tables[0];
      Session.cur_tid = t.id;
      Session.cur_game = t.game;
    }
    for (const t of tables) { lookupAddToList(bygame, [t.game], t); }
  }
  return bygame;
}
function set_user(name) {
  if (isdef(Z) && isdef(U) && U.name != name) {
    Z.prev.u = U;
    Z.prev.uname = U.name;
  }
  U = firstCond(Serverdata.users, x => x.name == name);
  if (isdef(Z)) {
    Z.u = U;
    Z.uname = Z.uplayer = name;
  }
}
function set_user_tables_by_game(obj) {
  let user_tables = obj.user_tables;
  let bygame = Session.user_tables_by_game = {};
  if (isEmpty(user_tables)) {
    Session.cur_tid = null;
    Session.user_tables_by_game = {};
  } else {
    Session.cur_tid = user_tables[0].id;
    for (const t of user_tables) { lookupAddToList(bygame, [t.game], t); }
  }
  return bygame;
}
function setActiveButton(button) {
  ActiveButton = button;
  mStyleX(button, { bg: 'dimgray', fg: 'white' });
  button.innerHTML = 'submit command!';
}
function setApply(prop, val) {
  let s = G.settings;
  if (isNumber(val)) val = Number(val);
  s[prop] = val;
  G.clientBoard = applySettings(G.clientBoard, s);
}
function setAreaHeight(areaName, h) {
  let varName = AREAS[areaName][1];
  let hAttr = isNumber(h) ? '' + h + 'px' : h;
  setCSSVariable(varName, hAttr);
  if (UIS[areaName]) UIS[areaName].h = h;
}
function setAreaWidth(areaName, w) {
  if (!(areaName in AREAS)) { alert('not in AREAS!!! ' + areaName) }
  let wString;
  let wNum = null;
  if (isString(w)) {
    let n = firstNumber(w);
    if (isNumber(n)) wNum = n;
    wString = w;
  } else {
    wNum = w;
    wString = '' + w + 'px';
  }
  let varName = AREAS[areaName][0];
  setCSSVariable(varName, wString);
  if (UIS[areaName] && wNum) UIS[areaName].w = wNum;
}
function setAutoplayFunctionForMode(mode, isStartup = false) {
  if (nundef(mode)) mode = S.settings.playmode;
  if (!isStartup) S_autoplayFunction = (_g, _) => isFrontAIPlayer(_g.player);
}
function setBackgroundColor(c) { mStyleX(document.body, { bg: getColorDictColor(isdef(c) ? c : G.color) }); }
function setBackgroundToPlayerColor() {
  let c = G.playersAugmented[G.player].color;
}
function setBadgeLevel(i) {
  G.level = i;
  Score.levelChange = true;
  if (isEmpty(badges)) showBadgesX(dLeiste, G.level, onClickBadgeX, G.maxLevel);
  for (let iBadge = 0; iBadge < G.level; iBadge++) {
    let d1 = iDiv(badges[iBadge]);
    d1.style.opacity = .75;
    d1.style.border = 'transparent';
    d1.children[1].innerHTML = '* ' + (iBadge + 1) + ' *';
    d1.children[0].style.color = 'white';
  }
  let d = iDiv(badges[G.level]);
  d.style.border = '1px solid #00000080';
  d.style.opacity = 1;
  d.children[1].innerHTML = 'Level ' + (G.level + 1);
  d.children[0].style.color = 'white';
  for (let iBadge = G.level + 1; iBadge < badges.length; iBadge++) {
    let d1 = iDiv(badges[iBadge]);
    d1.style.border = 'transparent';
    d1.style.opacity = .25;
    d1.children[1].innerHTML = 'Level ' + (iBadge + 1);
    d1.children[0].style.color = 'black';
  }
}
function setCategories(groupNameList) {
  ensureSymBySet();
  let keys = [];
  for (const cat of groupNameList) {
    let name = cat.toLowerCase();
    for (const k of symKeysBySet[name]) {
      keys.push(k);
    }
  }
  return keys;
}
function setColorPalette(colors, type = 'shade') {
  let pals = colors.map(x => getPalette(x));
  let i = 0;
  let d = 0;
  let ch = ['0', '1', 'h'];
  for (const p of pals) {
    for (const c of p) {
      setCSSVariable('--pal' + ch[i] + '_' + d, c);
      d += 1;
    }
    i += 1;
    d = 0;
  }
  if (nundef(S.pals)) S.pals = pals;
  else { S.pals[0] = pals[0]; S.pals[1] = pals[1]; S.pals[2] = pals[2]; }
}
function setCSSButtonColors(palset, ihue = 0) {
  let root = document.documentElement;
  let pal = palset[ihue];
  let len = pal.length;
  root.style.setProperty('--bbg', pal[2]);
  root.style.setProperty('--bhbg', pal[0]);
  root.style.setProperty('--babg', pal[5]);
  root.style.setProperty('--baltbg', pal[3]);
}
function setCssVar(varname, val) { document.body.style.setProperty(varname, val); }
function setCSSVariable(varName, val) {
  let root = document.documentElement;
  root.style.setProperty(varName, val);
}
function setCurrent(id) {
  if (dCurrent && dCurrent.id == id) return;
  else if (dCurrent) hideCurrent();
  dCurrent = mBy(id); mStyle(dCurrent, { overflow: 'hidden' }); show(id); return dCurrent;
}
function setCurrentInfo(item) {
  currentInfo = item.info;
  matchingWords = currentInfo.words;
  validSounds = currentInfo.valid;
  bestWord = Goal.label;
  hintWord = '_'.repeat(bestWord.length);
}
function setCurrentPath(fname) {
  let pathDictionary = DOC_vault;
  let key = firstCondDict(pathDictionary, x => sameCaseInsensitive(x.filename, fname));
  let entry = DOC_vault[key];
  let index = entry.index;
  setCurrentPathIndex(index);
}
function setCurrentPathIndex(i) {
  if (i == DOC_CURRENT_PATH_INDEX) {
    console.log('current path already set to', i);
    return;
  }
  let curPath = isdef(DOC_CURRENT_PATH_INDEX) ? DOC_dvIndex[DOC_CURRENT_PATH_INDEX] : null;
  let newPath = i >= 0 && i <= DOC_dvIndex.length ? DOC_dvIndex[i] : null;
  if (curPath) {
    let curEntry = DOC_vault[curPath];
    let idDiv = curEntry.idPathContainer;
    hide(idDiv);
  }
  if (newPath) {
    let newEntry = DOC_vault[newPath];
    let idDiv = newEntry.idPathContainer;
    show(idDiv);
    DOC_CURRENT_PATH_INDEX = i;
  }
}
function setDefaultOptions() {
  let opt = { present: { object: {}, player: {} }, game: {} };
  opt.present.object.createDefault = true;
  opt.present.player.createDefault = true;
  opt.present.object.optin = null;
  opt.present.object.optout = ['obj_type', 'id'];
  opt.present.player.optin = null;
  opt.present.player.optout = ['obj_type', 'id'];
  opt.colors = ['#07061c', '#6a1c81', '#f4695c'];
  opt.gap = 0;
  opt.outerGap = false;
  S.options = opt;
}
function setDefaultRSGSettings() {
  S.settings.table.createDefault = true;
  S.settings.player.createDefault = true;
  S.settings.boardDetection = S_boardDetection;
  S.settings.deckDetection = S_deckDetection;
  S.settings.useColorHintForProperties = S_useColorHintForProperties;
  S.settings.useColorHintForObjects = S_useColorHintForObjects;
  S.settings.gameAreaSize = S_boardDetection ? [1000, 800] : [1000, '65vh'];
  S.settings.table.defaultArea = S_defaultObjectArea;
  S.settings.player.defaultArea = S_defaultPlayerArea;
  S.settings.table.optin = null;
  S.settings.table.optout = ['obj_type', 'id'];
  S.settings.onlySimpleValues = true;
  S.settings.player.optin = null;
  S.settings.player.optout = ['id', 'color', 'altName', 'index'];
  S.settings.extendedOptout = { color: 1, altName: 1, index: 1, username: 1, playerType: 1, player: 1, agentType: 1, obj_type: 1, id: 1, visible: 1, neighbors: 1, fields: 1, edges: 1, corners: 1, row: 1, col: 1 };
  S.settings.useExtendedOptout = true;
  S.settings.table.ignoreTypes = [];
  S.settings.pieceSizeRelativeToLoc = {};
  S.settings.pieceSizeRelativeToLoc.corner = ['w', 100];
  S.settings.pieceSizeRelativeToLoc.field = ['w', 30];
  S.settings.pieceSizeRelativeToLoc.edge = ['length', 100];
  S.settings.addSymbolToEdges = false;
  S.settings.symbols = {};
  S.settings.color.theme = '#6B7A8F';
  S.settings.gap = 4;
  S.settings.outerGap = false;
}
function setDefaultSettings() {
  document.getElementById('c_b_TTip').textContent = 'tooltips: ' + S_tooltips;
  let checkedModeInput = document.getElementById('c_b_mm_' + PLAYMODE.toLowerCase());
  checkedModeInput.checked = true;
  S.settings = { table: {}, player: {}, game: {}, color: {} };
  S.settings.seed = SEED;
  S.settings.game = GAME;
  S.settings.playmode = PLAYMODE;
  S.settings.clickToSelect = true;
  S.settings.tooltips = document.getElementById('c_b_TTip').textContent.includes('ON');
  S.settings.openTab = S_openTab;
  S.settings.userSettings = S_userSettings;
  S.settings.userStructures = S_userStructures;
  S.settings.userBehaviors = S_userBehaviors;
  setDefaultRSGSettings();
}
function setDivBg(d1, bg) {
  d1.style.setProperty('background-color', bg);
}
function setDivSize(d1, w, h, unit = 'px') {
  d1.style.setProperty('width', makeUnitString(w, unit));
  d1.style.setProperty('height', makeUnitString(h, unit));
}
function setDropPosition(ev, elem, targetElem, dropPos) {
  if (dropPos == 'mouse') {
    var elm = $(targetElem);
    x = ev.pageX - elm.offset().left - dragStartOffset.x;
    y = ev.pageY - elm.offset().top - dragStartOffset.y;
    posXY(elem, targetElem, x, y);
  } else if (dropPos == 'none') {
    return;
  } else if (dropPos == 'center') {
    elem.style.position = elem.style.left = elem.style.top = '';
    elem.classList.add('centeredTL');
  } else if (dropPos == 'centerCentered') {
    elem.style.position = elem.style.left = elem.style.top = '';
    elem.classList.add('centerCentered');
  } else {
    dropPos(ev, elem, targetElem);
  }
}
function setDropZones(items, handler) {
  DropZones = [];
  DropZoneItems = [];
  for (let i = 0; i < items.length; i++) {
    let d = iDiv(items[i]);
    d.onmouseup = () => handler(items[i]);
    mClass(d, 'dropzone');
    DropZones.push(d);
    DropZoneItems.push(items[i]);
  }
}
function setEquationGoal() {
  let blank = blankWordInputs(G.words, G.numMissing, G.posMissing);
  Goal = { seq: G.seq, words: G.words, chars: G.letters, blankWords: blank.words, blankChars: blank.letters, iFocus: blank.iFocus };
  Goal.qCharIndices = Goal.blankChars.map(x => x.index);
  Goal.qWordIndices = Goal.blankWords.map(x => x.iWord);
  let yes = true;
  for (let i = 0; i < Goal.chars.length; i++) if (Goal.chars[i].index != i) yes = false;
  console.assert(yes == true);
}
function setExpGoal() { }
function setFixedSizeAndPos(n) {
  let ui = n.ui;
  if (nundef(n.params.size)) return;
  n.size = jsCopy(n.params.size);
  n.pos = jsCopy(n.params.pos);
  n.pos.cx = n.pos.x + n.size.w / 2;
  n.pos.cy = n.pos.y + n.size.h / 2;
  ui.style.position = 'absolute';
  ui.style.left = n.pos.x + 'px';
  ui.style.top = n.pos.y + 'px';
  ui.style.minWidth = n.size.w + 'px';
  ui.style.minHeight = n.size.h + 'px';
}
function setFullscreenKey() {
  addKeyup('F11', (ev) => {
    let k = ev.keyCode;
    let key = ev.key;
    toggleSidebar(ev, k, key);
  });
}
function setGame(game, immediate = false) {
  cleanupOldGame();
  resetUIDs();
  if (isdef(G) && G.id != game) Score.gameChange = true;
  G = new (classByName(capitalize(game)))(game, DB.games[game]);
  Settings = new SettingsClass(G, dAux);
  if (nundef(U.games[game])) {
    if (G.controllerType == 'solitaire') { U.games[game] = { nTotal: 0, nCorrect: 0, nCorrect1: 0, startLevel: 0 }; }
    else U.games[game] = {};
  }
  if (isdef(G.maxLevel)) G.level = Math.min(getUserStartLevel(game), G.maxLevel);
  Settings.updateGameValues(U, G);
  saveUser();
  switch (G.controllerType) {
    case 'solitaire': GC = new ControllerSolitaire(G, U); break;
    case 'solo': GC = new ControllerTTT(G, U); break;
    case 'multi': GC = new ControllerMulti(G, U); break;
  }
  G.controller = GC;
  showGameTitle();
  if (immediate) GC.startGame();
}
function setGame_dep(game, immediate = false) {
  cleanupOldGame();
  resetUIDs();
  if (isdef(G) && G.id != game) Score.gameChange = true;
  G = new (classByName(capitalize(game)))(game, DB.games[game]);
  Settings = new SettingsClass(G, dAux);
  if (nundef(U.games[game])) {
    if (G.controllerType == 'solitaire') { U.games[game] = { nTotal: 0, nCorrect: 0, nCorrect1: 0, startlevel: 0 }; }
    else U.games[game] = {};
  }
  if (isdef(G.maxlevel)) G.level = Math.min(getUserStartLevel(game), G.maxlevel);
  Settings.updateGameValues(U, G);
  save_users();
  let s = valf(G.av_modes, 'training');
  let modes = s.split(',');
  if (!modes.includes(Session.def_playmode)) Session.def_playmode = modes[0];
  G.playmode = Session.def_playmode;
  if (nundef(G.controller_class)) G.controller_class = `Controller${capitalize(G.playmode)}`;
  GC = new (classByName(G.controller_class))(G, U);
  G.controller = GC;
  showGameTitle();
  if (immediate) GC.startGame();
}
function setGamePlayer(username) {
  Username = username;
  GAMEPLID = firstCondDict(playerConfig[GAME].players, p => p.username == username);
}
function setGoal(index) {
  if (nundef(index)) {
    let rnd = G.numPics < 2 ? 0 : randomNumber(0, G.numPics - 2);
    if (G.numPics >= 2 && rnd == lastPosition && coin(70)) rnd = G.numPics - 1;
    index = rnd;
  }
  lastPosition = index;
  Goal = Pictures[index];
}
function setGradientImageBackground(d, path, color1 = 'red', color2 = 'green') {
  d.style.background = color1;
  d.style.backgroundImage = `url(${path})`;
  d.style.backgroundImage = `url(${path}), linear-gradient(${color1}, ${color2})`;
  d.style.backgroundSize = '100%';
}
function setGranularityFactor(s, f = 2) {
  let lines = s.split('"');
  let lines1 = lines.filter(x => !isEmptyOrWhiteSpace(x));
  let lines2 = [];
  for (const l of lines1) {
    let lNew = '';
    for (let i = 0; i < l.length; i++) {
      if (l[i] == ' ') continue;
      for (let x = 0; x < f; x++) lNew += l[i] + ' ';
    }
    lines2.push(lNew.trim());
  }
  let lines3 = [];
  for (const l of lines2) { for (let i = 0; i < f; i++) { lines3.push(l); } }
  return lines3;
}
function setGroup(groupName) {
  ensureSymBySet();
  return jsCopy(symKeysBySet[groupName]);
}
function setHNeeded(elem) {
  let sz = getSizeNeeded(elem);
  let r = getRect(elem);
  if (sz.h > r.h && elem.style.height != '100%') { r.h = sz.h; mStyle(elem, { h: r.h }); }
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  return r.h;
}
function SetInitialBoardPieces() {
  var sq;
  var sq120;
  var file, rank;
  var rankName;
  var fileName;
  var imageString;
  var pieceFileName;
  var pce;
  ClearAllPieces();
  for (sq = 0; sq < 64; ++sq) {
    sq120 = SQ120(sq);
    pce = brd_pieces[sq120];
    if (GameController.BoardFlipped == BOOL.TRUE) {
      sq120 = MIRROR120(sq120);
    }
    file = FilesBrd[sq120];
    rank = RanksBrd[sq120];
    if (pce >= PIECES.wP && pce <= PIECES.bK) {
      rankName = "rank" + (rank + 1);
      fileName = "file" + (file + 1);
      pieceFileName = "../base/assets/images/chess/" + SideChar[PieceCol[pce]] + PceChar[pce].toUpperCase() + ".png";
      imageString = "<image src=\"" + pieceFileName + "\" class=\"Piece " + rankName + " " + fileName + "\"/>";
      $("#ChessBoard").append(imageString);
    }
  }
}
function setIsReallyMultiplayer() {
  let gc = S.gameConfig;
  let players = gc.players;
  let foreign = firstCond(players, x => !isMyPlayer(x.id) && x.playerType == 'human');
  isReallyMultiplayer = (foreign != null);
  disableButtonsForMultiplayerGame();
}
function setKeys({ allowDuplicates, nMin = 25, lang, key, keySets, filterFunc, param, confidence, sortByFunc } = {}) {
  let keys = jsCopy(keySets[key]);
  if (isdef(nMin)) {
    let diff = nMin - keys.length;
    let additionalSet = diff > 0 ? nMin > 100 ? firstCondDictKeys(keySets, k => k != key && keySets[k].length > diff) : 'best100' : null;
    if (additionalSet) KeySets[additionalSet].map(x => addIf(keys, x));
  }
  let primary = [];
  let spare = [];
  for (const k of keys) {
    let info = Syms[k];
    info.best = info[lang];
    if (nundef(info.best)) {
      let ersatzLang = (lang == 'D' ? 'D' : 'E');
      let klang = 'best' + ersatzLang;
      if (nundef(info[klang])) info[klang] = lastOfLanguage(k, ersatzLang);
    }
    let isMatch = true;
    if (isdef(filterFunc)) isMatch = isMatch && filterFunc(param, k, info.best);
    if (isdef(confidence)) isMatch = info[klang + 'Conf'] >= confidence;
    if (isMatch) { primary.push(k); } else { spare.push(k); }
  }
  if (isdef(nMin)) {
    let len = primary.length;
    let nMissing = nMin - len;
    if (nMissing > 0) { let list = choose(spare, nMissing); spare = arrMinus(spare, list); primary = primary.concat(list); }
  }
  if (isdef(sortByFunc)) { sortBy(primary, sortByFunc); }
  if (isdef(nMin)) console.assert(primary.length >= nMin);
  if (nundef(allowDuplicates)) {
    primary = removeDuplicates(primary);
  }
  return primary;
}
function setKeysG(g, filterFunc, nMin, key) {
  if (nundef(nMin)) nMin = 25;
  if (isdef(g.numPics)) nMin = Math.max(25, g.numPics);
  return setKeys({ nMin: nMin, lang: g.language, key: valf(key, g.vocab), keySets: KeySets, filterFunc: filterFunc, param: g });
}
function setKeysX({ cats, bestOnly = false, correctOnly = false, sortAccessor }) {
  currentKeys = getKeySetX(isdef(cats) ? cats : currentCategories, currentLanguage, MinWordLength, MaxWordLength,
    bestOnly, sortAccessor, correctOnly, reqOnly);
  if (isdef(sortByFunc)) { sortBy(currentKeys, sortAccessor); }
}
function setLanguage(x) { currentLanguage = x; startLevel(); }
function setLanguageHALLO(l) { Settings.language = G.language = l; Speech.setLanguage(l); console.log('SET LANGUAGE TO', l, G.language, G.lang); }
function setLinearBackground(d, cInner = '#00000080', percentWide, cOuter = 'transparent') {
  if (typeof cInner == 'function') cInner = cInner();
  d.style.background = `linear-gradient(to right, ${cOuter} 0%, ${cInner} ${percentWide}%,${cInner} ${100 - percentWide}%, ${cOuter}) 100%`;
}
function setMessage(msg) { const parent = document.getElementById('status_message'); parent.innerHTML = msg; }
function setMultiGoal(n, indices) {
  Goal = { pics: [] };
  if (nundef(indices)) {
    Goal.pics = choose(Pictures, n);
  } else {
    for (const i of indices) Goal.pics.push(Pictures[i]);
  }
}
function setNewBackgroundColor(bg) {
  if (nundef(bg)) bg = randomDarkColor();
  BaseColor = bg; HeaderColor = colorDarker(BaseColor); SidebarColor = colorLighter(BaseColor, .125);
  setBackgroundColor(bg);
  mStyleX(dHeader, { bg: HeaderColor });
  mStyleX(mBy('sidebar'), { bg: SidebarColor });
  mStyleX(mBy('dAux'), { bg: SidebarColor });
  localStorage.setItem('BaseColor', BaseColor);
  if (isdef(G)) G.settings.baseColor = bg;
}
function setNextGame() {
  let game = G.id;
  let i = U.avGames.indexOf(game);
  let iNew = (i + 1) % U.avGames.length;
  setGame(U.avGames[iNew]);
}
function setNumberSequenceGoal() {
  let blank = blankWordInputs(G.words, G.numMissing, G.posMissing);
  Goal = { seq: G.seq, words: G.words, chars: G.letters, blankWords: blank.words, blankChars: blank.letters, iFocus: blank.iFocus };
  Goal.qCharIndices = Goal.blankChars.map(x => x.index);
  Goal.qWordIndices = Goal.blankWords.map(x => x.iWord);
}
function setOrigin(g, center = true) {
  if (center) g.setAttribute('class', 'gCentered');
  else g.setAttribute('class', null);
}
function setPageBackground(bg, fg = 'white', isBase = true) {
  bg = colorHex(bg);
  if (isBase) DA.pageBaseColor = bg;
  mStyleX(dMain, { bg: bg, fg: isdef(fg) ? fg : 'contrast' });
}
function setPicsPerLevel() {
  let inp = mBy('inputPicsPerLevel');
  inp.select();
  let x = getSelection();
  let n = Number(x.toString());
  inp.value = n;
  getSelection().removeAllRanges();
  PICS_PER_LEVEL = n;
  SAMPLES_PER_LEVEL = new Array(20).fill(PICS_PER_LEVEL);
  boundary = SAMPLES_PER_LEVEL[currentLevel];
}
function setPlayer(g, pl) {
  let idx;
  if (isdef(g.iPlayer)) {
    idx = (g.iPlayer + 1) % g.players.length;
  } else if (isdef(pl)) {
    idx = g.players.indexOf(pl);
  } else idx = 0;
  pl = g.players[idx];
  [GC.iPlayer, GC.plTurn] = [g.iPlayer, g.plTurn] = [idx, pl];
}
function setPlayMode(mode, isStartup = false) {
  if (mode != S.settings.playMode) S.playModeChanged = true;
  PLAYMODE = mode;
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE)
  setAutoplayFunctionForMode(mode, isStartup);
  if (mode == 'solo') {
    hide(document.getElementById('c_b_join'));
    hide(document.getElementById('c_b_NextPlayer'));
    hide(document.getElementById('c_b_RunToEnd'));
  } else if (mode == 'hotseat') {
    hide(document.getElementById('c_b_join'));
    show(document.getElementById('c_b_NextPlayer'));
    show(document.getElementById('c_b_RunToEnd'));
  } else if (mode == 'multiplayer') {
    show(document.getElementById('c_b_join'));
    hide(document.getElementById('c_b_NextPlayer'));
    hide(document.getElementById('c_b_RunToEnd'));
  }
}
function setPlaymode(mode, isStartup = false) {
  if (mode != S.settings.playmode) S.playModeChanged = true;
  S.settings.playmode = PLAYMODE = mode;
  setAutoplayFunctionForMode(mode, isStartup);
  return mode;
}
function setPositionData(g1) {
  let ids = g1.getNodeIds();
  for (const id of ids) {
    let pos = g1.getProp(id, 'center');
    g1.setPosition(id, pos.x, pos.y);
  }
  g1.reset();
}
function setRect(elem, options) {
  let r = getRect(elem);
  elem.rect = r;
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  if (isDict(options)) {
    if (options.hgrow) mStyle(elem, { hmin: r.h });
    else if (options.hfix) mStyle(elem, { h: r.h });
    else if (options.hshrink) mStyle(elem, { hmax: r.h });
    if (options.wgrow) mStyle(elem, { wmin: r.w });
    else if (options.wfix) mStyle(elem, { w: r.w });
    else if (options.wshrink) mStyle(elem, { wmax: r.w });
  }
  return r;
}
function setRectInt(elem, options) {
  let r = getRectInt(elem);
  elem.rect = r;
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  if (isDict(options)) {
    if (options.hgrow) mStyle(elem, { hmin: r.h });
    else if (options.hfix) mStyle(elem, { h: r.h });
    else if (options.hshrink) mStyle(elem, { hmax: r.h });
    if (options.wgrow) mStyle(elem, { wmin: r.w });
    else if (options.wfix) mStyle(elem, { w: r.w });
    else if (options.wshrink) mStyle(elem, { wmax: r.w });
  }
  return r;
}
function setReloadOnClick() {
  window.onclick = (ev) => {
    if (!['dStatusLine', 'header', 'inner_left_panel', 'left_panel'].includes(ev.target.id)) return;
    reload();
    mBy('dStatusLine').innerHTML = 'last reload: ' + formatNow();
  };
}
function setRSG_SOURCE(val) {
  if (RSG_SOURCE == 'test' && val == 'main') {
    let d = mBy('table');
    clearElement(d);
    d.style.minHeight = 0;
    d.style.minWidth = 0;
  }
  RSG_SOURCE = val;
  showMenu(val);
}
function setSettingsKeys(elem) {
  let val = elem.type == 'number' ? Number(elem.value) : elem.type == 'checkbox' ? elem.checked : elem.value;
  lookupSetOverride(Settings, elem.keyList, val);
  SettingsChanged = true;
  console.log(elem.keyList, val)
}
function setSettingsKeysSelect(elem) {
  let val;
  for (const opt of elem.children) {
    if (opt.selected) val = opt.value;
  }
  SettingsChanged = true;
  lookupSetOverride(Settings, elem.keyList, val);
}
function setSide(cardDiv, newSide) {
  if (!cardDiv.isCard) return;
  let faceElem = cardDiv.faceElem;
  let backElem = cardDiv.backElem;
  if (newSide === 'front') {
    if (cardDiv.side === 'back') {
      cardDiv.removeChild(backElem);
    }
    cardDiv.side = 'front';
    cardDiv.appendChild(faceElem);
    cardDiv.setAttribute('class', 'cardMy ' + getSuitName(cardDiv.suit) + ' rank' + cardDiv.rank);
  } else {
    if (cardDiv.side === 'front') {
      cardDiv.removeChild(faceElem);
    }
    cardDiv.side = 'back';
    cardDiv.appendChild(backElem);
    cardDiv.setAttribute('class', 'cardMy');
  }
}
function setSizeNeeded(elem) {
  let sz = getSizeNeeded(elem);
  let r = getRect(elem);
  if (sz.w > r.w && elem.style.width != '100%') { r.w = sz.w; mStyle(elem, { w: r.w }); }
  if (sz.h > r.h && elem.style.height != '100%') { r.h = sz.h; mStyle(elem, { h: r.h }); }
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  return r;
}
function setSP(n) {
  let ui = n.ui;
  let b = getBounds(ui, true);
  n.size = { w: b.width, h: b.height };
  n.pos = { x: b.x, y: b.y };
}
function setSpeechResult(transcript, conf1, conf2, isFinal = false) {
  Goal.reqAnswer = bestWord;
  Goal.answer = transcript;
  Goal.confidence = conf1;
  Goal.confidence2 = conf2;
  Goal.isSpeechResultFinal = isFinal;
  if (RecogHighPriorityOutput)
    console.log('*=' + (isFinal ? 'final' : 'interim') + '==>', 'best:' + bestWord, 'got:' + transcript,
      '(confid: ' + conf1 + '/' + conf2 + ')');
}
function SetSqSelected(sq) {
  if (GameController.BoardFlipped == BOOL.TRUE) {
    sq = MIRROR120(sq);
  }
  $(".Square").each(function (index) {
    if ((RanksBrd[sq] == 7 - Math.round($(this).position().top / 60)) && (FilesBrd[sq] == Math.round($(this).position().left / 60))) {
      $(this).addClass('SqSelected');
    }
  });
}
function setStatus(s) {
  let areaName = isPlain() ? 'c_d_statusInHeaderText' : 'c_d_statusText';
  let d = document.getElementById(areaName);
  let mobj = UIS[areaName];
  mobj.clear(); clearElement(d);
  d.innerHTML = s;
}
function setSubtitle(s) { mBy('dSubtitle').innerHTML = s; }
function setSymLabel(g, id, key, styles = {}) {
  if (nundef(Syms[key])) return;
  let info = Syms[key];
  console.log('family', info.family);
  g.setLabel(id, info.text, addKeys({ fz: 40, family: info.family }, styles));
}
function setTableBackground(bg, fg = 'white', isBase = true) {
  bg = colorHex(bg);
  if (isBase) DA.tableBaseColor = bg;
  mStyleX(dTableBackground, { bg: bg, fg: isdef(fg) ? fg : 'contrast' });
}
function setTableSize(w, h, unit = 'px') {
  let d = mBy('areaTable');
  mStyle(d, { 'min-width': w, 'min-height': h }, unit);
}
function setText(card, text, fz = '8') {
  let el = card.elem;
  if (el.children.length > 1) {
    let elTitle = el.firstChild;
    clearElement(el);
    el.appendChild(elTitle);
  }
  let dText = document.createElement('div');
  el.appendChild(dText);
  dText.style.color = 'black';
  dText.innerHTML = text;
  dText.style.margin = '8px';
  dText.style.fontSize = fz + 'px';
}
function setTheme_dep(isDark = true) {
  let bg = dMain.style.backgroundColor;
  let lum = getBrightness(bg);
  console.log('bg is', bg, 'lum', lum)
  if (isDark) {
    if (lum < .5) return;
    else {
      bg = colorDarker(bg);
      setPageBackground(bg);
    }
  } else if (lum > .5) return; else { setPageBackground(colorLighter(bg)); }
}
function setTitle(s) { mBy('hTitle').innerHTML = s; }
function setTransformDOM(el, { x, y, scaleX, scaleY, rotDeg } = {}) {
  let info = getTransformInfoDOM(el);
  console.log('______________\n', info)
  let xNew, yNew, scaleXNew, scaleYNew, rotNew;
  if (isdef(x)) xNew = x; else xNew = info.translateX;
  if (isdef(y)) yNew = y; else yNew = info.translateY;
  if (isdef(scaleX)) scaleXNew = scaleX; else scaleXNew = info.scaleX;
  if (isdef(scaleY)) scaleYNew = scaleY; else scaleYNew = info.scaleY;
  if (isdef(rotDeg)) rotNew = rotDeg; else rotNew = info.rotation;
  let sTrans = ''; let sScale = ''; let sRot = '';
  console.log('xNew', xNew, 'yNew', yNew, 'scaleXNew', scaleXNew, 'scaleYNew', scaleYNew, 'rotNew', rotNew)
  if (xNew != 0 || yNew != 0) sTrans = `translate(${xNew}, ${yNew})`;
  if (scaleXNew != 1 || scaleYNew != 1) sScale = `scale(${scaleXNew} ${scaleYNew})`;
  if (rotNew != 0) sRot = `rotate(${rotNew})`;
  let s = (sTrans + ' ' + sScale + ' ' + sRot).trim();
  console.log('new transform:', s)
  el.style.transform = s;
}
function setup() {
  axiom = system.axiom;
  rules = system.rules;
  factor = valf(system.factor, 1);
  angle = radians(valf(system.angle, 60));
  sentence = axiom;
  let button = createButton("generate"); button.mousePressed(generate);
  button = createButton("animate"); button.mousePressed(() => interval_id = setInterval(generate, 500));
  createCanvas(400, 400);
  background(51);
  createP(axiom);
  turtle();
}
function setUpMinuteHands() {
  var containers = document.querySelectorAll('.minutes-container');
  var secondAngle = containers[0].getAttribute("data-second-angle");
  if (secondAngle > 0) {
    var delay = (((360 - secondAngle) / 6) + 0.1) * 1000;
    setTimeout(function () {
      moveMinuteHands(containers);
    }, delay);
  }
}
function setUserData(username) {
  if (nundef(DB.users[username])) {
    U = DB.users[username] = jsCopy(DB.users.guest0);
    U.id = U.name = U.username = Username = username;
  } else {
    U = DB.users[username]; U.name = U.username = Username = U.id;
  }
  U.clientId = ClientId;
}
function setUsername(inputElem) {
  USERNAME = inputElem.value.toString();
}
function setUserSpecAndCode() {
  S.user.spec = userSpec;
  S.user.specText = userSpec.asText;
  S.user.script = userCode.asText;
}
function setVocabulary(words) {
  var grammar = '#JSGF V1.0; grammar colors; public <color> = hallo';
  for (const w of words) {
    grammar += ' | ' + w;
  }
  var speechRecognitionList = new webkitSpeechGrammarList();
  speechRecognitionList.addFromString(grammar, 1);
  recognition.grammars = speechRecognitionList;
}
function setWNeeded(elem) {
  let sz = getSizeNeeded(elem);
  let r = getRect(elem);
  if (sz.w > r.w && elem.style.width != '100%') { r.w = sz.w; mStyle(elem, { w: r.w }); }
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  return r.w;
}
function setzeEineCheckbox(dParent, label, init, skeys) {
  let d = mDiv(dParent);
  let val = lookup(Settings, skeys);
  if (nundef(val)) val = init;
  let inp = createElementFromHTML(
    `<input type="checkbox" class="checkbox" ` + (val === true ? 'checked=true' : '') + ` onfocusout="setSettingsKeys(this)" >`
  );
  let labelui = createElementFromHTML(`<label>${label}</label>`);
  mAppend(d, labelui);
  mAppend(labelui, inp);
  mStyleX(inp, { maleft: 12, mabottom: 4 });
  mClass(inp, 'input');
  inp.keyList = skeys;
}
function setzeEineZahl(dParent, label, init, skeys) {
  let d = mDiv(dParent);
  let val = lookup(Settings, skeys);
  if (nundef(val)) val = init;
  let inp = createElementFromHTML(
    `<input type="number" class="input" value="${val}" onfocusout="setSettingsKeys(this)" />`);
  let labelui = createElementFromHTML(`<label>${label}</label>`);
  mAppend(d, labelui);
  mAppend(labelui, inp);
  mStyleX(inp, { maleft: 12, mabottom: 4 });
  mClass(inp, 'input');
  inp.keyList = skeys;
}
function setzeEinOptions(dParent, label, optionList, friendlyList, init, skeys) {
  let d = mDiv(dParent);
  let val = lookup(Settings, skeys);
  if (nundef(val)) val = init;
  let inp = createElementFromHTML(`<select class="options" onfocusout="setSettingsKeysSelect(this)"></select>`);
  for (let i = 0; i < optionList.length; i++) {
    let opt = optionList[i];
    let friendly = friendlyList[i];
    let optElem = createElementFromHTML(`<option value="${opt}">${friendly}</option>`);
    mAppend(inp, optElem);
    if (opt == val) optElem.selected = true;
  }
  let labelui = createElementFromHTML(`<label>${label}</label>`);
  mAppend(d, labelui);
  mAppend(labelui, inp);
  mStyleX(inp, { maleft: 12, mabottom: 4 });
  inp.keyList = skeys;
}
function shake_and_sieve(items) { }
function sheriff() {
  function sheriff_activate() {
    sheriff_pre_action();
  }
  function sheriff_check_gameover(z) {
    let [fen, round] = [z.fen, z.round];
    if (round <= z.rounds) return false;
    return arr_get_max(fen.plorder, x => fen.players[x].score);
  }
  function sheriff_setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: [] };
    let di = SHERIFF.cards;
    let deck = fen.deck = [];
    deck.push(...Array(48).fill('apples'));
    deck.push(...Array(36).fill('cheese'));
    deck.push(...Array(24).fill('pineapple'));
    deck.push(...Array(36).fill('bread'));
    deck.push(...Array(22).fill('pepper'));
    deck.push(...Array(21).fill('mead'));
    deck.push(...Array(12).fill('silk'));
    deck.push(...Array(5).fill('crossbow'));
    for (const name of ['chestnut', 'pear', 'pie', 'baguette', 'cherries']) deck.push(...Array(2).fill(name));
    for (const name of ['pretzel', 'grapes']) deck.push(name);
    shuffle(deck);
    console.log('deck', deck);
    for (const plname of players) {
      let pl = fen.players[plname] = {
        hand: deck_deal(deck, 6),
        coins: 50,
        vps: 0,
        score: 0,
        color: get_user_color(plname),
      };
    }
    console.log('fen', fen)
    fen.phase = 'market';
    fen.stage = 1;
    fen.turn = [fen.plorder[0]];
    return fen;
  }
  function sheriff_present(z, dParent, uplayer) {
    let [fen, ui] = [z.fen, UI];
    let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent);
    ari_player_stats(z, dRechts);
    show_history(fen, dRechts);
    let deck = ui.deck = ui_type_deck(fen.deck, dOpenTable, { maleft: 12 }, 'deck', 'deck', ari_get_card);
    let market = ui.market = ui_type_market(fen.market, dOpenTable, { maleft: 12 }, 'market', 'market', ari_get_card, true);
    let open_discard = ui.open_discard = ui_type_market(fen.open_discard, dOpenTable, { maleft: 12 }, 'open_discard', 'discard', ari_get_card);
    let deck_discard = ui.deck_discard = ui_type_deck(fen.deck_discard, dOpenTable, { maleft: 12 }, 'deck_discard', '', ari_get_card);
    if (exp_commissions(z.options)) {
      let open_commissions = ui.open_commissions = ui_type_market(fen.open_commissions, dOpenTable, { maleft: 12 }, 'open_commissions', 'bank', ari_get_card);
      mMagnifyOnHoverControlPopup(ui.open_commissions.cardcontainer);
      let deck_commission = ui.deck_commission = ui_type_deck(fen.deck_commission, dOpenTable, { maleft: 4 }, 'deck_commission', '', ari_get_card);
      let comm = ui.commissioned = ui_type_rank_count(fen.commissioned, dOpenTable, {}, 'commissioned', 'sentiment', ari_get_card);
      if (comm.items.length > 0) { let isent = arrLast(comm.items); let dsent = iDiv(isent); set_card_border(dsent, 15, 'green'); }
    }
    let order = [uplayer].concat(fen.plorder.filter(x => x != uplayer));
    for (const plname of order) {
      let pl = fen.players[plname];
      let playerstyles = { w: '100%', bg: '#ffffff80', fg: 'black', padding: 4, margin: 4, rounding: 10, border: `2px ${get_user_color(plname)} solid` };
      let d = mDiv(dMiddle, playerstyles, null, get_user_pic_html(plname, 25));
      mFlexWrap(d);
      mLinebreak(d, 10);
      ari_present_player(z, plname, d, plname != uplayer);
    }
    if (isdef(fen.winners)) ari_reveal_all_buildings(fen);
  }
  function ari_present_player(g, plname, d, ishidden = false) {
    let fen = g.fen;
    let pl = fen.players[plname];
    let ui = UI.players[plname] = {};
    pl.hand = fen.stage == '1' ? sort_cards(pl.hand, true, 'CDSH', true, 'A23456789TJQK') : sort_cards(pl.hand, false, null, true, 'A23456789TJQK');
    let hand = ui.hand = ui_type_hand(pl.hand, d, {}, `players.${plname}.hand`, 'hand', ari_get_card);
    if (ishidden) { hand.items.map(x => face_down(x)); }
    let stall = ui.stall = ui_type_market(pl.stall, d, { maleft: 12 }, `players.${plname}.stall`, 'stall', ari_get_card);
    if (fen.stage < 5 && ishidden) { stall.items.map(x => face_down(x)); }
    ui.buildinglist = [];
    for (const k in pl.buildings) {
      let i = 0;
      for (const b of pl.buildings[k]) {
        let type = k;
        let b_ui = ui_type_building(b, d, { maleft: 8 }, `players.${plname}.buildings.${k}.${i}`, type, ari_get_card);
        b_ui.type = k;
        ui.buildinglist.push(b_ui);
        lookupAddToList(ui, ['buildings', k], b_ui);
        i += 1;
      }
    }
    if (exp_commissions(g.options) && (!ishidden || isdef(fen.winners))) {
      pl.commissions.sort();
      ui.commissions = ui_type_market(pl.commissions, d, { maleft: 12 }, `players.${plname}.commissions`, 'commissions', ari_get_card);
      mMagnifyOnHoverControlPopup(ui.commissions.cardcontainer);
    }
    ui.journeys = [];
    let i = 0;
    for (const j of pl.journeys) {
      let jui = ui_type_hand(j, d, { maleft: 12 }, `players.${plname}.journeys.${i}`, '', ari_get_card);
      i += 1;
      ui.journeys.push(jui);
    }
  }
  function ari_player_stats(z, dParent) {
    let player_stat_items = UI.player_stat_items = ui_player_info(z, dParent);
    let fen = z.fen;
    let herald = fen.heraldorder[0];
    for (const uname of fen.plorder) {
      let pl = fen.players[uname];
      let item = player_stat_items[uname];
      let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
      if (uname == herald) {
        mSym('tied-scroll', d, { fg: 'gold', fz: 24, padding: 4 }, 'TR');
      }
      player_stat_count('coin', pl.coins, d);
      if (!isEmpty(fen.players[uname].stall) && fen.stage >= 5 && fen.stage <= 6) {
        player_stat_count('shinto shrine', !fen.actionsCompleted.includes(uname) || fen.stage < 6 ? calc_stall_value(fen, uname) : '_', d);
      }
      player_stat_count('star', uname == U.name || isdef(fen.winners) ? ari_calc_real_vps(fen, uname) : ari_calc_fictive_vps(fen, uname), d);
      if (fen.turn.includes(uname)) {
        show_hourglass(uname, d, 30, { left: 10, top: 'calc( 50% - 36px )' });
      }
    }
  }
  function sheriff_state(dParent) {
    function get_phase_html() {
      if (isEmpty(Z.phase) || Z.phase == 'over') return null;
      let rank = Z.phase[0].toUpperCase();
      let card = ari_get_card(rank + 'Hn', 40);
      let d = iDiv(card);
      mClassRemove(d.firstChild, 'card');
      return iDiv(card).outerHTML;
    }
    let user_html = get_user_pic_html(Z.uplayer, 30);
    let phase_html = get_phase_html();
    if (phase_html) dParent.innerHTML = `${Z.phase}:&nbsp;${phase_html}&nbsp;player: ${user_html} `;
  }
  return { state_info: sheriff_state, setup: sheriff_setup, present: sheriff_present, present_player: ari_present_player, check_gameover: sheriff_check_gameover, stats: ari_player_stats, activate_ui: sheriff_activate };
}
function sheriff_card(name, color) {
  let di = SHERIFF.cards;
  let info = valf(di[name], { ksym: 'crossbow', kcenter: 'green apple', label: 'crossbow', type: 'contraband', value: 9, penalty: 4 });
  let bcolor = SHERIFF.color[info.type];
  let c = cPortrait(null, { margin: 12, border: `solid 4px ${bcolor}`, bg: valf(color, colorLight('gold', 60)) });
  let d = iDiv(c);
  let ds = mSym(info.ksym, d, { sz: 30 }, 'tl');
  ds = mSymText(info.value, d, { sz: 25, rounding: '50%', bg: 'gold', margin: 3 }, 'tr');
  ds = mText(info.label.toUpperCase(), d, { family: 'Algerian', w: '100%', fz: 12, align: 'center', position: 'absolute', bottom: 0 });
  ds = mText(info.label.toUpperCase(), d, { family: 'Algerian', w: '100%', fz: 12, align: 'center', position: 'absolute', top: 0 });
  ds = mSymText(info.penalty, d, { sz: 25, rounding: '50%', bg: 'crimson', margin: 3 }, 'br');
  ds = mSym(info.kcenter, d, { sz: 70 }, 'cc'); mPos(ds, 'calc( 50% - 35px )', 'calc( 50% - 35px )');
  return c;
}
function sheriff_pre_action() {
  let [stage, A, fen, phase, uplayer, deck, market] = [Z.stage, Z.A, Z.fen, Z.phase, Z.uplayer, Z.deck, Z.market];
  if (Z.num_actions > 0) fen.progress = `(action ${Z.action_number} of ${Z.total_pl_actions})`; else delete fen.progress;
  switch (ARI.stage[stage]) {
    case 'journey': select_add_items(ui_get_hand_and_journey_items(uplayer), process_journey, 'may form new journey or add cards to existing one'); break;
    case 'add new journey': post_new_journey(); break;
    case 'auto market': ari_open_market(fen, phase, deck, market); break;
    case 'stall selection': select_add_items(ui_get_hand_items(uplayer), post_stall_selected, 'must select your stall'); break;
    case 'action: command': Z.stage = 6; select_add_items(ui_get_commands(uplayer), process_command, 'must select an action', 1, 1); break;
    case 'tax': let n = fen.pl_tax[uplayer]; select_add_items(ui_get_hand_items(uplayer), post_tax, 'must pay tax', n, n); break;
    case 'action step 2':
      switch (A.command) {
        case 'trade': select_add_items(ui_get_trade_items(uplayer), post_trade, 'must select 2 cards to trade', 2, 2); break;
        case 'build': select_add_items(ui_get_payment_items('K'), payment_complete, 'must select payment for building', 1, 1); break;
        case 'upgrade': select_add_items(ui_get_payment_items('K'), payment_complete, 'must select payment for upgrade', 1, 1); break;
        case 'downgrade': select_add_items(ui_get_building_items(uplayer, A.payment), process_downgrade, 'must select a building to downgrade', 1, 1); break;
        case 'pickup': select_add_items(ui_get_stall_items(uplayer), post_pickup, 'must select a stall card to take into your hand', 1, 1); break;
        case 'harvest': select_add_items(ui_get_harvest_items(uplayer), post_harvest, 'must select a farm to harvest from', 1, 1); break;
        case 'sell': select_add_items(ui_get_stall_items(uplayer), post_sell, 'must select 2 stall cards to sell', 2, 2); break;
        case 'buy': select_add_items(ui_get_payment_items('J'), payment_complete, 'must select payment option', 1, 1); break;
        case 'exchange': select_add_items(ui_get_exchange_items(uplayer), post_exchange, 'must select cards to exchange', 2, 2); break;
        case 'visit': select_add_items(ui_get_payment_items('Q'), payment_complete, 'must select payment for visiting', 1, 1); break;
        case 'commission': select_add_items(ui_get_commission_items(uplayer), process_commission, 'must select a card to commission', 1, 1); break;
        case 'pass': post_pass(); break;
      }
      break;
    case 'build': select_add_items(ui_get_build_items(uplayer, A.payment), post_build, 'must select cards to build (first card determines rank)', 4, 6); break;
    case 'commission new': select_add_items(ui_get_commission_new_items(uplayer), post_commission, 'must select a new commission', 1, 1); break;
    case 'upgrade': select_add_items(ui_get_build_items(uplayer, A.payment), process_upgrade, 'must select card(s) to upgrade a building', 1); break;
    case 'select building to upgrade': select_add_items(ui_get_farms_estates_items(uplayer), post_upgrade, 'must select a building', 1, 1); break;
    case 'select downgrade cards': select_add_items(A.possible_downgrade_cards, post_downgrade, 'must select card(s) to downgrade a building', 1); break;
    case 'buy': select_add_items(ui_get_open_discard_items(uplayer, A.payment), post_buy, 'must select a card to buy', 1, 1); break;
    case 'visit': select_add_items(ui_get_other_buildings(uplayer, A.payment), process_visit, 'must select a farm to visit', 1, 1); break;
    case 'visit destroy': select_add_items(ui_get_string_items(['destroy', 'get cash']), post_visit, 'must destroy the building or select the cash', 1, 1); break;
    case 'ball': select_add_items(ui_get_hand_items(uplayer), post_ball, 'may add cards to the ball'); break;
    case 'auction: bid': select_add_items(ui_get_coin_amounts(uplayer), process_auction, 'must bid for the auction', 1, 1); break;
    case 'auction: buy': select_add_items(ui_get_market_items(), post_auction, 'must buy a card', 1, 1); break;
    case 'end game?': select_add_items(ui_get_endgame(uplayer), post_endgame, 'may end the game here and now or go on!', 1, 1); break;
    case 'pick luxury or journey cards': select_add_items(ui_get_string_items(['luxury cards', 'journey cards']), post_luxury_or_journey_cards, 'must select luxury cards or getting cards from the other end of the journey', 1, 1); break;
    default: console.log('stage is', stage); break;
  }
}
function shield_off() {
  mStyle('dAdmin', { bg: 'white' });
}
function shield_on() {
  mShield(dTable.firstChild.childNodes[1]);
  mStyle('dAdmin', { bg: 'silver' });
}
function shortHintPic() {
  mClass(mBy(Goal.id), 'onPulse1');
  TOMain = setTimeout(() => shortHintPicRemove(), 800);
}
function shortHintPicRemove() {
  mRemoveClass(mBy(Goal.id), 'onPulse1');
}
function show(elem, isInline = false) {
  if (isString(elem)) elem = document.getElementById(elem);
  if (isSvg(elem)) {
    elem.setAttribute('style', 'visibility:visible');
  } else {
    elem.style.display = isInline ? 'inline-block' : null;
  }
  return elem;
}
function show_account() {
  if (isdef(mBy('dAccount').firstChild)) { console.log('NOPE!'); return; }
  DA.imageChanged = false;
  let dParent = mBy('dAccount');
  clearElement(dParent);
  let d = mDiv(dParent, { matop: 20 });
  let dir = '../base/assets/images/';
  let imagePath = dir + (Userdata.hasImage ? Username : 'unknown_user') + '.jpg';
  d.append(createElementFromHtml(`
  <div class="wrapper" style="margin-top:5%; animation: appear 4s ease;">
  <div id="error">some text</div>
  <form id="myform" autocomplete="off" action="index.php" method="POST">
    <div id='dImage'>
      <span style="font-size:11px;">drag and drop an image to change</span><br>
      <img id="imgPreview" src='${imagePath}' ondragover="handle_drag_and_drop(event)" ondrop="handle_drag_and_drop(event)" ondragleave="handle_drag_and_drop(event)"
        style="height:200px;margin:10px;" />
    </div>
    <input id='iUsername' type="text" name="username" placeholder='username' value="${Username}" autofocus />
    <br />
    <!-- <input type="password" name="password" />
    <br /> -->
    <input type="submit" />
  </form>
  </div>
  `));
  var form = document.getElementById('myform');
  form.onsubmit = e => {
    e.preventDefault();
    let el = document.getElementById('iUsername');
    let val = el.value;
    if (Username != val) {
      onClickSubmitUsernameChange(val);
    } else if (DA.imageChanged) {
      onClickSubmitImageChange();
    }
  };
}
function show_admin_ui() {
  for (const id of ['bSpotitStart', 'bClearAck', 'bRandomMove', 'bSkipPlayer', 'bRestartMove']) hide(id);
  if (Z.game == 'spotit' && Z.uname == Z.host && Z.stage == 'init') show('bSpotitStart');
  else if (Z.game == 'bluff' && Z.uname == Z.host && Z.stage == 1) show('bClearAck');
  else if (Z.uname == Z.host && Z.stage == 'round_end') show('bClearAck');
  else if (Z.game == 'ferro' && Z.uname == 'mimi' && Z.stage != 'card_selection') show('bClearAck');
  if (['ferro', 'bluff', 'aristo', 'a_game'].includes(Z.game) && (Z.role == 'active' || Z.mode == 'hotseat')) {
    show('bRandomMove');
  }
  if (Z.uname == Z.host || Z.uname == 'mimi') show('dHostButtons'); else hide('dHostButtons');
  if (DA.TEST0 == true) show('dTestButtons'); else hide('dTestButtons');
}
function show_advanced_ui() {
  show('dButtons');
  show('dTest0');
  show('dTopAdvanced');
  DA.testing = true;
  DA.test = { iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [100, 101] };
  DA.test.list = arrRange(100, 101);
  DA.test.number = 306;
  DA.staged_moves = []; DA.iter = 100; DA.auto_moves = {};
}
function show_all_players() { populate_players(get_def_players_for_user(Session.cur_user)); }
function show_apps(ms = 500) {
  let dParent = mBy('dApps');
  if (!isEmpty(arrChildren(dParent))) { show(dParent); return; }
  show_standard_title(dParent, 'Apps');
  let d = mDiv(dParent, { fg: 'white' }, 'apps_menu');
  mCenterFlex(d);
  let applist = 'action book fitbit howto magic meditate therapy';
  for (const id of toWords(applist)) {
    let app = DB.apps[id]; app.name = id; let f = get_app_presenter(app.id); f(d, app);
  }
}
function show_available_voices() { say('', 'english male', () => console.log(DA.voicelist.map(x => x.name))); }
function show_bars() {
  let d = mDiv(dTable, { w: '100%', box: true, opacity: 0 }, 'dBars');
  mLinebreak(d);
  let dgreen = get_plus_progressbar(d, 'green');
  mLinebreak(d);
  let dred = get_plus_progressbar(d, 'red');
  mLinebreak(d);
  DA.bars = {
    green: dgreen,
    red: dred,
  };
  return d;
}
function show_bill_button() {
  if (isdef(mBy('tbbill'))) return;
  let tb = mBy('dTopRight');
  let b = mDiv(tb, {}, `tbbill`, `<a href="javascript:onclick_bill()"><img src="../rechnung/images/bill.png" height="30"/></a>`);
  mInsert(tb, b);
}
function show_card(dParent, key, type = 'aristo') {
  if (type == 'spotit') {
    Card.sz = 200;
    let [rows, cols, numCards, setName] = [3, 2, 2, valf(key, 'animals')];
    let infos = spotitDeal(rows, cols, numCards, setName);
    let items = [];
    for (const info of infos) {
      let item = spotitCard(info, dParent, { margin: 10 }, spotitOnClickSymbol);
      mStyle(iDiv(item), { padding: 12 });
      items.push(item);
    }
  } else if (type == 'aristo') {
    let card = ari_get_card(valf(key, 'ASr'));
    mAppend(dParent, iDiv(card))
  }
}
function show_checkmark(dParent, styles = { fg: 'limegreen' }) {
  let b = getRect(dParent);
  let fz = b.h;
  if (nundef(styles.fz)) styles.fz = fz;
  let d1 = mDiv(document.body, { position: 'fixed', w: b.w, h: b.h, top: b.t, left: b.l, align: 'center', overflow: 'visible' });
  let d2 = mDiv(d1);
  mClass(d1, 'no_events');
  d2.innerHTML = 'A';
  d2.style.fontSize = '' + Math.round(b.h) + 'px';
  d2.style.color = 'green';
  Markers.push(d1);
}
function show_click_vocab() {
  let cmd = 'click';
  let vocab = Goal.label;
  let voice = G.language;
  let dParent = dTitle;
  let fz = 36;
  let fSpeak = () => {
    Speech.say(cmd, 1, .8, .9, 'random', () => {
      Speech.say(vocab, 1, .8, .9, voice);
    }, 'E');
  };
  fSpeak();
  clearElement(dParent);
  let d = mDiv(dParent);
  mStyle(d, { margin: 15 })
  mClass(d, 'flexWrap');
  let msg = cmd + " " + `<b>${vocab.toUpperCase()}</b>`;
  if (nundef(fz)) fz = 36;
  let d1 = mText(msg, d, { fz: fz, display: 'inline-block' });
  let sym = symbolDict.speaker;
  let d2 = mText(sym.text, d, {
    fz: fz + 2, weight: 900, display: 'inline-block',
    family: sym.family, 'padding-left': 14
  });
  dFeedback = dInstruction = d;
  dInstruction.addEventListener('click', () => ani_say(dInstruction, () => {
    Speech.say(vocab, 1, .8, .9, voice);
  }));
}
function show_code(res, download = false) {
  if (isdef(res.target)) { res.key = res.target.innerHTML; res.text = CODE.justcode[res.key]; }
  dTable = mBy('dTable');
  let ta = dTable.getElementsByTagName('textarea')[0];
  let text = res.text;
  if (nundef(ta)) ta = mTextarea(null, null, dTable, { w: '100%', h: '100%' });
  ta.value = text;
  if (download) downloadAsText(text, 'hallo', 'js');
  ta.scrollTop = ta.scrollHeight;
  return res;
}
function show_code_editor() {
  mHide('fSearch')
  mClear(dTable);
  mDiv(dTable, { w: '100%' }, null, 'Enter Code:');
  let d = mTextArea(25, 120, dTable, { fz: 16, margin: 'auto', padding: 10, outline: 'none', border: 'none' }, 'dCode');
  let dButtons = mDiv(dTable, { display: 'flex', w: '100%' });
  let asave = mLink("javascript:void(0)", dButtons, {}, null, 'Save Code', 'a');
  asave.onclick = db_add_code;
  let aclear = mLink("javascript:void(0)", dButtons, {}, null, 'Clear Code', 'a');
  aclear.onclick = () => d.value = '';
}
function show_code_list(list) {
  mClear(dTable);
  for (const code of list) {
    let d = mDiv(dTable, { w: '100%' });
    let dkw = mDiv(d, {}, null, code.kw);
    let text = code.c; let lines = text.split('\n'); let rows = lines.length;
    let dcode = mDiv(d, {}, null, `<textarea rows=${rows} cols=120>${code.c}</textarea>`);
  }
}
function show_compose() { mCardButton('compose', onclick_compose, dTable); }
function show_correct_location(k) {
  hide('dPopup');
  for (const k1 in DIBOA) { hide(`d${capitalize(k1)}`); }
  S.location = k;
  show(`d${capitalize(k)}`);
}
function show_dd_click_letters(word, dTable, wTotal, gap = 4) {
  let wmax = wTotal / word.length;
  let fzMax = wmax - 3 * gap;
  fz = Math.min(60, fzMax);
  let dp = createLetterInputsX(word, dTable, { bg: 'silver', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
  shuffle_children(dp);
  let letters = Array.from(dp.children);
  for (let i = 0; i < letters.length; i++) {
    let l = letters[i];
    l.setAttribute('draggable', true);
    ipaddX(l, 'source');
    l.id = 'letter' + i;
  }
  return letters;
}
function show_div_ids() {
  let divs = Array.from(document.getElementsByTagName('div')).filter(d => !isEmptyOrWhiteSpace(d.id) && !isEmpty(d.innerHTML));
  for (const d of divs) {
    let d1 = mDiv(d, { fz: 12, bg: 'black', fg: 'white', hpadding: 4, rounding: 12 }, null, d.id);
    mPlace(d1, 'tr', 2, 2);
  }
}
function show_emos() {
  let d = mDiv(dTable, DA.styles);
  for (const k in EMO.emoscale) {
    let emo = EMO.emoscale[k];
    let sym = Syms[emo.key];
    let item = { name: k, key: emo.key, text: sym.text, color: emo.color, family: sym.family, list: emo.list };
    let handler = question2;
    let d1 = ui_type_item_line(d, item, { cursor: 'pointer', aitems: 'center', vpadding: 6, hpadding: 12, gap: 4, margin: 6, rounding: 12, bg: item.color, fg: 'contrast' }, handler, ['text', 'list']);
    iAdd(item, { div: d1 });
  }
}
function show_eval_message(correct, msg = null, callback = null) {
  if (isdef(DA.anim)) { DA.anim.onfinish = null; DA.anim.cancel(); }
  if (nundef(msg)) msg = correct ? `Congratulations!!! You passed the ${DA.name} challenge!` : 'Wrong solution - Try Again!';
  let d = valf(mBy('dBandMessage'), mDiv(document.body, {}, 'dBandMessage'));
  show(d);
  clearElement(d);
  d.innerHTML = msg; 
  mStyle(d, { display: 'block', position: 'fixed', top: 127, left: 0, bg: 'red', fg: 'white', w: '100%', h: 40, hmin: 40, hmax: 40, fz: 24, align: 'center', vpadding: 10, classname: 'slow_gradient_blink' });
  DA.anim = mFadeRemove(d, 4000, callback);
}
function show_feedback(is_correct, correction = true) {
  function success() {
    if (isdef(Selected) && isdef(Selected.feedbackUI)) {
      let uilist;
      if (isdef(Selected.positiveFeedbackUI)) uilist = [Selected.positiveFeedbackUI];
      else uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
      let sz = getRect(uilist[0]).h;
      for (const ui of uilist) {
        mpOver(markerSuccess(), ui, sz, 'green', 'segoeBlack');
      }
    }
    return 500;
  }
  function fail() {
    if (isdef(Selected) && isdef(Selected.feedbackUI)) {
      let uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
      let sz = getRect(uilist[0]).h;
      for (const ui of uilist) {
        mpOver(markerFail(), ui, sz, 'red', 'segoeBlack');
      }
    }
    return 1000;
  }
  if (is_correct) { return success(); }
  else {
    if (correction) {
      let anim = valf(Selected.animation, 'onPulse5');
      for (const ui of Selected.correctUis) { mClass(ui, anim); }
    }
    return fail();
  }
}
function show_fiddle() { fiddleInit(); }
function show_fleeting_message(s, dParent, styles, id, ms = 2000) {
  let d = mDiv(dParent, styles, id, s);
  mFadeRemove(d, ms);
}
function show_game_name(gname) { dGameTitle.innerHTML = gname; }
function show_game_options(dParent, game) {
  mRemoveChildrenFromIndex(dParent, 2);
  let poss = Config.games[game].options;
  if (nundef(poss)) return;
  for (const p in poss) {
    let key = p;
    let val = poss[p];
    if (isString(val)) {
      let list = val.split(',');
      let fs = mRadioGroup(dParent, {}, `d_${key}`, key);
      for (const v of list) { mRadio(v, isNumber(v) ? Number(v) : v, key, fs, { cursor: 'pointer' }, null, key, true); }
      measure_fieldset(fs);
    }
  }
}
function show_game_options_menu(gamename) {
  let dMenu = mBy('dMenu'); iClear(dMenu);
  show_standard_title(dMenu, 'Game Options');
  let d = mDiv(dMenu, { align: 'center' }, 'fMenuInput');
  let dOptions = mDiv(d, {}, 'dMenuInput'); mCenterFlex(dOptions);
  let dButtons = mDiv(d, { display: 'flex', justify: 'center', w: '100%' }, 'dMenuButtons');
  DA.playerlist = null;
  show_game_options(dOptions, gamename);
  let astart = maButton('Start', start_game, dButtons);
  let acancel = maButton('Cancel', cancel_game, dButtons);
}
function show_game_screen(host = true) {
  if (in_game_screen) return;
  in_game_screen = true;
  screen_transition('dTable', 'dHeader');
  is_host = host;
  granularity = 100 / window.innerWidth; console.log('granularity:', granularity);
  mClear(dTable);
  mStyle(dTable, { hmin: 300 });
  let d = mDiv(dTable, { w: '100%', box: true, opacity: 0 }, 'dBars');
  mAppear(d, 500, null, 'linear');
  mLinebreak(d, 20);
  let dp = mDiv(d, { margin: 10, padding: 20 }, null, null, 'card')
  mLinebreak(dp, 20);
  dgreen = get_progressbar(dp, 'green', '+').bar;
  mLinebreak(dp, 20);
  dred = get_progressbar(dp, 'red', '-').bar;
  mLinebreak(dp, 20);
  if (!is_host) return;
  let d1 = mDiv(dp, { gap: 12 }, 'dButtons', null, ['d-flex', 'justify-content-center']);
  mButton('reset', send_reset, d1, {}, 'button');
  mButton('pause', send_pause, d1, {}, 'button');
  mButton('resume', send_resume, d1, {}, 'button');
  mLinebreak(dp, 20);
  mBy('dSettingsButton').style.opacity = 1;
}
function show_gameover(winners) {
  let pl = Session.cur_players[winners[0]];
  let styles = { bg: pl.color, fg: 'contrast', top: 220, };
  if (winners.length > 1) {
    status_message(`GAME OVER - The winners are ${winners.join(', ')}!!!`, styles);
  } else {
    status_message(`GAME OVER - The winner is ${winners[0]}!!!`, styles);
  }
}
function show_gameover_new(winners) {
  let game = Session.cur_game;
  let table = Session.cur_table;
  if (!Session.scoring_complete) {
    console.log('======>scoring!!!!!', table.friendly);
    scoring_update(get_keys(Session.cur_players), winners, game);
    if (Session.level_setting == 'player') {
      inc_level_on_winstreak(winners, game);
      dec_level_on_losestreak();
    }
    out1();
    Session.scoring_complete = true;
  }
  let pl = Session.cur_players[winners[0]];
  let styles = { bg: pl.color, alpha: .75, fg: 'contrast', top: 220, };
  let msg = 'GAME OVER - The ' + (winners.length > 1 ? `winners are ${winners.join(', ')}!!!` : `winner is ${winners[0]}!!!`);
  let d = status_message(msg, styles);
  let end_scores = table.status == 'past' ? table.end_scoring : get_scores_from_cur_players();
  show_score_table(end_scores, table.friendly, d);
  mLinebreak(d);
  mButton('click to close', onclick_gameover_new, d, { fz: 20 }, ['buttonClass', 'donebutton']);
}
function show_games(ms = 500) {
  let dParent = mBy('dGames');
  mClear(dParent);
  mText(`<h2>start new game</h2>`, dParent, { maleft: 12 });
  let d = mDiv(dParent, { fg: 'white', animation: 'appear 1s ease both' }, 'game_menu');
  mCenterFlex(d);
  let gamelist = 'aristo bluff spotit ferro fritz'; if (DA.TEST0) gamelist += ' a_game';
  for (const g of dict2list(Config.games)) {
    if (gamelist.includes(g.id)) {
      let [sym, bg, color, id] = [Syms[g.logo], g.color, null, getUID()];
      let d1 = mDiv(d, { cursor: 'pointer', rounding: 10, margin: 10, vpadding: 15, wmin: 140, bg: bg, position: 'relative' }, g.id);
      d1.setAttribute('gamename', g.id);
      d1.onclick = onclick_game_menu_item;
      mCenterFlex(d1);
      mDiv(d1, { fz: 50, family: sym.family, 'line-height': 55 }, null, sym.text);
      mLinebreak(d1);
      mDiv(d1, { fz: 18, align: 'center' }, null, g.friendly);
    }
  }
}
function show_games_menu() {
  console.assert(isdef(S.tables_by_game), 'ERROR', getFunctionCallerName(), 'S.tables_by_game not set!');
  console.log('tables for user', U.name, S.tables);
  let html = `<div id='game_menu' style="text-align: center; animation: appear 1s ease both">`;
  for (const g of dict2list(DB.games)) { html += ui_game_menu_item(g, S.tables_by_game[g.id]); }
  mBy('inner_left_panel').innerHTML = html;
  mCenterCenterFlex(mBy('game_menu'));
}
function show_gametable(dParent, clickplayer = 'onclick_player_in_gametable', clickgame = 'onclick_game') {
  clear_gametable();
  if (isEmpty(Serverdata.games)) return [];
  let items = mDataTable(Serverdata.games, dParent, null, ['name', 'gamename', 'turn', 'players', 'step', 'round']);
  mTableCommandify(items, {
    0: (item, val) => hFunc(val, clickgame, val),
    2: (item, val) => mTableCommandifyList(item, val, (rowitem, valpart) => hFunc(valpart, clickplayer, valpart, rowitem.o.name)),
    3: (item, val) => mTableCommandifyList(item, val, (rowitem, valpart) => hFunc(valpart, clickplayer, valpart, rowitem.o.name)),
  });
  return items;
}
function show_guest_screen() { get_intro(); }
function show_handsorting_buttons_for(plname, styles = {}) {
  if (Z.role == 'spectator' || isdef(mBy('dHandButtons'))) return;
  let fen = Z.fen;
  let pl = fen.players[plname];
  if (pl.hand.length <= 1) return;
  let d = UI.players[plname].hand.container; mStyle(d, { position: 'relative', wmin: 155 });
  addKeys({ position: 'absolute', left: 58, bottom: -8, height: 25 }, styles);
  let dHandButtons = mDiv(d, styles, 'dHandButtons');
  show_player_button('rank', dHandButtons, onclick_by_rank);
  show_player_button('suit', dHandButtons, onclick_by_suit);
}
function show_history(fen, dParent) {
  if (!isEmpty(fen.history)) {
    let html = '';
    for (const o of jsCopy(fen.history).reverse()) {
      html += beautify_history(o.lines, o.title, fen);
    }
    let dHistory = mDiv(dParent, { paleft: 12, bg: colorLight('#EDC690', .5), box: true, matop: 4, rounding: 10, patop: 10, pabottom: 10, w: '100%', hmax: `calc( 100vh - 250px )`, 'overflow-y': 'auto', w: 260 }, null, html);
    UI.dHistoryParent = dParent;
    UI.dHistory = dHistory;
    if (isdef(Clientdata.historyLayout)) {
      show_history_layout(Clientdata.historyLayout);
    }
  }
}
function show_history_layout(layout) {
  assertion(isdef(UI.dHistoryParent) && isdef(UI.dHistory), 'UI.dHistoryParent && UI.dHistory do NOT exist!!!');
  if (layout == 'ph') PHLayout();
  else if (layout == 'hp') HPLayout();
  else if (layout == 'prh') PRHLayout();
  else if (layout == 'hrp') HRPLayout();
  else PHLayout();
}
function show_history_popup() {
  if (isEmpty(Z.fen.history)) return;
  assertion(isdef(UI.dHistoryParent) && isdef(UI.dHistory), 'UI.dHistoryParent && UI.dHistory do NOT exist!!!');
  let l = valf(Clientdata.historyLayout, 'ph');
  let cycle = ['ph', 'hp', 'prh', 'hrp'];
  let i = (cycle.indexOf(l) + 1) % cycle.length;
  show_history_layout(cycle[i]);
}
function show_home() {
  console.log('hallo! should clear table!!!')
  mClear(dTable);
  show_motto();
  mLinebreak(dTable, 40);
  show_compose();
  mLinebreak(dTable, 4);
  show_recent_contributions();
}
function show_home_logo() {
  let bg = colorLight();
  let dParent = mBy('dAdminLeft');
  clearElement(dParent);
  let d = miPic('castle', dParent, { cursor: 'pointer', fz: 24, padding: 6, h: 36, box: true, margin: 2 });
  d.onclick = db_load;
  let version = 'v0.0.1';
  let html = `version ${version}`
  mText(html, dParent, { fz: 12 });
}
function show_hourglass(uname, d, sz, stylesPos = {}) {
  let html = get_waiting_html(sz);
  mStyle(d, { position: 'relative' });
  addKeys({ position: 'absolute' }, stylesPos);
  let dw = mDiv(d, stylesPos, `dh_${uname}`, html);
}
function show_instruction(msg) { mBy('dSelections0').innerHTML = msg; }
function show_instruction_different(dParent, wlist, slist, styles) {
  wlist = [
    { phrase: 'click', styles: { fg: 'red' } },
    { phrase: 'tomato', styles: { fg: 'red' } },
  ];
  slist = [
    { phrase: 'click', voice: 'default', }
  ];
  console.assert(isdef(Speech));
  clearElement(dParent);
  let d = mDiv(dParent);
  mStyle(d, { margin: 15 })
  mClass(d, 'flexWrap');
  let msg = cmd + " " + `<b>${text.toUpperCase()}</b>`;
  if (nundef(fz)) fz = 36;
  let d1 = mText(msg, d, { fz: fz, display: 'inline-block' });
  if (nundef(fz)) fz = 36;
  d1 = mText(written, d, { fz: fz, display: 'inline-block' });
  if (isSpoken) {
    let sym = symbolDict.speaker;
    let d2 = mText(sym.text, d, {
      fz: fz + 2, weight: 900, display: 'inline-block',
      family: sym.family, 'padding-left': 14
    });
  }
  dFeedback = dInstruction = d;
  spoken = isSpoken ? isdef(spoken) ? spoken : cmd + " " + text : null;
  dInstruction.addEventListener('click', () => aniInstruction(spoken));
  if (!isSpoken) return;
  sayRandomVoice(isdef(spoken) ? spoken : (cmd + " " + text), null, "david");
  let sym = symbolDict.speaker;
  let d2 = mText(sym.text, d, {
    fz: fz + 2, weight: 900, display: 'inline-block',
    family: sym.family, 'padding-left': 14
  });
  dFeedback = dInstruction = d;
  dInstruction.addEventListener('click', () => aniInstruction(spoken));
  if (isdef(spoken)) sayRandomVoice(spoken, spoken, voice);
}
function show_intro_screen() {
  if (!in_game_screen) return;
  in_game_screen = false;
  screen_transition('dHeader', 'dTable');
  mBy('dSettingsButton').style.opacity = 0;
}
function show_jittering() { let b = mBy('bJittering'); b.innerHTML = jittering ? 'repair' : 'desintegrate'; }
function show_letter_inputs(word, dTable, wTotal, gap = 4) {
  let fzMax = wTotal / word.length - 3 * gap;
  let fz = Math.min(70, fzMax);
  let dpEmpty = createLetterInputsX(word, dTable, { pabottom: 5, bg: 'grey', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: gap });
  let inputs = blankInputs(dpEmpty, range(0, word.length - 1), false);
  for (let i = 0; i < inputs.length; i++) {
    let l = iDiv(inputs[i]);
    ipaddX(l, 'both');
    mClass(l, 'dropzone');
    l.id = 'input' + i;
  }
  return inputs;
}
function show_level(level, maxlevel) {
  let handicap = maxlevel - level;
  dLevel.innerHTML = `level: ${level}`;
  mStyle(dLevel, { fg: level >= 8 ? get_user_color() : 'white' });
}
function show_logged_in_user_simple() {
  let uname = U.name;
  let sz = 36;
  let html = `
  <div username='${uname}' style='display:flex;align-items:center;gap:6px;height:100%'>
    <img src='../base/assets/images/${uname}.jpg' width='${sz}' height='${sz}' class='img_person' style='border:3px solid ${U.color};margin:0'>
    <span>${uname}</span>
  </div>`;
  show_title_right(html, { fg: U.color });
}
function show_map_dims() {
  let map = M.map;
  console.log('________ at zoom', map.getZoom());
  console.log('meters per pixel', get_meters_per_pixel());
  console.log('map dims in meters', get_map_dims_in_meters());
  console.log('map dims in lat lon', get_map_dims_in_lat_long());
  console.log('map dims in pixel', get_map_dims_in_pixel());
}
function show_master_password() {
  let score = localStorage.getItem('score');
  show_special_message('the bitwarden master password is ' + S.master_password, false, 5000, 2000, { bg: 'dodgerblue', classname: '', top: 400 });
}
function show_medium_ui() { DA.testing = false; hide('dButtons'); hide('dTest0'); hide('dTopAdvanced'); toggle_games_off(); }
function show_message(msg = '', stay = false) {
  mStyle(dTable, { transition: 'all 1s ease' });
  let d = mBy('dMessage'); d.innerHTML = msg;
  if (stay) return;
  let ms = 1000, delay = 3000;
  let anim = d.animate([{ transform: `scale(1,1)`, opacity: 1 }, { transform: `scale(1,0)`, opacity: 0 },], { duration: 1000, easing: 'ease', delay: delay });
  dTable.animate([{ transform: 'translateY(0px)' }, { transform: 'translateY(-56px)' },], { fill: 'none', duration: ms, easing: 'ease', delay: delay });
  anim.onfinish = () => {
    mClear(d);
  }
}
function show_MMM(msg) { show_fleeting_message(msg, mBy('dMMM')); }
function show_motto() {
  let d = mBy('dMotto');
  mLinebreak(d, 6);
  mDiv(d, {}, null, `Chillax. Dream. Let Go.`);
  mLinebreak(d);
  mDiv(d, {}, null, `Life made simple and light.`);
}
function show_my_role(role) {
  let dRoles = mBy('dRoles');
  dRoles.innerHTML = `<h1>${role}</h1>`;
  Clientdata.role = role;
  mAppear(dRoles, 1000, null, 'linear');
  let d = show_bars();
  mAppear(d, 1000, null, 'linear');
  if (role == 'host') {
    mButton('reset', onclick_reset_progressbars, d, { h: 30, w: 100 });
    disable_bar_ui();
  } else if (role == 'guest') {
    if (nundef(Clientdata.uid)) Clientdata.uid = rUniqueId(30);
    Clientdata.new_clicks = 0;
  }
  autopoll();
}
function show_my_score() { let me = Session.cur_players[Session.cur_user]; console.log('my', me.name, 'score is', me.score); }
function show_one_skype_message(dParent, o) {
  let d = mDiv(dParent, { rounding: 12, hpadding: 6, vpadding: 6, margin: 4, gap: 12 }); mFlex(d);
  let [sz] = [40];
  let dimg = get_skype_phone_icon(o.color);
  mAppend(d, dimg);
  let dmiddle = mDiv(d, { flex: 8, wmax: '75%' });
  let dnum = mDiv(dmiddle, { fz: 11, fg: 'grey' }, null, `<div>${o.num} ${format_date(o.date)}</div>`);
  let msg = get_skype_expanded_message(o.msg);
  S.boa_authorization_code = stringAfter(msg, 'Code ').substring(0, 6);
  let dmsg = mDiv(dmiddle, { bg: '#EEE', fz: 14, fg: 'black', rounding: 8, padding: 8 }, null, `<div>${msg}</div>`);
}
function show_options_popup(options) {
  let opresent = {};
  let di = { mode: 'gamemode', yes: true, no: false };
  let keys = get_keys(options);
  keys.sort();
  for (const k of get_keys(options).sort()) {
    let key = valf(di[k], k);
    let val = valf(di[options[k]], options[k]);
    opresent[key] = val;
  }
  let x = mYaml(mCreate('div'), opresent);
  let dpop = mPopup(x.innerHTML, dTable, { fz: 16, fg: 'white', top: 0, right: 0, border: 'white', padding: 10, bg: 'dimgray' }, 'dOptions');
  mInsert(dpop, mCreateFrom(`<div style="text-align:center;width:100%;font-family:Algerian;font-size:22px;">${Z.game}</div>`));
}
function show_player_button(caption, ui_item, handler) {
  let d = ui_item.container ?? iDiv(ui_item);
  let styles = { rounding: 6, bg: 'silver', fg: 'black', border: 0, maleft: 10 };
  let b = mButton(caption, handler, d, styles, 'enabled');
  return b;
}
function show_player_mode(dParent, g, uname) {
  let dplmode = valf(mBy('dPlayerMode'), mDiv(dParent, { fg: 'blue', fz: 12, padding: 4 }, 'dPlayerMode'));
  mCenterCenterFlex(dplmode);
  let plmode = lookupSet(g.fen, ['players', uname, 'playmode'], 'human');
  dplmode.innerHTML = plmode;
  if (g.fen.turn.includes(uname)) {
    dplmode.onclick = () => {
      let playermode = lookup(g.fen, ['players', uname, 'playmode']);
      playermode = lookupSetOverride(g.fen, ['players', uname, 'playmode'], playermode == 'human' ? 'bot' : 'human');
      dplmode.innerHTML = playermode;
      if (playermode == 'bot') ai_move();
    }
    mStyle(dplmode, { cursor: 'pointer' });
  }
}
function show_playerdatastate() {
  for (const pldata of Z.playerdata) {
    console.log('player', pldata.name, `status=${isEmpty(pldata.player_status) ? 'none' : pldata.player_status}`, pldata.state);
  }
}
function show_polling_signal() {
  if (DA.TEST0 != true) return;
  let d1 = mDiv(mBy('dAdmin'), { position: 'fixed', top: 10, left: 73 });
  let bg = Z.skip_presentation == true ? 'grey' : 'green';
  let d2 = mDiv(d1, { width: 20, height: 20, bg: bg, rounding: 10, display: 'inline-block' });
  mFadeRemove(d1, 1000);
}
function show_project_editor() {
  console.log('display the project editor!');
  mClear(dTable);
  let d = mCard(dTable, {}, 'coform'); mCenterFlex(d);
  mLinebreak(d, 40);
  let d1 = mText('New Composition', d, {}, 'fett');
  mPlace(d1, 'tl', 10);
  let d2 = mButtonX(d, onclick_close_project_editor);
  mPlace(d2, 'tr', 10);
  let i = 0;
  let d3 = mInput(d, {}, 'inTitle', 'Title', 'coinput', i++);
  let d4 = mInput(d, {}, 'inCreator', 'Creator', 'coinput', i++, isdef(U) ? U.name : '');
  let d5 = mInput(d, {}, 'inDescription', 'Short Description', 'coinput', i++);
  let b = mButton('next', onclick_add_question, d, {}, ['fett', 'no_outline', 'btn']);
}
function show_prompt(q, list, handler) {
  mClear(dTable);
  console.log('list', list)
  let dqcont = mDiv(dTable, G.stcont);
  mLinebreak(dTable);
  let dq = mDiv(dqcont, G.stq, `q_${G.i}`, q);
  let qitem = iAdd({ type: 'q', index: G.i, text: q }, { cont: dqcont, div: dq });
  let dacont = mDiv(dTable, G.stcont);
  mLinebreak(dTable);
  let tb = mToolbar(['back', 'clear', 'next'], handle_command, dTable, { align: 'center' }, { margin: 8, fz: 30, cursor: 'pointer' });
  G.buttons = tb.children;
  let aslist = [];
  list.map(x => {
    let da = ui_type_sym_text_line(dacont, x, dict_augment({ bg: x.color }, G.sta), handler);
    let item = iAdd(x, { div: da });
    aslist.push(item.id);
  });
  G.q = qitem.id;
  G.alist = aslist;
  G.selist = [];
  dTable.setAttribute('transition-style', "in:wipe:bottom-right");
  toolbar_check();
}
function show_question_editor() {
  mLinebreak(dTable, 4)
  let d = mCard(dTable, {}, 'coform'); mCenterFlex(d);
  let iform = arrChildren(dTable).length;
  console.log('this is question number', iform);
  let d1 = mText('New Composition', d, {}, 'fett'); mPlace(d1, 'tl', 10);
  let d2 = mButtonX(d, onclick_close_question_editor);
  mPlace(d2, 'tr', 10);
  mLinebreak(d, 40);
  let i = 0;
  let d3 = mInput(d, {}, 'inTitle' + iform, 'Title', 'coinput', i++);
  let d4 = mInput(d, {}, 'inCreator' + iform, 'Creator', 'coinput', i++, isdef(U) ? U.name : '');
  let d5 = mInput(d, {}, 'inDescription' + iform, 'Short Description', 'coinput', i++);
  let b = mButton('next', onclick_add_question, d, {}, ['fett', 'no_outline', 'btn']);
}
function show_rankings(dParent) {
  csv = make_csv_for_rankings();
  let ch = csv[csv.length - 1];
  if (ch == '%' || isNumber(ch)) {
    let d = mDiv(dParent, { align: 'center' }, null, `<h1>All Time Ranking</h1>`);
    let d1 = mDiv(d, { align: 'center', display: 'flex' });
    mCenterCenterFlex(d1);
    present_table_from_csv(csv, d1);
    mLinebreak(dParent);
  }
}
function show_recent_contributions() {
  let d = mCard(dTable);
  let contrib = Serverdata.contrib;
  if (isEmpty(contrib)) { d.innerHTML = 'no projects yet...'; return; }
}
function show_role() {
  let d = mBy('dAdminMiddle');
  clearElement(d);
  let hotseatplayer = Z.uname != Z.uplayer && Z.mode == 'hotseat' && Z.host == Z.uname;
  let styles, text;
  let boldstyle = { fg: 'red', weight: 'bold', fz: 20 };
  let normalstyle = { fg: 'black', weight: null, fz: null };
  let location = '';
  if (hotseatplayer) {
    styles = boldstyle;
    text = `your turn for ${Z.uplayer}`;
  } else if (Z.role == 'spectator') {
    styles = normalstyle;
    text = `(spectating)`;
  } else if (Z.role == 'active') {
    styles = boldstyle;
    text = `It's your turn!!!`;
  } else if (Z.role == 'waiting') {
    text = `waiting for players to complete their moves...`;
  } else {
    assertion(Z.role == 'inactive', 'role is not active or inactive or spectating ' + Z.role);
    styles = normalstyle;
    text = `(${Z.turn[0]}'s turn)`;
  }
  d.innerHTML = location + text;
  mStyle(d, styles);
}
function show_roles() {
  let d = mDiv(dTable, {}, 'dRoles', null, 'grid_roles');
  mButton('host', () => onclick_role('host'), d, {}, ['donebutton', 'enabled']);
  mButton('guest', () => onclick_role('guest'), d, {}, ['donebutton', 'enabled']);
}
function show_route(map, pts, color, callback) {
  let control = L.Routing.control({
    waypoints: points_to_waypoints(pts),
    lineOptions: { styles: [{ color: color, opacity: 1, weight: 3 }], },
    draggableWaypoints: false,
    createMarker: function () { return false; },
    show: false,
  }).addTo(map);
  control.on('routesfound', callback);
  return control;
}
function show_score_table(fen, game_title, dParent) {
  let d = mDiv(dParent, { margin: 'auto', wmin: 300, wmax: 500 });
  html = `<div style='text-align:center;margin-top:100px'>
  <h1>${game_title}</h1>
  <table id='customers'><tr><th>player</th><th>score</th></tr>
  `;
  let plparts = fen.split(',');
  for (const pl of plparts) {
    html += `<tr><td>${stringBefore(pl, ':')}</td><td>${stringAfter(pl, ':')}</td></tr>`
  }
  html += '</table></div>';
  d.innerHTML = html;
}
function show_settings(dParent) {
  let [options, fen, uplayer] = [Z.options, Z.fen, Z.uplayer];
  clearElement(dParent);
  mFlex(dParent);
  mStyle(dParent, { 'justify-content': 'end', gap: 12, paright: 10 })
  let playmode = get_playmode(uplayer);
  let game_mode = Z.mode;
  let st = { fz: 20, padding: 0, h: 40, box: true, matop: 2, rounding: '50%', cursor: 'pointer' };
  let dHistoryButton = miPic('scroll', dParent, st);
  dHistoryButton.onclick = show_history_popup;
  if (isdef(Config.games[Z.game].options.strategy)) {
    let dStrategy = miPic('chess pawn', dParent, st);
    dStrategy.onclick = show_strategy_popup;
  }
  let d = miPic('gear', dParent, st);
  options.playmode = playmode;
  d.onmouseenter = () => show_options_popup(options);
  d.onmouseleave = hide_options_popup;
}
function show_settings_orig(options) {
  clearElement('dTitleRight');
  let dParent = mDiv(mBy('dTitleRight'), { display: 'flex', fg: 'red' }, null, options.mode == 'hotseat' ? 'h' : '');
  let d = miPic('gear', dParent, { fz: 20, padding: 6, h: 40, box: true, matop: 2, rounding: '50%', cursor: 'pointer' });
  d.onmouseenter = () => show_options_popup(options);
  d.onmouseleave = hide_options_popup;
}
function show_shield(msg) {
  mBy('dShield').style.display = 'block';
  mBy('dShield').innerHTML = msg;
}
function show_sidebar(list, handler) {
  dSidebar = mBy('dSidebar'); mClear(dSidebar); mStyle(dSidebar, { w: 200, h: window.innerHeight - 68, overy: 'auto' });
  for (const k of list) {
    let d = mDiv(dSidebar, { cursor: 'pointer', wmin: 100 }, null, k, 'hop1')
    if (isdef(handler)) d.onclick = handler;
  }
}
function show_simple_ui(name) {
  U = firstCond(Serverdata.users, x => x.name == name);
  localStorage.setItem('uname', U.name);
  dTitle = mBy('dTitle');
  show_title();
  show_logged_in_user_simple();
  dTitle.animate([{ opacity: 0 }, { opacity: 1 },], { fill: 'both', duration: 1000, easing: 'ease-in' });
  dTable = mBy('dTable');
  hide('dUsers'); show('aLogout');
  hide('dTopMenu')
  let dStatus = mBy('dStatus'); mStyle(dStatus, { left: 10, width: '50%', right: null });
  onclick_tables();
  DA.testing = false; return;
  hide('dButtons');
  hide('dTest0');
  hide('dTopAdvanced');
  toggle_games_off();
  toggle_tables_off();
  toggle_users_on();
}
function show_simple_ui_orig() {
  DA.testing = false;
  hide('dButtons');
  hide('dTest0');
  hide('dTopAdvanced');
  toggle_games_off();
  toggle_tables_off();
  toggle_users_on();
}
function show_skype_contact(dParent) {
  let c = S.skype_contact;
  if (isdef(c)) {
    mClear(dParent);
    let d = mDiv(dParent, { h: 'calc( 100vh - 200px )', 'overflow-y': 'scroll' });
    let dfooter = mDiv(dParent, { h: 190, padding: 10 });
    let address = c.num;
    dfooter.innerHTML = `to: ${address} via Skype<br>`;
    let dform = mDiv(dfooter, { vmargin: 14 }); mFlex(dform);
    let denter = mInput(dform, { border: 'none', w: '85%', h: 40, bg: '#EEE', fg: '#000', fz: 14, padding: 10, hmargin: 14, rounding: 25 }, null, 'Type an SMS here');
    let b = skype_go_button();
    mAppend(dform, b);
    for (let i = 0; i < 20; i++) {
      show_one_skype_message(d, c)
    }
    d.scrollTop = d.scrollHeight;
  }
}
function show_special_message(msg, stay = false, ms = 3000, delay = 0, styles = {}, callback = null) {
  let dParent = mBy('dBandMessage');
  if (nundef(dParent)) dParent = mDiv(document.body, {}, 'dBandMessage');
  show(dParent);
  clearElement(dParent);
  addKeys({ position: 'fixed', top: 200, classname: 'slow_gradient_blink', vpadding: 10, align: 'center', position: 'absolute', fg: 'white', fz: 24, w: '100vw' }, styles);
  if (!isEmpty(styles.classname)) { mClass(dParent, styles.classname); }
  delete styles.classname;
  mStyle(dParent, styles);
  dParent.innerHTML = msg;
  if (delay > 0) TO.special = setTimeout(() => { mFadeRemove(dParent, ms, callback); }, delay);
  else mFadeRemove(dParent, ms, callback);
}
function show_stage() {
  if (isdef(Z.fen.progress)) {
    let d = mBy('dTitleLeft');
    let former = mBy('dProgress');
    if (isdef(former)) former.remove();
    let dprogress = mDiv(d, {}, 'dProgress', `<div>${Z.fen.progress}</div>`);
  }
}
function show_standard_title(dParent, title) { mText(title, dParent, { margin: 20, fz: 24 }); }
function show_status(s) {
  if (is_advanced_user()) {
    clear_status();
    if (!TESTING && !s.includes('reload')) show_fleeting_message(s, 'dTest', { fz: 14, position: 'absolute', top: 5, right: 10 }, 'dStatus');
  }
}
function show_status_orig(msg = '', stay) {
  if (isdef(stay)) showFleetingMessage(msg, mBy('dStatus'), { fg: 'red' }, 1000, 0, false);
  else showFleetingMessage(msg, mBy('dStatus'), { fg: 'black' });
}
function show_status_simple() { }
function show_strategy_popup() {
  let dpop = mPopup('', dTable, { fz: 16, fg: 'white', top: 0, right: 0, border: 'white', padding: 10, bg: 'dimgray' }, 'dOptions');
  mAppend(dpop, mCreateFrom(`<div style="text-align:center;width:100%;font-family:Algerian;font-size:22px;">${Z.game}</div>`));
  mDiv(dpop, { matop: 5, maleft: 10 }, null, `choose strategy:`);
  let vals = Config.games[Z.game].options.strategy.split(',');
  let key = 'strategy';
  let fs = mRadioGroup(dpop, { fg: 'white' }, `d_${key}`);
  for (const v of vals) { mRadio(v, isNumber(v) ? Number(v) : v, key, fs, { cursor: 'pointer' }, set_player_strategy, key, v == Z.strategy); }
  measure_fieldset(fs);
}
function show_table() {
  console.log('show_table S', S)
}
function show_table_for(g, dParent, uname) {
  let present = false;
  if (!UBEF || uname != UBEF) present = true;
  else if (!GBEF || g.name != GBEF) present = true;
  else {
    if (!EBEF) present = true;
    else {
      let keybef = get_keys(EBEF);
      let keys = get_keys(g.expected);
      console.log('keys', keybef, keys);
      if (!sameList(keybef, keys)) present = true;
      console.log('uname', uname)
      let ubef = EBEF[uname];
      let u = g.expected[uname];
      console.log('uname', ubef, u)
      console.log('STEP!!!', ubef.step, u.step)
      if (ubef.type != u.type || ubef.step != u.step) present = true;
    }
  }
  console.log('need to present:', present);
  U = firstCond(Serverdata.users, x => x.name == uname);
  UBEF = U.name;
  G = g;
  GBEF = G.name;
  EBEF = jsCopy(G.expected);
  if (!present) return;
  show_title();
  show_user();
  clearElement(dParent);
  ui_game_stats(dParent, G.fen.players);
  mLinebreak(dParent, 10)
  show_message(G.fen.message);
  show_instruction(isdef(G.expected[uname]) ? G.fen.instruction : 'NOT YOUR TURN');
  show_status(G.fen.status);
  window[`${G.gamename}_present`](G, dParent, uname);
  if (!isdef(G.expected[uname])) mShield(dParent);
  if (G.turn.includes(uname)) activate_ui();
}
function show_table_for_old(g, dParent, uname) {
  console.assert(isdef(g.fen), `game ${g.name} does not have a fen!`)
  console.assert(isDict(g.fen), "fen is NOT an object!!! " + g.name)
  console.assert(isdef(uname), `uname ${uname}`);
  Prevturn = isdef(Turn) ? jsCopy(Turn) : null;
  console.log('g.fen.turn', g.fen.turn)
  Turn = jsCopy(g.fen.turn);
  let sameuser = isdef(U) && U.name == uname;
  let samegame = isdef(G) && G.name == g.name;
  let sameturn = sameuser && samegame && isList(Prevturn) && isList(Turn) && sameList(Prevturn, Turn);
  G = g;
  U = firstCond(Serverdata.users, x => x.name == uname);
  let wasmyturn = isList(Prevturn) && Prevturn.includes(U.name);
  let ismyturn = isList(Turn) && Turn.includes(U.name);
  if (sameturn) return;
  show_title();
  show_user();
  clearElement(dParent);
  ui_game_stats(dParent, G.fen.players);
  mLinebreak(dParent, 10)
  show_message(G.fen.message);
  show_instruction(ismyturn ? G.fen.instruction : 'NOT YOUR TURN');
  show_status(G.fen.status);
  window[`${G.gamename}_present`](G, dParent, uname);
  if (!ismyturn) mShield(dParent);
  if (G.turn.includes(uname)) activate_ui();
}
function show_table_if_winner(otree) {
  table_shield_off();
  if (isdef(otree.winner)) {
    stop_game();
    ari_reveal_all_buildings(otree);
    if (!DA.test.running) turn_show_gameover(otree);
  }
}
function show_table_simple(tablename) {
  hide('dTables');
  show('dTable');
  stopgame();
  let table = firstCond(Serverdata.tables, x => x.friendly == tablename);
  ensure_polling();
  phpPost({ friendly: tablename }, 'table');
}
function show_tables(ms = 500) {
  clear_screen();
  let dParent = mBy('dTables');
  mClear(dParent);
  show_games();
  let tables = Serverdata.tables;
  if (isEmpty(tables)) { mText('no active game tables', dParent); return []; }
  tables.map(x => x.game_friendly = Config.games[x.game].friendly);
  mText(`<h2>game tables</h2>`, dParent, { maleft: 12 })
  let t = mDataTable(tables, dParent, null, ['friendly', 'game_friendly', 'players'], 'tables', false);
  mTableCommandify(t.rowitems, {
    0: (item, val) => hFunc(val, 'onclick_table', val, item.id),
  });
  let d = iDiv(t);
  for (const ri of t.rowitems) {
    let r = iDiv(ri);
    let h = hFunc('delete', 'delete_table', ri.o.friendly);
    c = mAppend(r, mCreate('td'));
    c.innerHTML = h;
  }
}
function show_tables_simple() {
  let dParent = mBy('dTables');
  show(dParent); hide('dTable');
  clearElement(dParent);
  let tables = Serverdata.tables;
  if (isEmpty(tables)) { mText('no active game tables', dParent); return []; }
  mText(`<h1>game tables</h1>`, dParent, { maleft: 12 })
  let t = mDataTable(tables, dParent, null, ['game', 'friendly', 'players'], 'tables');
  mTableCommandify(t.rowitems, {
    1: (item, val) => hFunc(val, 'onclick_game_in_gametable', val, item.id),
  });
}
function show_tagged() {
  if (isdef(DA.tags)) get_values(DA.tags).map(x => x.remove());
  let tpop = mPopup('', document.body)
  DA.tags = {};
  for (const id in Items) {
    let el = mBy(id);
    if (nundef(el)) {
      let item = Items[id];
      el = iDiv(item);
      if (nundef(el)) continue;
      if (nundef(item.live)) { item.live = { div: el }; el.id = id; delete Items[id].div; }
    }
    console.log('id', id)
    let r = getRect(el);
    let dtag = mDiv(tpop, { fz: 12, bg: 'black', fg: 'white', hpadding: 4, rounding: 12 }, null, id)
    mPos(dtag, r.l, r.t);
    DA.tags[id] = dtag;
  }
}
function show_title() {
  Z.func.state_info(mBy('dTitleLeft'));
  show_settings(mBy('dTitleRight'));
  mBy('dTablename').innerHTML = Z.friendly;
}
function show_title_left(s, styles, funnyLetters = false) {
  let d = mBy('dTitleLeft');
  d.innerHTML = `${funnyLetters ? mColorLetters(s) : s}`;
  if (isdef(styles)) mStyle(d, styles);
}
function show_title_right(s, styles, funnyLetters = false) {
  let d = mBy('dTitleRight');
  d.innerHTML = `${funnyLetters ? mColorLetters(s) : s}`;
  if (isdef(styles)) mStyle(d, styles);
}
function show_user() {
  if (isdef(U) && U.name != 'anonymous') {
    let uname = U.name;
    let sz = 36;
    let html = `
    <div username='${uname}' style='display:flex;align-items:center;gap:6px;height:100%'>
      <img src='../base/assets/images/${uname}.jpg' width='${sz}' height='${sz}' class='img_person' style='border:3px solid ${U.color};margin:0'>
      <span>${uname}</span>
    </div>`;
    show_title_left(html, { fg: U.color });
  }
  else show_home_logo();
}
function show_user_image(uname, dParent, sz = 300) {
  let d = mDiv(dParent, { margin: 'auto', w: sz });
  let html = `
  <div style='text-align:center;margin-top:50px'>
    <img src='../base/assets/images/${uname}.jpg' class="img_person" height=150 />
  </div>
  `;
  d.innerHTML = html;
  return d;
}
function show_user_intro_screen(is_show_ranking = false, is_start_poll = true) {
  show('dIntro'); clearElement('dIntro');
  intro_show_user_image(Session.cur_user);
  status_message(`hi, ${capitalize(Session.cur_user)}, a game is starting soon...`, { top: 330, classname: 'slow_gradient_blink' });
  if (is_show_ranking) {
    let t = Session.cur_table;
    let fen = t.status == 'past' ? t.fen : get_score_fen_from_cur_players();
    intro_create_score_table(fen);
  }
  if (is_start_poll) poll_for_table_started();
}
function show_user_version_0() {
  if (isdef(U) && U.name != 'anonymous') show_title_left(U.name, { fg: U.color });
  else show_home_logo();
}
function show_username() {
  let uname = U.name;
  let dpic = get_user_pic(uname, 30);
  let d = mBy('dAdminRight');
  mClear(d);
  mAppend(d, get_logout_button());
  mAppend(d, dpic);
  if (is_advanced_user()) { show('dAdvanced1'); } else { hide('dAdvanced'); hide('dAdvanced1'); }
  if (!TESTING && !DA.running) phpPost({ app: 'easy' }, 'tables');
}
function show_users(ms = 300) {
  let dParent = mBy('dUsers');
  mClear(dParent);
  for (const u of Serverdata.users) {
    if (['ally', 'bob', 'leo'].includes(u.name)) continue;
    let d = get_user_pic_and_name(u.name, dParent);
    d.onclick = () => onclick_user(u.name);
    mStyle(d, { cursor: 'pointer' });
  }
  mFall(dParent, ms);
}
function show_users_version_0() {
  let dParent = mBy('dAllTables');
  show(dParent);
  clearElement(dParent);
  let headers = ['id', 'name', 'motto', 'commands'];
  let t = mDataTable(Serverdata.users, dParent, rec => ({ fg: 'contrast', bg: rec.color }), headers, 'users');
  mTableCommandify(t.rowitems, {
    1: (item, val) => hFunc(val, 'onclick_user', val),
  });
  return t;
}
function show_view_buildings_button(plname) {
  if (Z.role == 'spectator' || isdef(mBy('dPlayerButtons'))) return;
  if (isEmpty(UI.players[plname].buildinglist)) return;
  let d1 = iDiv(UI.players[plname]); mStyle(d1, { position: 'relative' });
  let d2 = mDiv(d1, { position: 'absolute', top: 8, left: 50, height: 25 }, 'dPlayerButtons');
  show_player_button('view buildings', d2, onclick_view_buildings);
}
function show_waiting_for_ack_message() {
  let dInstruction = mBy('dSelections0');
  mClass(dInstruction, 'instruction');
  mCenterCenterFlex(dInstruction);
  mBy('dSelections0').innerHTML = 'waiting for next round to start...';
}
function show_waiting_message(msg) {
  let dInstruction = mBy('dSelections0');
  mClass(dInstruction, 'instruction');
  mCenterCenterFlex(dInstruction);
  mBy('dSelections0').innerHTML = msg;
}
function show_winners() {
  let winners = Z.fen.winners;
  let multiple_winners = winners.length > 1;
  let winners_html = winners.map(x => get_user_pic_html(x, 35)).join(' ');
  let msg = `
    <div style="display:flex;gap:10px;align-items:center">
      <div style="color:red;font-size:22px;font-weight:bold;">GAME OVER! the winner${multiple_winners ? 's are: ' : ' is '}</div>
      <div style="padding-top:5px;">${winners_html}</div>
    </div>
  `;
  show_message(msg, true);
  mShield(dTable);
  hide('bRestartMove');
  return Z.fen.winners;
}
function show_x_button(dParent) {
  let b = mButton('close', () => hide(dParent), dParent, { maleft: '95%' });
}
function show0(id) { mBy(id).style.display = "block"; }
function show100() {
  let table = mBy('table');
  clearElement(table);
  let picLabelStyles = getHarmoniousStylesXX(100, 100, 10, 'arial', 'random', 'random', true);
  let picStyles = getHarmoniousStylesXX(100, 100, 10, 'arial', 'random', 'random', false);
  ensureSymByType();
  mButton('download key set', downloadKeySet, table, { fz: 30 });
  mButton('next 100', () => show100(), table, { fz: 30 });
  mLinebreak(table);
  let keys = takeFromTo(IconSet, lastIndex, lastIndex + 100);
  lastIndex += 100;
  console.log('JAJAJAJAJ lastIndex', lastIndex);
  gridLabeled(keys, picLabelStyles);
}
function showActiveMessage(msg, handler, styles = {}, fade = false) {
  let defStyles = { fz: 22, rounding: 10, vpadding: 12, hpadding: 0, matop: 50 };
  styles = mergeOverride(defStyles, styles);
  if (nundef(styles.fg)) styles.fg = colorIdealText(Session.color);
  clearFleetingMessage();
  let d = fleetingMessage(msg, styles, fade);
  d.onclick = handler;
}
function showAllInnoCards(dParent) {
  Pictures = [];
  let allKeys = Object.keys(cinno);
  console.group(allKeys);
  let dims = calcRowsColsX(allKeys.length);
  let idx = 0;
  for (let i = 0; i < dims.rows; i++) {
    for (let j = 0; j < dims.cols; j++) {
      if (allKeys.length <= idx) break;
      let c = cardInnoz(allKeys[idx]); idx += 1;
      mAppend(dParent, c.div);
      c.row = i;
      c.col = j;
      Pictures.push(c);
    }
  }
}
function showAxes(ctx, axes) {
  var x0 = axes.x0, w = ctx.canvas.width;
  var y0 = axes.y0, h = ctx.canvas.height;
  var xmin = axes.doNegativeX ? 0 : x0;
  ctx.beginPath();
  ctx.strokeStyle = "rgb(128,128,128)";
  ctx.moveTo(xmin, y0); ctx.lineTo(w, y0);
  ctx.moveTo(x0, 0); ctx.lineTo(x0, h);
  ctx.stroke();
}
function showBadges(dParent, level, clickHandler) {
  clearElement(dParent); badges = [];
  for (let i = 1; i <= level; i++) {
    addBadge(dParent, i, clickHandler);
  }
}
function showBadgesX(dParent, level, clickHandler, maxLevel) {
  clearElement(dParent);
  badges = [];
  for (let i = 1; i <= maxLevel + 1; i++) {
    if (i > level) {
      let b = addBadge(dParent, i, clickHandler, false);
      b.live.div.style.opacity = .25;
      b.achieved = false;
    } else {
      let b = addBadge(dParent, i, clickHandler, true);
      b.achieved = true;
    }
  }
}
function showBoat(id) { let ms = UIS[id]; ms.show(); ms.o.weg = false; }
function showCard(card, { size = 90, area, hand, layout } = {}) {
  let d = document.getElementById(area);
  mStyle(card, { width: size * .66, height: size });
  if (nundef(layout)) card.style.setProperty('float', 'left');
  let dHand = isdef(hand) ? d.getElementById(hand)
    : d.childElementCount >= 1 ? d.lastChild
      : addDivPosTo(d, 12, 25, 'auto', size, 'px', null);
  dHand.appendChild(card);
}
function showCards(o, type) {
  let d2 = iDiv(o);
  if (nundef(type)) type = isdef(o.type) ? o.type : 'hand';
  let arr = type == 'deck' ? o.deck.cards() : o.cards;
  let cont = type == 'deck' ? stdDeckContainer(d2, arr.length) : startsWith(type, 'cards') ? stdCardsContainer(d2, arr.length) : stdHandContainer(d2, arr.length);
  let items = arr.map(x => Card52.getItem(x % 52));
  if (endsWith(type, 'Hidden') || type == 'deck') items.map(x => Card52.turnFaceDown(x, BG_CARD_BACK));
  items.map(x => mAppend(cont, iDiv(x)));
  return items;
}
function showCardSimple(card, area) {
  let hCard = getBounds(mById(area)).height - 30;
  showCard(card, { size: 80, area: area });
}
function showChatWindow() { let d = mBy('dChatWindow'); mStyle(d, { display: 'block' }); return d; }
function ShowChessMessage(s, ms) {
  console.log('message:', s);
  $("#GameStatus").text(s);
  if (isdef(ms)) setTimeout(() => $("#GameStatus").text(''), ms)
}
function showChildren(n) {
  console.log('children:')
  if (nundef(n.children)) {
    console.log('NO Children!!!', n)
  } else if (isList(n.children)) {
    n.children.map(x => console.log(x));
  } else {
    console.log(n.children);
  }
}
function showCollapsibleContent(ev) {
  let id = evToClosestId(ev);
  mBy('pageContent').scrollTo(0, 0);
  ev.cancelBubble = true;
  setCurrentPathIndex(firstNumber(id));
}
function showCollection(coll, idCollection) {
  if (coll.tbd == 'add' || coll.tbd == 'update') {
    _clearHand(idCollection, 'hand');
    let msCollection = UIS[idCollection];
    let collectionAreaName = getAreaName(idCollection);
    let els = coll.type == '_obj' ? coll.arr.map(x => x._obj) : coll.arr;
    if (coll.type == '_obj') {
      for (const oid of els) {
        let mobj = getVisual(oid);
        if (nundef(mobj)) {
          mobj = makeCard(oid, G.table[oid], idCollection);
        }
        if (!_isInHand(oid, idCollection)) {
          addCardToCollectionArea(oid, idCollection);
        }
      }
      repositionCards(msCollection);
    }
  }
}
function showCollections(pool, oid, keys, cardFunc, areaName) {
  let propName = keys.shift();
  let collDict = getCollections(pool, oid, propName);
  if (nundef(collDict)) return;
  let msArea = getMainArea(areaName);
  if (!msArea) {
    return;
  }
  for (const key in collDict) {
    let coll = collDict[key];
    let idCollection = getCollectionArea(key, msArea);
    showCollection(coll, idCollection);
  }
}
function showCorrectLabelSwapping() {
  for (const p of Pictures) {
    for (const l of p.letters) {
      let sw = l.swapInfo;
      if (isdef(sw)) {
        iDiv(l).innerHTML = sw.correct.l;
        if (l.i == p.iLetter) animate(iDiv(l), 'komisch', 2300);
      }
    }
  }
  DELAY = 3000;
  return 3000;
}
function showCorrectPictureLabels(sayit = true) { return 1000; }
function showCorrectUis() {
  let anim = 'onPulse5';
  for (const ui of Selected.correctUis) { mClass(ui, anim); }
  return Selected.correctionDelay;
}
function showCorrectWord(sayit = true) {
  let anim = G.spokenFeedback ? 'onPulse' : 'onPulse1';
  let div = mBy(Goal.id);
  mClass(div, anim);
  if (!sayit || !G.spokenFeedback) G.spokenFeedback ? 3000 : 300;
  let correctionPhrase = isdef(Goal.correctionPhrase) ? Goal.correctionPhrase : Goal.label;
  sayRandomVoice(correctionPhrase);
  return G.spokenFeedback ? 3000 : 300;
}
function showCorrectWordInTitle(sayit = true) {
  let anim = G.spokenFeedback ? 'onPulse' : 'onPulse1';
  clearElement(dInstruction);
  let d1 = mText(`<b>${Goal.label}</b>`, dInstruction, { fz: 36, display: 'inline-block' });
  mClass(dInstruction, anim);
  showFleetingMessage(Goal.label);
  if (!sayit || !G.spokenFeedback) G.spokenFeedback ? 3000 : 300;
  let correctionPhrase = isdef(Goal.correctionPhrase) ? Goal.correctionPhrase : Goal.label;
  sayRandomVoice(correctionPhrase);
  return G.spokenFeedback ? 3000 : 300;
}
function showCorrectWords(sayit = true) {
  if (nundef(TOList)) TOList = {};
  TOList.correctWords = [];
  let anim = 'onPulse2';
  let to = 0;
  let speaking = sayit && G.spokenFeedback;
  let ms = speaking ? 2000 : 1000;
  for (const goal of Goal.pics) {
    TOList.correctWords.push(setTimeout(() => {
      let div = mBy(goal.id);
      mClass(div, anim);
      if (speaking) sayRandomVoice((G.language == 'E' ? 'the ' : ' ') + goal.correctionPhrase);
    }, to));
    to += ms;
  }
  if (!sayit || !G.spokenFeedback) return to;
  return to + ms;
}
function showCurrent(id) { if (isdef(dCurrent) && dCurrent.id == id) { return 0; } else { dCurrent = mBy(id); mStyle(dCurrent, { overflow: 'hidden' }); show(id); return DELAY_APPEAR } };
function showDeck(keys, dParent, splay, w, h) {
  let d = mDiv(dParent);
  mStyleX(d, { display: 'block', position: 'relative', bg: 'green', padding: 25 });
  let gap = 10;
  let ovPercent = 20;
  let overlap = w * ovPercent / 100;
  let x = y = gap;
  for (let i = 0; i < keys.length; i++) {
    let k = keys[i];
    let c = zInno(k, d);
    mAppend(d, c.div);
    mStyleX(c.div, { position: 'absolute', left: x, top: y });
    c.row = 0;
    c.col = i;
    x += overlap;
    Pictures.push(c);
  }
  d.style.width = (x - overlap + w) + 'px';
  console.log(Pictures[0])
  console.log(Pictures[0].div)
  d.style.height = firstNumber(Pictures[0].div.style.height) + 'px';
}
function showElemProps(e) { console.log(e.id + '(' + getTypeOf(e) + ')' + ': x', e.offsetLeft, 'y', e.offsetTop, 'w', e.offsetWidth, 'h', e.offsetHeight, 'bg', e.style.backgroundColor, 'fg', e.style.color); }
function showElems(idlist) {
  for (const fid of idlist) {
    EID[fid].ms.show();
  }
}
function showElemSize(e) { console.log(e.id + ': x', e.offsetLeft, 'y', e.offsetTop, 'w', e.offsetWidth, 'h', e.offsetHeight); }
function showEquation(words, dParent, idForContainerDiv, sep = null, styleContainer = {}, styleWord = {}, styleLetter = {}, styleSep = {}, colorWhiteSpaceChars = true, preserveColorsBetweenWhiteSpace = true) {
  if (isEmpty(styleWord)) {
    let sz = 80;
    let fg = helleFarbe(G.color);
    styleWord = {
      margin: 8, padding: 8, rounding: '50%', w: 'auto', h: sz, display: 'flex', fg: fg, bg: 'transparent',
      'align-items': 'center', border: 'transparent', outline: 'none', fz: sz, 'justify-content': 'center',
    };
  }
  let dContainer = mDiv(dParent);
  if (!isEmpty(styleContainer)) mStyleX(dContainer, styleContainer); else mClass(dContainer, 'flexWrap');
  dContainer.id = idForContainerDiv;
  let inputGroups = [];
  let charInputs = [];
  let iWord = 0;
  let idx = 0;
  let numWords = words.length;
  for (const w of words) {
    let dGroup = mDiv(dContainer);
    mStyleX(dGroup, styleWord);
    dGroup.id = idForContainerDiv + '_' + iWord;
    let g = { dParent: dContainer, word: w, iWord: iWord, div: dGroup, oStyle: styleWord, ofg: dGroup.style.color, obg: dGroup.style.backgroundColor };
    inputGroups.push(g);
    let inputs = [];
    let iLetter = 0;
    let wString = w.toString();
    for (const l of wString) {
      let dLetter = mDiv(dGroup);
      if (!isEmpty(styleLetter)) mStyleX(dLetter, styleLetter);
      dLetter.innerHTML = l;
      let inp = { group: g, div: dLetter, letter: l, iLetter: iLetter, index: idx, oStyle: styleLetter, ofg: dLetter.style.color, obg: dLetter.style.backgroundColor };
      charInputs.push(inp);
      inputs.push(inp);
      iLetter += 1; idx += 1;
    }
    g.charInputs = inputs;
    if (iWord < words.length - 1 && isdef(sep)) {
      let dSep = mDiv(dContainer);
      dSep.innerHTML = sep;
      if (isdef(styleSep)) mStyleX(dSep, styleSep);
    }
    iWord += 1;
  }
  return [inputGroups, charInputs];
}
function showEventList() { document.getElementById('events').style.display = null; }
function ShowFenPosition() {
  $("#currentFenSpan").text(BoardToFen());
  let pl = SideChar[brd_side] == 'b' ? 'BLACK (AI)' : 'WHITE (you)';
  mStyle(dTitle, { align: 'left' });
  dTitle.innerHTML = `<div style='margin-left:78px;width:483px;text-align:center;'>Turn: ${pl}</div>`;
}
function showFleetingMessage(msg, dParent, styles = {}, ms = 3000, msDelay = 0, fade = true) {
  clearFleetingMessage();
  dFleetingMessage = mDiv(dParent);
  if (msDelay) {
    TOFleetingMessage = setTimeout(() => fleetingMessage(msg, dFleetingMessage, styles, ms, fade), msDelay);
  } else {
    TOFleetingMessage = setTimeout(() => fleetingMessage(msg, dFleetingMessage, styles, ms, fade), 10);
  }
}
function showFullObject(o, indent = 0, onlySimple = false) {
  for (const k in o) {
    if (isSimple(o[k])) console.log(' '.repeat(indent), k, o[k]);
    else if (!onlySimple) console.log(' '.repeat(indent), k, anyString3(o[k]));
    else {
      console.log(' '.repeat(indent), k);
      showFullObject(o[k], indent + 2);
    }
  }
}
function showGame() { document.getElementById('R_d_root').style.display = null; }
function showGameConfig() { document.getElementById('gameConfig').style.display = null; }
function showGameTitle() { dGameTitle.innerHTML = G.friendly; }
function showGlobals() {
  getGlobals();
  console.log('Globals', Globals)
  dTable = mBy('dTable');
  let d = mDiv(dTable);
  for (const k in Globals) {
    let d1 = mDiv(d, {}, null, k);
    let d2 = mDiv(d, {}, null, Globals[k].map(x => x.key).join(',')); mFlexWrap(d2);
  }
}
function showGrid(cards, dParent) { }
function showHand52(cards, dParent, splayed = 'left', w, h) { }
function showHands(oid, propList, cardFunc, areaName) { }
function showHiddenThumbsUpDown(sz = 100) {
  let d = mDiv(dTable, { hmin: sz * 1.5 });
  mCenterFlex(d);
  let keys = ['thumbs up', 'thumbs down'];
  let options = getOptionsMinimalistic(d, null, 300, 100, { bg: 'transparent', display: 'inline' }, {}, G);
  let items = Pictures = genItemsFromKeys(keys, options);
  for (const item of items) {
    let d1 = makeItemDiv(item, options);
    mAppend(d, d1);
    mStyleX(d1.firstChild, { fz: sz, mabottom: 12 });
    mStyleX(d1, { opacity: 0 });
  }
}
function showInnoCards(keys, dParent, wCard = 200) {
  Pictures = [];
  let dims = calcRowsColsX(keys.length);
  let idx = 0;
  for (let i = 0; i < dims.rows; i++) {
    for (let j = 0; j < dims.cols; j++) {
      if (keys.length <= idx) break;
      let c = cardInnoz(keys[idx], wCard); idx += 1;
      mAppend(dParent, c.div);
      c.row = i;
      c.col = j;
      Pictures.push(c);
    }
  }
}
function showInstruction(text, cmd, dParent, isSpoken, spoken, fz, voice) {
  clearElement(dParent);
  let d = mDiv(dParent);
  mStyleX(d, { margin: 15 })
  mClass(d, 'flexWrap');
  let msg = cmd + " " + `<b>${text.toUpperCase()}</b>`;
  if (nundef(fz)) fz = 36;
  let d1 = mText(msg, d, { fz: fz, display: 'inline-block' });
  if (isSpoken) {
    let sym = symbolDict.speaker;
    let d2 = mText(sym.text, d, {
      fz: fz + 2, weight: 900, display: 'inline-block',
      family: sym.family, 'padding-left': 14
    });
  }
  dFeedback = dInstruction = d;
  spoken = isSpoken ? isdef(spoken) ? spoken : cmd + " " + text : null;
  dInstruction.addEventListener('click', () => aniInstruction(spoken));
  if (!isSpoken) return;
  sayRandomVoice(isdef(spoken) ? spoken : (cmd + " " + text), null, "david");
}
function showInstructionX(written, dParent, spoken, { fz, voice } = {}) {
  clearElement(dParent);
  let d = mDiv(dParent);
  mStyleX(d, { margin: 15 })
  mClass(d, 'flexWrap');
  if (nundef(fz)) fz = 36;
  let d1 = mText(written, d, { fz: fz, display: 'inline-block' });
  let sym = symbolDict.speaker;
  let d2 = mText(sym.text, d, {
    fz: fz + 2, weight: 900, display: 'inline-block',
    family: sym.family, 'padding-left': 14
  });
  dFeedback = dInstruction = d;
  dInstruction.addEventListener('click', () => aniInstruction(spoken));
  if (isdef(spoken)) sayRandomVoice(spoken, spoken, voice);
}
function showJoinConfig() { show('joinConfig'); }
function showLabelPercentHintAfter(percent, msecs) {
  let len = Goal.label.length;
  let sublen = Math.floor(len * percent / 100); let restlen = len - sublen;
  let hintWord = Goal.label.substring(0, sublen);
  for (let i = 0; i < restlen; i++) hintWord += ' _';
  hintWord = hintWord.toUpperCase();
  showFleetingMessage(hintWord, msecs, { fz: 32 });
}
function showLbls(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items = getLbls(onClickPictureHandler, ifs, options, keys, labels);
  presentItems(items, dTable, 1);
  return items;
}
function showLevel() {
  dLevel.innerHTML = 'level: ' + (G.level + 1) + '/' + (G.maxLevel + 1);
}
function showLevelComplete() {
  if (!skipAnimations) {
    soundLevelComplete();
    mClass(mBy('dLevelComplete'), 'aniFadeInOut');
    show('dLevelComplete');
    setTimeout(levelStep10, 1500);
  } else {
    addBadge(dLeiste, currentLevel);
    setBackgroundColor();
    proceedIfNotStepByStep();
  }
}
function showListOfLists(arr) { let s = ''; arr.map(x => { s += '[' + x.toString() + '] ' }); return s; }
function showLoader() { mBy('dLoader').style.display = "unset"; }
function showLobby() {
  document.getElementById('a_d_lobby').style.display = null;
  if (!USE_SOCKETIO) { document.getElementById('a_d_chat').style.display = 'none'; }
}
function showLog(pl) { let d = LOG[pl]; if (d) show(d); }
function showLogin() { document.getElementById('a_d_login').style.display = null; }
function showMenu(desc) {
  let d = mBy('div' + desc);
  if (!isVisible(d)) {
    let b = mBy('b' + desc);
    show(d);
    d.style.display = 'inline';
    b.innerHTML = '-' + desc[0];
  }
}
function showMouse() {
  var x = dTable.getElementsByTagName("DIV");
  if (nundef(x) || nundef(x[0]) || nundef(x[0].prevCursor)) { console.log('did NOT hide mouse!'); return; }
  for (const el of x) {
    mRemoveClass(el, 'noCursor');
  }
  for (const el of x) { el.style.cursor = el.prevCursor; }
  for (const p of Pictures) {
    mRemoveClass(iDiv(p), 'noCursor');
    mClass(iDiv(p), 'frameOnHover'); iDiv(p).style.cursor = 'pointer';
    for (const ch of iDiv(p).children) ch.style.cursor = 'pointer';
  }
}
function showMouseAvatar(username) { show(getAvatar(username)); }
function showNodeInfo(n, title, lst, lstOmit) {
  if (nundef(title)) title = 'node';
  let args = [];
  if (isList(lst)) {
    for (const prop of lst) {
      if (isdef(n[prop])) args.push(prop + ': ' + anyString3(n[prop]));
    }
  } else {
    for (const prop in n) {
      if (lstOmit.includes(prop)) continue;
      args.push(prop + ': ' + anyString3(n[prop]));
    }
  }
  let s = title + '\n' + args.join('\n');
  console.log(s);
}
function showNumberSequence(words, dParent, idForContainerDiv = 'seqContainer', sep = null, styleContainer = {}, styleWord = {}, styleLetter = {}, styleSep = {}, colorWhiteSpaceChars = true, preserveColorsBetweenWhiteSpace = true) {
  if (isEmpty(styleWord)) {
    let sz = 80;
    styleWord = {
      margin: 10, padding: 4, rounding: '50%', w: sz, h: sz, display: 'flex', fg: 'lime', bg: 'yellow', 'align-items': 'center',
      border: 'transparent', outline: 'none', fz: sz - 25, 'justify-content': 'center',
    };
  }
  let dContainer = mDiv(dParent);
  if (!isEmpty(styleContainer)) mStyleX(dContainer, styleContainer); else mClass(dContainer, 'flexWrap');
  dContainer.id = idForContainerDiv;
  let inputGroups = [];
  let charInputs = [];
  let iWord = 0;
  let idx = 0;
  let numWords = words.length;
  let wheel = getHueWheel(G.color, 40, numWords <= 4 ? 60 : numWords <= 10 ? 30 : 15, 0);
  wheel = wheel.map(x => colorHSLBuild(x, 100, 50));
  wheel = shuffle(wheel);
  let wheel1 = colorPalShadeX(colorFrom(wheel[0]), numWords);
  wheel = jsCopy(wheel1);
  if (G.op == 'plus') wheel.reverse();
  for (const w of words) {
    let dGroup = mDiv(dContainer);
    mStyleX(dGroup, styleWord);
    let bg = wheel[iWord]; 
    dGroup.style.backgroundColor = bg;
    dGroup.style.color = colorIdealText(bg);
    dGroup.id = idForContainerDiv + '_' + iWord;
    let g = { dParent: dContainer, word: w, iWord: iWord, div: dGroup, oStyle: styleWord, ofg: dGroup.style.color, obg: dGroup.style.backgroundColor };
    inputGroups.push(g);
    let inputs = [];
    let iLetter = 0;
    let wString = w.toString();
    for (const l of wString) {
      let dLetter = mDiv(dGroup);
      if (!isEmpty(styleLetter)) mStyleX(dLetter, styleLetter);
      dLetter.innerHTML = l;
      let inp = { group: g, div: dLetter, letter: l, iLetter: iLetter, index: idx, oStyle: styleLetter, ofg: dLetter.style.color, obg: dLetter.style.backgroundColor };
      charInputs.push(inp);
      inputs.push(inp);
      iLetter += 1; idx += 1;
    }
    g.charInputs = inputs;
    if (iWord < words.length - 1 && isdef(sep)) {
      let dSep = mDiv(dContainer);
      dSep.innerHTML = sep;
      if (isdef(styleSep)) mStyleX(dSep, styleSep);
    }
    iWord += 1;
  }
  return [inputGroups, charInputs];
  return { words: inputGroups, letters: charInputs };
  return [wi.words, wi.letters];
}
function showObject(o, indent = 0, simple = true, lstShow = null, lstOmit = null) {
  let s = extendedObjectString(o, indent, simple, lstShow, lstOmit);
  console.log(s);
}
function showPackages(data, domid = 'OLDCODE') {
  let d = mBy(domid);
  if (d) { d.innerHTML = '<pre>' + jsonToYaml(data) + '</pre>'; }
}
function showPicLabel(key, label, area, color = 'blue', x = 0, y = 0, sz = 50, gap = 4) {
  console.log(key, label, area, color, x, y, sz, gap)
  let dOuter = mCreate('div');
  let wOuter = sz;
  let wInner = sz - 2 * gap;
  mStyle(dOuter, {
    color: 'black',
    width: wOuter,
    left: x,
    top: y,
    padding: 0,
    position: 'absolute',
    'text-align': 'center',
    'background-color': randomColor(),
    display: 'inline'
  });
  let dPic = addPictoDiv(key, dOuter, color, wInner);
  mStyle(dPic, { margin: gap, 'margin-bottom': 1 })
  let dText = mAppendText(dOuter, label);
  dText.classList.add('truncate');
  mStyle(dText, { 'margin-bottom': gap, width: wOuter });
  area = asElem(area);
  mPosRel(area);
  mAppend(area, dOuter);
}
function showPicLabelCentered(key, label, area, color = 'blue', sz = 50, gap = 4) {
  let d = showPicLabel(key, label, area, color, 0, 0, sz, gap);
}
function showPics(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items = getPics(onClickPictureHandler, ifs, options, keys, labels);
  console.log(items);
  presentItems(items, dTable, options.rows);
  return items;
}
function showPicsS(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items = getPicsS(onClickPictureHandler, ifs, options, keys, labels);
  presentItems(items, dTable, options.rows);
  return items;
}
function showPictoDiv(key, area, color = 'blue', x = 0, y = 0, w = 50, h = 0) {
  let d = pictoDiv(key, color, w, h ? h : w);
  mAppend(area, d);
  mPos(d, x, y);
  return d;
}
function showPictoDivCentered(key, area, color = 'blue', sz = 50) {
  let d = pictoDiv(key, color, sz, sz);
  mAppend(area, d);
  posCIC(d);
  return d;
}
function showPictureGrid(n = 9, dParent, ifs = {}, options = {}) {
  let items = detectItems(n);
  console.log('item', items[0]);
  for (let i = 0; i < items.length; i++) {
    let info = items[i].info;
    let d = mDiv(dParent, { w: 200, h: 200, bg: 'red' });
    d.innerHTML = 'hallo';
    let dpic = mDiv(d, { fz: 100, family: 'emoNoto' });
    dpic.innerHTML = info.text;
  }
}
function showPictureHints(items, dParentProp) {
  for (const item of items) {
    let d1 = item[dParentProp];
    mRemoveChildrenFromIndex(d1, 1);
    let dHint = item.dHint = miPic(item, d1);
  }
}
function showPictures(dParent, handler, ifs = {}, options = {}, keys, labels) {
  options = getOptionsMinimalistic(dParent, handler, options.w, options.h, ifs, options, G);
  if (nundef(keys)) keys = choose(G.keys, G.numPics);
  let items = genItemsFromKeys(keys, options);
  if (isdef(labels)) {
    options.showLabels = true;
    for (let i = 0; i < items.length; i++) item[i].label = labels[i % labels.length];
  }
  let dArea = mDiv(dParent);
  let rect = myPresent(dArea, items, options);
  return items;
}
function showPlayer(i) {
  let id;
  id = getidNum(i); show(id);
  id = getidSpan(i); show(id);
  id = getidType(i); show(id);
}
function showPlayerHand(oid, propName, cardFunc, areaName) { showCollections(collections, oid, [propName], cardFunc, areaName); }
function showPlayerHand_dep(plid, propName, areaName) {
  let oPlayer = G.playersAugmented[plid];
  let oCards = oPlayer[propName];
  if (isSet(oCards)) oCards = oCards._set;
  if (!isListOfLiterals(oCards)) { alert('wrong format of cards property: ' + propName); }
  let oids = oCards.map(x => x._obj);
  let idHand = getIdArea(areaName);
  if (_handChanged(oids, idHand)) {
    _clearHand(idHand);
    _showHand(oids, idHand);
  }
}
function showPlayerHandNew(name, cardArr, areaName) {
  if (isSet(cardArr)) cardArr = cardArr._set;
  if (!isListOfLiterals(cardArr)) { alert('wrong format of cards property: ' + propName); }
  let oids = cardArr.map(x => isdef(x._obj) ? x._obj : x);
  let idHand = getIdArea(areaName);
  if (_handChanged(oids, idHand)) {
    _clearHand(idHand, 'hand');
    _showHand(oids, idHand, 'hand');
  }
}
function showPlayerStats(plid, propName, areaName) {
  let oPlayer = G.playersAugmented[plid];
  let oStatsVal = oPlayer[propName];
  let msStats = UIS[getIdArea(areaName)];
}
function showProps(ms) { console.log(ms.id + '(' + getTypeOf(ms) + ')' + ': x', ms.x, 'y', ms.y, 'w', ms.w, 'h', ms.h, 'bg', ms.bg, 'fg', ms.fg); }
function showRect(s, o) {
  let r = o.rect;
  console.log('\n', s, 'w', Math.round(r.w), '=', Math.round(r.l), Math.round(r.r), 'h', Math.round(r.h), '=', Math.round(r.t), Math.round(r.b));
}
function showRectReal(s, o) {
  let r = o.rect;
  console.log('\n', s, 'w', r.w, '=', r.l, r.r, 'h', r.h, '=', r.t, r.b);
}
function showSayHint(i) {
  let [spoken, written] = G.hintFunc(i);
  if (spoken) sayRandomVoice(spoken);
  if (written) showFleetingMessage(written, 0, { fz: 40 });
}
function showScore() {
  if (G.controllerType == 'solitaire') {
    if (Score.gameChange) showBadgesX(dLeiste, G.level, onClickBadgeX, G.maxLevel);
    let scoreString = 'question: ' + (Score.nTotal + 1) + '/' + G.samplesPerGame;
    if (Score.levelChange) {
      dScore.innerHTML = scoreString;
      setBadgeLevel(G.level);
    } else {
      setTimeout(() => {
        dScore.innerHTML = scoreString;
        setBadgeLevel(G.level);
      }, 300);
    }
  } else {
    setTimeout(() => { dScore.innerHTML = 'score ' + GC.human.score + ':' + GC.ai.score; }, 300);
  }
}
function showScore_dep(showScoreString = true) {
  if (G.controllerType == 'solitaire') {
    if (Score.gameChange) showBadgesX(dLeiste, G.level, onClickBadgeX, G.maxlevel);
    if (showScoreString) scoreString = 'question: ' + (Score.nTotal + 1) + '/' + G.samplesPerGame;
    if (Score.levelChange) {
      if (showScoreString) dScore.innerHTML = scoreString;
      setBadgeLevel(G.level);
    } else {
      setTimeout(() => {
        if (showScoreString) dScore.innerHTML = scoreString;
        setBadgeLevel(G.level);
      }, 300);
    }
  } else {
    setTimeout(() => { if (showScoreString) dScore.innerHTML = 'score ' + GC.human.score + ':' + GC.ai.score; }, 300);
  }
}
function showServerData(data, domid = 'SERVERDATA') {
  let d = mBy(domid);
  if (d && SHOW_SERVERDATA) { d.innerHTML = '<pre>' + jsonToYaml(data) + '</pre>'; }
}
function showSetSizes(nLast, R) {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    if (nundef(n.size)) setSP(n);
  }
}
function showShield() { mBy('dShield').style.display = 'block'; }
function showSignatureContent(ev) {
  let id = evToClosestId(ev);
  ev.cancelBubble = true;
  let ifunc = firstNumber(id);
  let path = stringAfter(id, '@');
  let pathEntry = DOC_vault[path];
  let funcName = pathEntry.funcIndex[ifunc];
  let funcEntry = pathEntry.funcDict[funcName];
  let divPath = document.getElementById(pathEntry.idPathContainer);
  if (!isVisible(divPath)) setCurrentPath(pathEntry.filename);
  let funcDiv = mBy(funcEntry.idDiv);
  funcDiv.scrollIntoView(true);
}
function showSingle52(dParent, rank, suit, w, h) {
  let c = card52(rank, suit, w, h);
  mAppend(dParent, c.div);
  return c;
}
function showSize(ms) { console.log(ms.id + ': x', ms.x, 'y', ms.y, 'w', ms.w, 'h', ms.h); }
function showSizes(nLast, R) {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    if (isdef(n.size) && isdef(n.sizeNeeded)) {
      console.log(n.uid, 'size', n.size.w, n.size.h, 'measured', n.sizeMeasured.w, n.sizeMeasured.h, 'needed', n.sizeNeeded.w, n.sizeNeeded.h,);
    } else {
      setSP(n);
      console.log(n.uid, 'size', n.size.w, n.size.h, 'pos', n.pos.x, n.pos.y);
    }
  }
}
function showSpoken() { }
function showState() {
  console.log('______________', G.friendly);
  console.log(T.players)
}
function showStats() {
  if (nundef(Score)) initScore();
  showGameTitle();
  showLevel();
  showScore();
  Score.levelChange = false;
  Score.gameChange = false;
}
function showString(x, proplist, include = true) {
  console.log(anyString3(x, 0, proplist, include));
}
function showsub(n) {
  console.log('sub:')
  if (nundef(n.sub)) {
    console.log('NO sub!!!', n)
  } else if (isList(n.sub)) {
    n.sub.map(x => console.log(x));
  } else {
    console.log(n.sub);
  }
}
function showSvg(elem) {
  elem.setAttribute('style', 'visibility:visible');
}
function showTextHints(items, dParentProp, textProp, removeFirst = true) {
  for (const item of items) {
    let d1 = item[dParentProp];
    let hint = item[textProp];
    let dHint = item.dHint = mText(hint, d1);
  }
}
function showTree(o, childrenKeys = ['sub', 'elm'], plus, minus) {
  recShowTree(o, 0, childrenKeys, plus, minus);
}
function showTrick() {
  let dZone = Zones.table.dData;
  let d = mDiv(dZone);
  mStyleX(d, { display: 'flex', position: 'relative' });
  let zIndex = 1;
  for (let i = 0; i < T.trick.length; i++) {
    let c = T.trick[i];
    let direction = i == 0 ? { x: 0, y: -1 } : { x: 0, y: 1 };
    let displ = 10;
    let offset = { x: -35 + direction.x * displ, y: direction.y * displ };
    let d1 = c.div;
    mAppend(d, d1);
    mStyleX(d1, { position: 'absolute', left: offset.x, top: offset.y, z: zIndex });
    zIndex += 1;
  }
}
function showTT(ev) {
  if (TTMS) {
    $(TTMS.elem).off('mouseover');
    console.log('hallo')
    let d = document.getElementById('tooltip');
    clearElement(d);
    let t = tableElem(TTMS.o);
    d.appendChild(t);
    $('div#tooltip').css({
      display: 'inline-block',
      top: ev.pageY,
      left: ev.pageX,
    });
    TTMS = null;
  }
}
function showUsernameOnScreen(isEditable = true) {
  let uiName = 'spUser';
  let dUser = mBy(uiName);
  if (isdef(dUser)) return;
  dUser = isEditable ? editableUsernameUi(dLineTopLeft) : mText(Session.cur_user, dLineTopLeft);
  dUser.id = uiName;
}
function showWritten(cmd, vocab, dParent, styles) { }
function shuffle(arr) { if (isEmpty(arr)) return []; else return fisherYates(arr); }
function shuffle_children(d) {
  let arr = Array.from(d.children);
  shuffle(arr);
  for (const ch of arr) { mAppend(d, ch); }
}
function shuffleChildren(dParent) { shuffle_children(dParent); }
function shuffletest(list) {
  for (let i = 0; i < 100; i++) {
    shuffle(list);
    console.log('shuffle: ' + jsCopy(list));
  }
}
function sidebar_transition_off() {
  let d = mBy('left_panel');
  mClass(d, 'notransition');
}
function sidebar_transition_on() {
  let d = mBy('left_panel');
  mClass(d, 'alltransition');
}
function sieveLocOids(R) {
  if (isEmpty(R.locOids)) return;
  calcCycles(R);
  for (const k in R.partitions) {
    let cycle = R.partitions[k];
    let max_cycles = cycle.isCycle ? DEFS.cycleLengthAllowed : 1;
    processLocOids(cycle.oids, max_cycles, cycle.isCycle, R);
  }
}
function simple_gaussian(canvas) {
  var mean = 100;
  var b = 25;
  var stdev = 10;
  let variance = stdev * stdev;
  var cv = canvas.cv;
  var cx = canvas.cx;
  cx.strokeStyle = 'silver';
  let width_of_rect = cv.width / (4 * b); let w = width_of_rect;
  for (var j = 0; j < 2 * b; j++) {
    let x = j - b;
    var y = mean / Math.E ** (((j - b) ** 2) / (2 * variance));
    console.log('x', x, 'y', y)
    cx.rect(j * w + 125, cv.height - y, w, y);
    cx.stroke();
  }
}
function simpleColors(c = 'powderblue') {
  let pal = getPalette(c);
  S.settings.palette = pal;
  ROOT.children.map(x => UIS[x].setBg(pal[2], true));
  setCSSVariable('--bgBody', pal[5]);
  UIS['a_d_header'].setBg(pal[7]);
  UIS['a_d_action_header'].setBg(pal[3]);
  UIS['a_d_history_header'].setBg(pal[3]);
  UIS['a_d_game'].setBg(pal[1]);
  let c1 = pal[1];
  setCSSVariable('--bgTabActive', c1);
  setCSSVariable('--bgTabContent', c1);
  UIS['a_d_testing'].setBg(pal[2]);
  UIS['a_d_testing'].children.map(x => { UIS[x].setBg(c1); UIS[x].setFg('silver'); });
  setCSSVariable('--bgButton', pal[0]);
  setCSSVariable('--fgButton', 'white');
  setCSSVariable('--bgButtonHover', pal[3]);
  setCSSVariable('--bgButtonActive', pal[5]);
}
function simpleCompare(o1, o2) {
  let s1 = object2string(o1);
  let s2 = object2string(o2);
  return s1 == s2;
}
function simpleFit(text, wmax, hmax, fz) {
  let sz = { h: 10000 };
  while (sz.h > hmax && fz > 8) {
    sz = getSizeWithStyles(text, { w: wmax, fz: fz });
    fz -= 1;
  }
  sz.fz = fz;
  return sz;
}
function simpleGridToServerData(b1) {
  let bo1 = {};
  let fields = bo1.fields = { _set: b1.fields.map(oid => { return { _obj: oid }; }) };
  let edges = null;
  if (b1.hasEdges) {
    edges = bo1.edges = { _set: b1.edges.map(oid => { return { _obj: oid }; }) };
  }
  let corners = null;
  if (b1.hasNodes) {
    corners = bo1.corners = { _set: b1.corners.map(oid => { return { _obj: oid }; }) };
  }
  bo1.rows = b1.rows;
  bo1.cols = b1.mapData[0].length;
  let obj_type = bo1.obj_type = 'Board';
  if (this.shape == 'hex') {
    let maxColIndex = 2 * b1.colarr[b1.imiddleRow] - 1;
    console.assert(maxColIndex == bo1.cols, 'maxColIndex is NOT correct!!!!!!!!', maxColIndex, bo1.cols)
  }
  bo1.map = b1.mapData;
  return bo1;
}
function simpleLayoutForOneChildPosition(nBoard, tile, R) {
  let ch = tile.children[0];
  let robber = R.uiNodes[ch];
  let ui = robber.ui;
  ui.style.position = 'absolute';
  ui.style.display = 'inline-block';
  let x = nBoard.size.w / 2 + tile.pos.x - robber.size.w / 2;
  let y = nBoard.size.h / 2 + tile.pos.y - robber.size.h / 2;
  ui.style.left = x + 'px';
  ui.style.top = y + 'px';
  robber.pos = { x: x, y: y };
  ui.style.margin = '0px';
}
function simpleLayoutForOneChildSizeNeeded(ch, R) {
  let nChild = R.uiNodes[ch];
  let wNeeded = nChild.size.w + 12;
  let hNeeded = nChild.size.h + 12;
  return { w: wNeeded, h: hNeeded };
}
function simpleRep(val) {
  if (nundef(val) || val === '') {
    return '_';
  } else if (isSimple(val)) return val;
  else if (isList(val)) {
    return '[' + val.map(x => simpleRep(x)).join(', ') + ']';
  } else if (typeof val == 'object') {
    let s = [];
    for (const k in val) {
      if (isEmpty(val[k])) continue;
      let s1 = simpleRep(val[k]);
      if (k == '_set') s1 = '{' + s1.substring(1, s1.length - 1) + '}';
      s.push(s1);
    }
    return s.join(', ');
  }
}
function simpleSizes(wGame = 1000, hGame = 800, wSide = 200) {
  return;
  setCSSVariable('--wGame', wGame + 'px');
  setCSSVariable('--hGame', hGame + 'px');
  setCSSVariable('--wActions', wSide + 'px');
  setCSSVariable('--wLog', wSide + 'px');
  setCSSVariable('--hStatus', 'auto');
  setCSSVariable('--hTesting', '100%');
}
function simpleSizes_unused(wGame = 1000, hGame = 800, wSide = 200) {
  setCSSVariable('--wGame', wGame + 'px');
  setCSSVariable('--hGame', hGame + 'px');
  setCSSVariable('--wActions', wSide + 'px');
  setCSSVariable('--wLog', wSide + 'px');
  setCSSVariable('--hStatus', 'auto');
  setCSSVariable('--hTesting', '100%');
}
function simplest_game_open_for_move_dep(obj) {
  for (const k in obj) { if (isdef(Session[k])) copyKeys(obj[k], Session[k]); else Session[k] = obj[k]; }
  Session.cur_table = Session.table;
  console.assert(isdef(Session.cur_user) && Session.cur_game == Session.table.game && Session.cur_tid == Session.table.id, "SESSION MISMATCH IN GAME_OPEN_FOR_MOVE!!!!!!!!!!!!!!!!!!!!!");
  open_game_ui();
  G = open_game(Session.cur_user, Session.cur_game);
  G.make_players(Session.table);
  G.startGame(Session.cur_fen);
}
function simplestPerlenGame() {
  hide('dMainContent');
  show('dGameScreen');
  setTitle('Glasperlenspiel');
  setSubtitle('logged in as ' + Username);
  mStyleX(document.body, { opacity: 1 });
  initTable(null, 2); initSidebar(); initAux(); initScore();
  ColorThiefObject = new ColorThief();
  sendStartOrJoinPerlenGame();
}
function simpleWordListFromString(s, sep = [' ']) {
  let lst = listFromString(s);
  let res = [];
  for (const w of lst) {
    let parts = w.split(sep);
    parts.map(x => addIf(res, x));
  }
  return res;
}
function simplifyFraction(numerator, denominator) {
  var gcd = function gcd(a, b) {
    return b ? gcd(b, a % b) : a;
  };
  gcd = gcd(numerator, denominator);
  return [numerator / gcd, denominator / gcd];
}
function simulateClick(elem) {
  var evt = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
  var canceled = !elem.dispatchEvent(evt);
}
function single_poly_feature(f) {
  if (f.geometry.type == 'MultiPolygon') {
    let max_area_polygon;
    let max_area = 0;
    for (poly in (f.geometry.coordinates)) {
      let polygon1 = turf.polygon((f.geometry.coordinates)[poly])
      area = turf.area(polygon1);
      if (area > max_area) {
        max_area = area
        max_area_polygon = polygon1;
      }
    }
    return max_area_polygon;
  } else return f;
}
function size2hex(w = 100, h = 0, x = 0, y = 0) {
  let hexPoints = [{ X: 0.5, Y: 0 }, { X: 1, Y: 0.25 }, { X: 1, Y: 0.75 }, { X: 0.5, Y: 1 }, { X: 0, Y: 0.75 }, { X: 0, Y: 0.25 }];
  if (h == 0) {
    h = (2 * w) / 1.73;
  }
  return polyPointsFrom(w, h, x, y, hexPoints);
}
function size2tridown(w = 100, h = 0, x = 0, y = 0) {
  let triPoints = [{ X: 1, Y: 0 }, { X: 0.5, Y: 1 }, { X: 0, Y: 0 }];
  if (h == 0) { h = w; }
  return polyPointsFrom(w, h, x, y, triPoints);
}
function size2triup(w = 100, h = 0, x = 0, y = 0) {
  let triPoints = [{ X: 0.5, Y: 0 }, { X: 1, Y: 1 }, { X: 0, Y: 1 }];
  if (h == 0) { h = w; }
  return polyPointsFrom(w, h, x, y, triPoints);
}
function sizedCard123(w, h) { return o => card123(o, w, h); }
function sizeToContent(uid) {
  let n = R.uiNodes[uid];
  if (nundef(n.children)) return { w: 0, h: 0 }
  parentPadding = isdef(n.params.paddingAroundChildren) ? n.params.paddingAroundChildren : DEFS.defaultPadding;
  childMargin = isdef(n.params.gapBetweenChildren) ? n.params.gapBetweenChildren : DEFS.defaultGap;
  let or = n.params.orientation;
  let bl = n.params.baseline;
  let [y0, wTitle] = calcParentContentYOffsetAndWidth(n, parentPadding);
  let children = n.children.map(x => R.uiNodes[x]);
  let axMain, ax2;
  if (or == 'v') { axMain = 'h'; ax2 = 'w'; } else { axMain = 'w'; ax2 = 'h'; }
  let ax2Max = Math.max(...children.map(x => x.size[ax2]));
  let axMainSum = children.reduce((a, b) => a + (b.size[axMain] || 0), 0);
  axMainSum += childMargin * (children.length - 1);
  let wmax = (or == 'v' ? ax2Max : axMainSum);
  let xoff = 0;
  if (wTitle > wmax) xoff = (wTitle - wmax) / 2;
  let x0 = parentPadding + xoff;
  let x = x0;
  let y = y0;
  let lastChild = R.uiNodes[n.children[n.children.length - 1]];
  for (const n1 of children) {
    if (or == 'v') {
      switch (bl) {
        case 'start': x = x0; break;
        case 'end': x = x0 + ax2Max - n1.size[ax2]; break;
        case 'centered': x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
        case 'stretch':
          x = x0;
          if (n1.size.w < ax2Max) {
            n1.size.w = ax2Max;
            n1.ui.style.minWidth = n1.size.w + 'px';
          }
          break;
        default: x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
      }
      n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
      y += n1.size[axMain];
      if (n1 != lastChild) y += childMargin;
    } else {
      switch (bl) {
        case 'start': y = y0; break;
        case 'end': y = y0 + ax2Max - n1.size[ax2]; break;
        case 'centered': y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
        case 'stretch':
          y = y0;
          if (n1.size.h < ax2Max) {
            n1.size.h = ax2Max;
            n1.ui.style.minHeight = n1.size.h + 'px';
          }
          break;
        default: y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
      }
      n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
      x += n1.size.w;
      if (n1 != lastChild) x += childMargin;
    }
    n1.ui.style.left = n1.pos.x + 'px';
    n1.ui.style.top = n1.pos.y + 'px';
  }
  let wParent, hParent;
  if (or == 'h') {
    wParent = Math.max(wTitle + parentPadding * 2, x + parentPadding);
    hParent = y0 + ax2Max + parentPadding;
  } else {
    wParent = Math.max(wTitle + parentPadding * 2, ax2Max + 2 * x0);
    hParent = y0 + axMainSum + parentPadding;
  }
  return { w: wParent, h: hParent };
}
function skipToLine(lines, i, options) {
  options = convertToList(options);
  while (i < lines.length) {
    for (const s of options) {
      if (lines[i].includes(s)) {
        return { index: i, option: s };
      }
    }
    i += 1;
  }
  return { index: i, option: null };
}
function skype_go_button() {
  let html = `
    <button
      role="button"
      title="Send message"
      aria-label="Send message"
      aria-disabled="false"
      style="
        position: relative;
        display: flex;
        flex-direction: column;
        flex-grow: 0;
        flex-shrink: 0;
        overflow: visible;
        align-items: center;
        justify-content: center;
        app-region: no-drag;
        background-color: transparent;
        border-color: transparent;
        text-align: left;
        border-width: 0px;
        height: 44px;
        width: 44px;
        padding: 0px;
        cursor: pointer;
        border-style: solid;
      "
    >
      <div
        role="none"
        style="
          position: absolute;
          display: flex;
          flex-direction: column;
          flex-grow: 0;
          flex-shrink: 0;
          overflow: hidden;
          align-items: center;
          background: linear-gradient(135deg, rgb(0, 188, 242), rgb(0, 120, 212));
          height: 40px;
          width: 40px;
          border-radius: 20px;
          top: 2px;
          left: 2px;
          justify-content: center;
        "
      >
        <div
          role="none"
          aria-hidden="true"
          style="position: relative; display: flex; flex-direction: column; flex-grow: 0; flex-shrink: 0; overflow: hidden; align-items: stretch; margin-left: 2px"
        >
          <svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#FFFFFF" gradientcolor1="#FFFFFF" gradientcolor2="#FFFFFF">
            <path
              d="M5.694 12L2.299 3.272c-.236-.608.356-1.189.942-.982l.093.04 18 9a.75.75 0 01.097 1.283l-.097.058-18 9c-.583.291-1.217-.245-1.065-.847l.03-.096L5.694 12 2.299 3.272 5.694 12zM4.402 4.54l2.61 6.71h6.627a.75.75 0 01.743.648l.007.102a.75.75 0 01-.649.743l-.101.007H7.01l-2.609 6.71L19.322 12 4.401 4.54z"
            ></path>
          </svg>
        </div>
      </div>
    </button>
  `;
  return mCreateFrom(html);
}
function skype_start() {
  let d = mBy('dSkype'); mClear(d);
  mStyle(d, { h: 'calc( 100vh - 56px )', 'overflow-y': 'hidden' });
  let d0 = mDiv(d);
  let [dl, dr] = mColFlex(d, [1, 3]);
  mStyle(dl, { border: '1px dotted silver' }); mStyle(dr, { border: '1px dotted silver' });
  mDiv(dl, {}, null, img_html('skypeTopLeft.jpg'));
  let d1 = mDiv(dl);
  DIBOA.skype.divRight = dr;
  DIBOA.skype.divLeft = dl;
  let contacts = DIBOA.skype.contacts = generate_skype_contacts(25); console.log(contacts)
  for (const o of contacts) {
    let dc = mDiv(d1, { rounding: 12, hpadding: 6, vpadding: 6, margin: 4, gap: 12, overflow: 'hidden' }, null, null, 'skypecontact');
    mFlex(dc);
    o.div = dc;
    dc.onclick = () => { S.skype_contact = toggleSelection(o, S.skype_contact, 'skypecontact_active'); show_skype_contact(dr) };
    let [sz] = [40];
    let dimg = get_skype_phone_icon(o.color);
    mAppend(dc, dimg);
    let dmiddle = mDiv(dc, { flex: 8 });
    let dnum = mDiv(dmiddle, { fz: 14, fg: 'black' }, null, `<div>${o.num}</div>`);
    let dmsg = mDiv(dmiddle, { fz: 11, fg: 'grey' }, null, `<div>${o.msg}</div>`);
    let ddate = mDiv(dc, { flex: 1, fz: 11, fg: 'grey' }, null, `<div>${format_date(o.date)}</div>`);
  }
}
function sleep() { return new Promise(r => setTimeout(r, m)) }
function sleepX(msecs) {
  return new Promise(r => setTimeout(r, msecs));
}
function slowlyTurnFaceDown(pic, secs = 5, removeBg = false) {
  let ui = iDiv(pic);
  for (const p1 of ui.children) {
    p1.style.transition = `opacity ${secs}s ease-in-out`;
    p1.style.opacity = 0;
  }
  if (removeBg) {
    ui.style.transition = `background-color ${secs}s ease-in-out`;
    ui.style.backgroundColor = 'dimgray';
  }
  pic.isFaceUp = false;
}
function small_hands(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand.sort();
    pl.hand = arrTake(pl.hand, 7);
  }
}
function snail(p, o, d) {
  if (o.length == 0) return;
  testHelpers(p, o);
  o[0].setPos(p.x, p.y);
  n = o.length;
  let step = 1;
  let k = 1;
  while (true) {
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mup(o[k], p, d);
        k += 1;
      } else return;
    }
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mri(o[k], p, d);
        k += 1;
      } else return;
    }
    step += 1;
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mdo(o[k], p, d);
        k += 1;
      } else return;
    }
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mle(o[k], p, d);
        k += 1;
      } else return;
    }
    step += 1;
  }
}
function socketEmitChat(msg = '') {
  if (!USE_SOCKETIO) return;
  let text = msg + getInputValue('chat');
  if (!isEmpty(text)) { socket.emit('chat', text); }
}
function socketEmitMessage(msg) {
  if (!USE_SOCKETIO) return;
  if (isDict(msg)) msg = JSON.stringify(msg);
  socket.emit('message', msg);
}
function solve(board) {
  let updated = true, solved = false
  while (updated && !solved) {
    updated = one_value_cell_constraint(board)
    solved = is_solved(board)
  }
  if (!solved) {
    board = backtrack_based(board)
    solved = is_solved(board)
  }
  return board
}
function someFunction() {
  testHelpers('hhhhhhhhhhhhhhhhhhhhhhhhhhh');
}
function someVisualExists(oid) { return firstCond(oid2ids[oid], x => x[0] == 'd' || x[0] == 'm'); }
function sort_cards(hand, bySuit = true, suits = 'CDHS', byRank = true, rankstr = '23456789TJQKA') {
  if (bySuit && byRank) {
    let buckets = arrBuckets(hand, x => x[1], suits);
    for (const b of buckets) { sort_cards(b.list, false, null, true, rankstr); }
    hand.length = 0; buckets.map(x => x.list.map(y => hand.push(y)));
  } else if (bySuit) hand.sort((a, b) => suits.indexOf(a[1]) - suits.indexOf(b[1]));
  else if (byRank) hand.sort((a, b) => rankstr.indexOf(a[0]) - rankstr.indexOf(b[0]));
  return hand;
}
function sort_cards_orig(hand, bysuit = true, byrank = true) {
  let ranked = hand.map(x => ({ x: x, r: x[0], s: x[1] }));
  let rankstr = 'A23456789TJQK';
  if (bysuit && byrank) {
    sortByFunc(ranked, x => 3 * x.s.charCodeAt(0) + 2 * rankstr.indexOf(x.r));
  } else if (bysuit) {
    sortByFunc(ranked, x => x.s.charCodeAt(0));
  } else if (byrank) {
    sortByFunc(ranked, x => rankstr.indexOf(x.r));
  }
  return ranked.map(x => x.x);
}
function sortBy(arr, key) { arr.sort((a, b) => (a[key] < b[key] ? -1 : 1)); return arr; }
function sortByDescending(arr, key) { arr.sort((a, b) => (a[key] > b[key] ? -1 : 1)); return arr; }
function sortByFunc(arr, func) { arr.sort((a, b) => (func(a) < func(b) ? -1 : 1)); return arr; }
function sortByFuncDescending(arr, func) { arr.sort((a, b) => (func(a) > func(b) ? -1 : 1)); return arr; }
function sortByRank(ckeys, rankstr = '23456789TJQKA') {
  let ranks = toLetters(rankstr);
  ckeys.sort((a, b) => ranks.indexOf(a[0]) - ranks.indexOf(b[0]));
  return ckeys;
}
function sortCardItemsByRank(items, rankstr = '23456789TJQKA') {
  let ranks = toLetters(rankstr);
  items.sort((a, b) => ranks.indexOf(a.key[0]) - ranks.indexOf(b.key[0]));
  return items;
}
function sortCardItemsBySuit(items, suitstr = 'CDSH') {
  let ranks = toLetters(suitstr);
  items.sort((a, b) => ranks.indexOf(a.key[1]) - ranks.indexOf(b.key[1]));
  return items;
}
function sortCardItemsToSequence(items, rankstr = '23456789TJQKA', jolly_allowed = 1) {
  let ranks = toLetters(rankstr);
  let n = items.length;
  let jollies = items.filter(x => is_joker(x));
  if (jollies.length > jolly_allowed) { return null; }
  let no_jolly = items.filter(x => !is_joker(x));
  let sorted = sortCardItemsByRank(no_jolly, rankstr);
  let partial_sequences = [], seq = [sorted[0]], first, second;
  for (let i = 0; i < sorted.length - 1; i++) {
    first = sorted[i];
    second = sorted[i + 1];
    diff = second.irank - first.irank;
    if (diff == 1) { seq.push(second); }
    else {
      partial_sequences.push({ seq: seq, len: seq.length, diff_to_next: diff });
      seq = [second];
    }
  }
  diff = sorted[0].irank - (sorted[sorted.length - 1].irank - rankstr.length)
  if (!isEmpty(seq)) {
    partial_sequences.push({ seq: seq, len: seq.length, diff_to_next: diff });
  } else {
    arrLast(partial_sequences).diff_to_next = diff;
  }
  let i_max_diff = partial_sequences.findIndex(x => x.diff_to_next == Math.max(...partial_sequences.map(x => x.diff_to_next)));
  let max_diff = partial_sequences[i_max_diff].diff_to_next;
  let istart = (i_max_diff + 1) % partial_sequences.length;
  let final_sequence = [];
  let jollies_needed = 0;
  let len = partial_sequences.length;
  let ij = 0;
  for (let i = 0; i < len; i++) {
    let index = (i + istart) % len;
    let list = partial_sequences[index].seq;
    final_sequence = final_sequence.concat(list);
    let nj = partial_sequences[index].diff_to_next - 1;
    if (i < len - 1) {
      for (let j = 0; j < nj; j++) { final_sequence.push(jollies[ij++]); }
      jollies_needed += nj;
    }
  }
  for (let i = 0; i < final_sequence.length; i++) { items[i] = final_sequence[i]; }
  return jollies_needed;
}
function sortCaseInsensitive(list) {
  list.sort((a, b) => { return a.toLowerCase().localeCompare(b.toLowerCase()); });
  return list;
}
function sortClassKeys(di) {
  let classes = dict2list(di.cla, 'key');
  let classesWithoutExtends = classes.filter(x => !x.code.includes(' extends '));
  let keys = sortCaseInsensitive(classesWithoutExtends.map(x => x.key));
  let dinew = {};
  for (const el of keys) { dinew[el] = di.cla[el]; }
  let classesWithExtends = classes.filter(x => x.code.includes(' extends '));
  let MAX = 150, i = 0;
  console.log('starting class loop')
  while (!isEmpty(classesWithExtends)) {
    if (++i > MAX) { console.log("WRONG!!!"); return []; }
    let o = classesWithExtends.find(x => {
      let ext = firstWordAfter(x.code, 'extends', true).trim();
      if (nundef(di.cla[ext])) return true;
      return isdef(dinew[ext]);
    });
    if (isdef(o)) { dinew[o.key] = o; removeInPlace(classesWithExtends, o); }
  }
  return Object.keys(dinew);
}
function sortConstKeys(di) {
  let tbd = dict2list(di.const, 'key');
  let donelist = [];
  tbd = sortBy(tbd, x => x.code.length);
  let dinew = {};
  let MAX = 3000, i1 = 0, i2 = 0, i3 = 0;
  console.log('starting const loop');
  console.log('const keys', tbd.length);
  while (!isEmpty(tbd)) {
    if (++i1 > MAX) { console.log("WRONG!!!"); return donelist; }
    let o = null;
    i2 = 0;
    for (const c of tbd) {
      if (++i2 > MAX) { console.log("WRONG!!!"); return donelist; }
      i3 = 0;
      let ok = true;
      for (const c1 of tbd) {
        if (++i3 > MAX) { console.log("WRONG!!!"); return donelist; }
        if (c1 == c) continue;
        if (c.code.includes(c1.key)) ok = false;
      }
      if (ok) { o = c; break; }
    }
    if (isdef(o)) { donelist.push(o); dinew[o.key] = o; removeInPlace(tbd, o); }
  }
  return donelist;
}
function sortKeys(o) {
  if (Array.isArray(o)) {
    return o.map(sortKeys);
  } else if (isObject(o)) {
    return Object
      .keys(o)
      .sort()
      .reduce(function (a, k) {
        a[k] = sortKeys(o[k]);
        return a;
      }, {});
  }
  return o;
}
function sortKeysNonRecursive(o) {
  if (Array.isArray(o)) {
    return o.map(sortKeysNonRecursive);
  } else if (isObject(o)) {
    return Object
      .keys(o)
      .sort()
      .reduce(function (a, k) {
        a[k] = o[k];
        return a;
      }, {});
  }
  return o;
}
function sortKeysNonRecursiveDescending(o) {
  if (Array.isArray(o)) {
    return o.map(sortKeysNonRecursiveDescending);
  } else if (isObject(o)) {
    return Object
      .keys(o)
      .reverse()
      .reduce(function (a, k) {
        a[k] = o[k];
        return a;
      }, {});
  }
  return o;
}
function sortNumbers(ilist) { ilist.sort(function (a, b) { return a - b }); return ilist; }
function Sound(src) {
  this.snd = document.createElement("audio");
  this.snd.src = src;
  this.play = function () {
    this.snd.play();
  }
}
function soundsSimilar(w1, w2, lang) {
  w1 = convertTimesAndNumbersToWords(w1);
  w2 = convertTimesAndNumbersToWords(w2);
  const syllableRegex = /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi;
  function syllabify(words) {
    return words.match(syllableRegex);
  }
  let a1 = syllabify(w1);
  let a2 = syllabify(w2);
  if (!a1) a1 = [w1];
  if (!a2) a2 = [w2];
  if (lang == 'D' && isdef(germanNumbers[a1]) && germanNumbers[a1] == germanNumbers[a2]) return true;
  if (a1.length != a2.length) return false;
  let SUPER_WEAK_SIMILARTY = false;
  if (SUPER_WEAK_SIMILARTY) {
    for (let i = 0; i < a1.length; i++) {
      let s1 = a1[i];
      let s2 = a2[i];
      if (s1 == s2) return true;
      let x1 = stringAfterLeadingConsonants(s1);
      let x2 = stringAfterLeadingConsonants(s2);
      if (lang == 'E' && 'ou'.includes(x1) && 'ou'.includes(x2) && x1.substring(1) == x2.substring(1)) return true;
      if (lang == 'E' && 'oa'.includes(x1) && 'ao'.includes(x2) && x1.substring(1) == x2.substring(1)) return true;
      if (lang == 'E' && x1.replace('ee', 'i') == x2.replace('ee', 'i')) return true;
      if (lang == 'E' && x1.replace('ea', 'ai') == x2.replace('ea', 'ai')) return true;
      if (lang == 'E' && x1.replace('au', 'o') == x2.replace('au', 'o')) return true;
    }
  } else {
    for (let i = 0; i < a1.length; i++) {
      let yesItsAMatch = false;
      let s1 = a1[i];
      let s2 = a2[i];
      if (s1 == s2) yesItsAMatch = true;
      let x1 = stringAfterLeadingConsonants(s1);
      let x2 = stringAfterLeadingConsonants(s2);
      if (x1 == x2) yesItsAMatch = true;
      if (lang == 'E' && 'ou'.includes(x1) && 'ou'.includes(x2) && x1.substring(1) == x2.substring(1)) yesItsAMatch = true;
      if (lang == 'E' && 'oa'.includes(x1) && 'ao'.includes(x2) && x1.substring(1) == x2.substring(1)) yesItsAMatch = true;
      if (lang == 'E' && x1.replace('ee', 'i') == x2.replace('ee', 'i')) yesItsAMatch = true;
      if (lang == 'E' && x1.replace('ea', 'ai') == x2.replace('ea', 'ai')) yesItsAMatch = true;
      if (lang == 'E' && x1.replace('au', 'o') == x2.replace('au', 'o')) yesItsAMatch = true;
      if (!yesItsAMatch) return false;
    }
    return true;
  }
  return false;
}
function specAndDOM(callbacks = []) {
  flags.specAndDOM = false;
  initSETTINGS();
  initPageHeader();
  initTABLES();
  initDom();
  presentSpecAndCode();
  let hasStructure = false;
  if (S.settings.userStructures) hasStructure = initSTRUCTURES();
  if (!hasStructure && S.settings.boardDetection) {
    detectBoard(G.table, 'a_d_game');
    timit.showTime('*** board end ***')
  }
  if (!hasStructure && S.settings.deckDetection) {
    detectDecks(G.table, 'a_d_game');
  }
  openTabTesting(S.settings.openTab);
  if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
}
function specialTableElem(o, keys) {
  let t = document.createElement('table');
  t.classList.add('tttable');
  let s = '';
  for (const k in o) {
    if (isdef(keys) && !keys.includes(k)) continue;
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) {
      sval = `<div class='obj' onmouseenter='highlightContentIds(this);' onmouseleave='unhighlightContentIds(this);'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    } else if (val && isDict(val) && '_obj' in val) {
      sval = `<button onclick='onClickListOfObj(this);'>${val._obj.toString()}</button>`;
    }
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? specialTreee2(val, 4) : simpleRep(val);
    s += sval + '</td>';
  }
  t.innerHTML = s;
  return t;
}
function specialTreee2(o) {
  let s = '<table class="tttable up10">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) sval = `<button onclick='onClickListOfObj(this);'>${val.map(x => !x ? '_' : x._obj).toString()}</button>`;
    else if (val && isDict(val) && '_obj' in val) sval = `<button onclick='onClickListOfObj(this);'>${val._obj.toString()}</button>`;
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? specialTreee2(val) : simpleRep(val);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function speech00(lang) {
  if (typeof (webkitSpeechRecognition) != "function") { alert("Unable to use the Speech Recognition API"); }
  recognition = new webkitSpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;
  recognition.maxAlternatives = 5;
  recognition.lang = isEnglish(lang) ? 'en-US' : 'de-DE';
  addErrorHandler();
  addStartHandler();
  addEndHandler();
  addResultHandler();
}
function speechEngineGo(lang, matchingWords) {
  words = matchingWords;
  grammar = '#JSGF V1.0; grammar colors; public <color> = ' + words.join(' | ') + ' ;'
  recognition = new SpeechRecognition();
  speechRecognitionList = new SpeechGrammarList();
  speechRecognitionList.addFromString(grammar, 1);
  recognition.grammars = speechRecognitionList;
  recognition.continuous = false;
  recognition.lang = isEnglish(lang) ? 'en-US' : 'de-DE'; //'en-US';
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
  recognition.onresult = function (event) {
    let word = event.results[0][0].transcript;
    resultMessage.textContent = 'Result received: ' + word + '.';
    console.log('Confidence: ' + event.results[0][0].confidence);
    recognition.stop();
    let b = mBy('bStart');
    b.innerHTML = 'NEXT';
    show('bStart');
  }
  recognition.onspeechend = function () {
    console.log('onSpeechEnd happened!')
    recognition.stop();
  }
  recognition.onnomatch = function (event) {
    resultMessage.textContent = "I didn't recognise that word! - try again";
    recognition.stop();
  }
  recognition.onerror = function (event) {
    resultMessage.textContent = 'Error occurred in recognition: ' + event.error;
    recognition.stop();
  }
  document.body.onclick = function () {
    recognition.start();
    console.log('Ready to receive a color command.');
  }
}
function splayout(elems, dParent, w, h, x, y, overlap = 20, splay = 'right') {
  function splayRight(elems, d, x, y, overlap) {
    for (const c of elems) {
      mAppend(d, c);
      mStyle(c, { position: 'absolute', left: x, top: y });
      x += overlap;
    }
    return [x, y];
  }
  function splayLeft(elems, d, x, y, overlap) {
    x += (elems.length - 2) * overlap;
    let xLast = x;
    for (const c of elems) {
      mAppend(d, c);
      mStyle(c, { position: 'absolute', left: x, top: y });
      x -= overlap;
    }
    return [xLast, y];
  }
  function splayDown(elems, d, x, y, overlap) {
    for (const c of elems) {
      mAppend(d, c);
      mStyle(c, { position: 'absolute', left: x, top: y });
      y += overlap;
    }
    return [x, y];
  }
  function splayUp(elems, d, x, y, overlap) {
    y += (elems.length - 1) * overlap;
    let yLast = y;
    for (const c of elems) {
      mAppend(d, c);
      mStyle(c, { position: 'absolute', left: x, top: y });
      y -= overlap;
    }
    return [x, yLast];
  }
  if (isEmpty(elems)) return { w: 0, h: 0 };
  mStyle(dParent, { display: 'block', position: 'relative' });
  [x, y] = (eval('splay' + capitalize(splay)))(elems, dParent, x, y, overlap);
  let isHorizontal = splay == 'right' || splay == 'left';
  let sz = { w: (isHorizontal ? (x - overlap + w) : w), h: (isHorizontal ? h : (y - overlap + h)) };
  return sz;
}
function splitAtAnyOf(s, sep) {
  let arr = [], w = '';
  for (let i = 0; i < s.length; i++) {
    let ch = s[i];
    if (sep.includes(ch)) {
      if (!isEmpty(w)) arr.push(w);
      w = '';
    } else {
      w += ch;
    }
  }
  if (!isEmpty(w)) arr.push(w);
  return arr;
}
function splitAtWhiteSpace(s) { return s.split(/[-/ ,]+/); }
function splitIntoNumbersAndWords(s) {
  let arr = [], i = 0;
  while (i < s.length) {
    let ch = s[i];
    let w = '';
    if (isDigit(ch)) while (i < s.length && isDigit(ch)) { w += ch; i++; ch = s[i]; }
    else if (isLetter(ch)) while (i < s.length && isLetter(ch)) { w += ch; i++; ch = s[i]; }
    else { i++; continue; }
    arr.push(w);
  }
  return arr;
}
function spotit() {
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), turn: [players[0]], stage: 'init', phase: '' };
    for (const plname of players) {
      fen.players[plname] = {
        score: 0, name: plname, color: get_user_color(plname),
      };
    }
    fen.items = spotit_item_fen(options);
    if (nundef(options.mode)) options.mode = 'multi';
    return fen;
  }
  function check_gameover() {
    for (const uname of Z.plorder) {
      let cond = get_player_score(uname) >= Z.options.winning_score;
      if (cond) { Z.fen.winners = [uname]; return Z.fen.winners; }
    }
    return false;
  }
  function state_info(dParent) { spotit_state(dParent); }
  function present(dParent) { spotit_present(dParent); }
  function stats(dParent) { spotit_stats(dParent); }
  function activate_ui() { spotit_activate(); }
  return { setup, activate_ui, check_gameover, present, state_info, stats };
}
function spotit_activate() {
  let [stage, uplayer, host, plorder, fen] = [Z.stage, Z.uplayer, Z.host, Z.plorder, Z.fen];
  if (stage == 'move' && uplayer == host && get_player_score(host) >= 1) {
    let bots = plorder.filter(x => fen.players[x].playmode == 'bot');
    if (isEmpty(bots)) return;
    let bot = rChoose(bots);
    TO.main = setTimeout(() => spotit_move(bot, true), rNumber(2000, 9000));
  }
}
function spotit_card(info, dParent, cardStyles, onClickSym) {
  Card.sz = 300;
  copyKeys({ w: Card.sz, h: Card.sz }, cardStyles);
  let card = cRound(dParent, cardStyles, info.id);
  addKeys(info, card);
  card.faceUp = true;
  let zipped = [];
  for (let i = 0; i < card.keys.length; i++) {
    zipped.push({ key: card.keys[i], scale: card.scales[i] });
  }
  card.pattern = fillColarr(card.colarr, zipped);
  let symStyles = { sz: Card.sz / (card.rows + 1), fg: 'random', hmargin: 10, vmargin: 6, cursor: 'pointer' };
  let syms = [];
  mRowsX(iDiv(card), card.pattern, symStyles, { 'justify-content': 'center' }, { 'justify-content': 'center' }, syms);
  for (let i = 0; i < info.keys.length; i++) {
    let key = card.keys[i];
    let sym = syms[i];
    card.live[key] = sym;
    sym.setAttribute('key', key);
    sym.onclick = ev => onClickSym(ev, key);
  }
  return card;
}
function spotit_check_endcondition() {
  let players = get_values(Session.cur_players);
  let winners = players.filter(x => x.score >= 2).map(x => x.name);
  return winners;
}
function spotit_check_gameover(z) {
  for (const uname of z.plorder) {
    let cond = get_player_score(uname) >= z.options.winning_score;
    if (cond) { z.fen.winners = [uname]; return z.fen.winners; }
  }
  return false;
}
function spotit_clear_score() {
  assertion(isdef(Z.notes), 'Z.notes not defined');
  Z.notes = {};
}
function spotit_create_sample(numCards, numSyms, vocab, lang, min_scale, max_scale) {
  lang = valf(lang, 'E');
  let [rows, cols, colarr] = calc_syms(numSyms);
  let perCard = arrSum(colarr);
  let nShared = (numCards * (numCards - 1)) / 2;
  let nUnique = perCard - numCards + 1;
  let numKeysNeeded = nShared + numCards * nUnique;
  let nMin = numKeysNeeded + 3;
  let keypool = setKeys({ nMin: nMin, lang: valf(lang, 'E'), key: valf(vocab, 'animals'), keySets: KeySets, filterFunc: (_, x) => !x.includes(' ') });
  let keys = choose(keypool, numKeysNeeded);
  let dupls = keys.slice(0, nShared);
  let uniqs = keys.slice(nShared);
  let infos = [];
  for (let i = 0; i < numCards; i++) {
    let keylist = uniqs.slice(i * nUnique, (i + 1) * nUnique);
    let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols: cols, colarr: colarr, num_syms: perCard };
    infos.push(info);
  }
  let iShared = 0;
  for (let i = 0; i < numCards; i++) {
    for (let j = i + 1; j < numCards; j++) {
      let c1 = infos[i];
      let c2 = infos[j];
      let dupl = dupls[iShared++];
      c1.keys.push(dupl);
      c1.shares[c2.id] = dupl;
      c2.shares[c1.id] = dupl;
      c2.keys.push(dupl);
    }
  }
  for (const info of infos) { shuffle(info.keys); }
  for (const info of infos) {
    info.scales = info.keys.map(x => chooseRandom([.5, .75, 1, 1.2]));
  }
  for (const info of infos) {
    let zipped = [];
    for (let i = 0; i < info.keys.length; i++) {
      zipped.push({ key: info.keys[i], scale: info.scales[i] });
    }
    info.pattern = fillColarr(info.colarr, zipped);
  }
  return infos;
}
function spotit_deal(numCards, rows, cols, vocab, lang, min_scale, max_scale, fen) {
  lang = valf(lang, 'E');
  let colarr = _calc_hex_col_array(rows, cols);
  if (rows == 3 && cols == 1) { colarr = [1, 3, 1]; }
  else if (rows == 2 && cols == 1) { colarr = [1, 2]; }
  else if (rows == 4 && cols == 1) { rows = 3; colarr = [2, 3, 1]; }
  else if (rows == 5 && cols == 1) { rows = 4; cols = 1; colarr = [1, 3, 3, 1]; }
  else if (rows == 5 && cols == 3) { rows = 5; cols = 1; colarr = [1, 3, 4, 3, 1]; }
  else if (rows == 6 && cols == 2) { rows = 5.5; colarr = [2, 4, 5, 4, 2]; }
  let perCard = arrSum(colarr);
  let nShared = (numCards * (numCards - 1)) / 2;
  let nUnique = perCard - numCards + 1;
  let numKeysNeeded = nShared + numCards * nUnique;
  let nMin = numKeysNeeded + 3;
  let keypool = setKeys({ nMin: nMin, lang: valf(lang, 'E'), key: valf(vocab, 'animals'), keySets: KeySets, filterFunc: (_, x) => !x.includes(' ') });
  let keys = choose(keypool, numKeysNeeded);
  let dupls = keys.slice(0, nShared);
  let uniqs = keys.slice(nShared);
  let infos = [];
  for (let i = 0; i < numCards; i++) {
    let keylist = uniqs.slice(i * nUnique, (i + 1) * nUnique);
    let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols: cols, colarr: colarr, num_syms: perCard };
    infos.push(info);
  }
  let iShared = 0;
  for (let i = 0; i < numCards; i++) {
    for (let j = i + 1; j < numCards; j++) {
      let c1 = infos[i];
      let c2 = infos[j];
      let dupl = dupls[iShared++];
      c1.keys.push(dupl);
      c1.shares[c2.id] = dupl;
      c2.shares[c1.id] = dupl;
      c2.keys.push(dupl);
    }
  }
  for (const info of infos) { shuffle(info.keys); }
  for (const info of infos) {
    info.scales = info.keys.map(x => randomNumber(min_scale * 100, max_scale * 100) / 100);
  }
  if (isdef(fen)) {
    let ks_for_cards = fen.split(',');
    for (let i = 0; i < infos.length; i++) {
      let info = infos[i];
      let ks_list = ks_for_cards[i].split(' ');
      info.keys = ks_list.map(x => stringBefore(x, ':'));
      info.scales = ks_list.map(x => stringAfter(x, ':')).map(x => Number(x));
    }
  }
  let items = [];
  for (const info of infos) {
    let item = spotit_card(info, dTable, { margin: 20 }, spotit_interact);
    items.push(item);
  }
  return items;
}
function spotit_evaluate() {
  if (!canAct()) return;
  uiActivated = false; clearTimeouts();
  IsAnswerCorrect = Selected.isCorrect;
  update_my_score(IsAnswerCorrect ? 1 : 0);
  let me = Session.cur_me;
  if (me.score >= Session.winning_score) me.player_status = 'done';
  let delay = show_feedback(IsAnswerCorrect);
  setTimeout(() => {
    in_game_open_prompt_off();
    clear_table_events();
    send_move();
  }, delay);
}
function spotit_fail() { spotit_move(G, U.name, false); }
function spotit_fen() {
  let me = Session.cur_players[Session.cur_user];
  let items = Session.items;
  let fen = items.map(x => x.keys.join(' ')).join(',');
  let item_fens = [];
  for (const item of items) {
    let arr = arrFlatten(item.pattern);
    let ifen = arr.map(x => `${x.key}:${x.scale}`).join(' ');
    item_fens.push(ifen);
  }
  fen = item_fens.join(',');
  me.state = fen;
}
function spotit_find_shared(card, keyClicked) {
  let success = false, othercard = null;
  for (const c of Z.cards) {
    if (c == card) continue;
    if (c.keys.includes(keyClicked)) { success = true; othercard = c; }
  }
  return [success, othercard];
}
function spotit_get_shared_symbols() {
  let result = [];
  for (const item of Session.items) {
    for (const id in item.shares) {
      let k = item.shares[id];
      let ui = iGetl(item, k);
      result.push(ui);
    }
  }
  return result;
}
function spotit_interact(ev, key) {
  ev.cancelBubble = true;
  if (!uiActivated) { console.log('ui NOT activated'); return; }
  let keyClicked = evToProp(ev, 'key');
  let id = evToId(ev);
  if (isdef(keyClicked) && isdef(Items[id])) {
    let item = Items[id];
    let dsym = ev.target;
    let card = Items[id];
    let [success, othercard] = spotit_find_shared(card, keyClicked);
    spotit_move(Z.uplayer, success);
  }
}
function spotit_item_fen(options) {
  let o = {
    num_cards: valf(options.num_cards, 2),
    num_symbols: options.adaptive == 'yes' ? 14 : valf(options.num_symbols, 7),
    vocab: valf(options.vocab, 'lifePlus'),
    lang: 'E',
    min_scale: valf(options.min_scale, 0.75),
    max_scale: valf(options.max_scale, 1.25),
  };
  let items = spotit_create_sample(o.num_cards, o.num_symbols, o.vocab, o.lang, o.min_scale, o.max_scale);
  let item_fens = [];
  for (const item of items) {
    let arr = arrFlatten(item.pattern);
    let ifen = arr.map(x => `${x.key}:${x.scale}`).join(' ');
    item_fens.push(ifen);
  }
  let res = item_fens.join(',');
  return res;
}
function spotit_move(uplayer, success) {
  if (success) {
    inc_player_score(uplayer);
    assertion(get_player_score(uplayer) >= 1, 'player score should be >= 1');
    Z.fen.items = spotit_item_fen(Z.options);
    Z.state = { score: get_player_score(uplayer) };
    take_turn_spotit();
  } else {
    let d = mShield(dTable, { bg: '#000000aa', fg: 'red', fz: 60, align: 'center' });
    d.innerHTML = 'NOPE!!! try again!';
    TO.spotit_penalty = setTimeout(() => d.remove(), 2000);
  }
}
function spotit_parse_fen() { }
function spotit_populate_settings(dParent) {
  Session.game_options.game = {};
  let poss = DB.games[Session.cur_game].options;
  if (nundef(poss)) return;
  for (const p in poss) {
    let key = p;
    let val = poss[p];
    if (isString(val)) {
      let list = val.split(',');
      let fs = mRadioGroup(dParent, {}, `d_${key}`, key);
      let checkfirst = true;
      for (const v of list) {
        let d = mRadio(v, isNumber(v) ? Number(v) : v, fs, { cursor: 'pointer' }, null, key);
        if (checkfirst) {
          let inp = d.firstChild;
          inp.setAttribute('checked', true);
          checkfirst = false;
        }
      }
      measure_fieldset(fs);
    } else if (val === true || val === false) {
      console.log('should make a checkbox for', key);
    }
  }
}
function spotit_present(dParent) {
  let [fen, ui, stage, uplayer] = [Z.fen, UI, Z.stage, Z.uplayer];
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent, 1, 0);
  spotit_read_all_scores();
  let dt = dOpenTable; clearElement(dt); mCenterFlex(dt);
  spotit_stats(dt);
  mLinebreak(dt, 10);
  let ks_for_cards = fen.items.split(',');
  let numCards = ks_for_cards.length;
  let items = Z.items = [];
  Items = [];
  let i = 0;
  for (const s of ks_for_cards) {
    let ks_list = s.split(' ');
    let item = {};
    item.keys = ks_list.map(x => stringBefore(x, ':'));
    item.scales = ks_list.map(x => stringAfter(x, ':')).map(x => Number(x));
    item.index = i; i++;
    let n = item.numSyms = item.keys.length;
    let [rows, cols, colarr] = calc_syms(item.numSyms);
    item.colarr = colarr;
    item.rows = rows;
    items.push(item);
  }
  Z.cards = [];
  let is_adaptive = Z.options.adaptive == 'yes';
  let nsyms = is_adaptive ? cal_num_syms_adaptive() : Z.options.num_symbols;
  for (const item of items) {
    if (is_adaptive) { modify_item_for_adaptive(item, items, nsyms); }
    let card = spotit_card(item, dt, { margin: 20, padding: 10 }, spotit_interact);
    Z.cards.push(card);
    if (Z.stage == 'init') {
      face_down(card, GREEN, 'food');
    }
  }
  mLinebreak(dt, 10);
}
function spotit_read_all_scores() {
  if (nundef(Z.playerdata)) {
    Z.playerdata = [];
    for (const pl in Z.fen.players) {
      Z.playerdata.push({
        name: pl,
        state: { score: 0 },
      });
    }
  }
  for (const pldata of Z.playerdata) {
    let plname = pldata.name;
    let state = pldata.state;
    let score = !isEmpty(state) ? state.score : 0;
    let fenscore = lookupSet(Z.fen, ['players', plname, 'score'], score);
    Z.fen.players[plname].score = Math.max(fenscore, score);
  }
}
function spotit_setup(players) {
  Card.sz = 200;
  let fen = { cards: ['ASr', 'QHb'], players: {}, step: 0, plorder: jsCopy(players), turn: jsCopy(players) };
  let expected = {};
  for (const uname of players) {
    fen.players[uname] = { score: 0 };
    expected[uname] = { step: 0, type: 'move' }
  }
  return { fen: fen, expected: expected };
}
function spotit_start() { startgame('spotit', ['amanda', 'felix']); }
function spotit_state(dParent) {
  let user_html = get_user_pic_html(Z.uplayer, 30);
  let msg = Z.stage == 'init' ? `getting ready...` : `player: ${user_html}`;
  dParent.innerHTML = `Round ${Z.round}:&nbsp;${msg} `;
}
function spotit_stats(d) {
  let players = Z.fen.players;
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname of get_present_order()) {
    let pl = players[plname];
    let onturn = Z.turn.includes(plname);
    let sz = 50;
    let bcolor = plname == Z.uplayer ? 'lime' : 'silver';
    let border = pl.playmode == 'bot' ? `double 5px ${bcolor}` : `solid 5px ${bcolor}`;
    let rounding = pl.playmode == 'bot' ? '0px' : '50%';
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='../base/assets/images/${plname}.jpg' style="border-radius:${rounding};display:block;border:${border};box-sizing:border-box" class='img_person' width=${sz} height=${sz}>${get_player_score(plname)}`);
  }
}
function spotit_success() { spotit_move(G, U.name, true); }
function spotit_test1(g, dParent, uname) {
  console.log('from server:', g, dParent, uname);
  spotit_present(g, dParent, uname)
}
function spotitCard(info, dParent, cardStyles, onClickSym) {
  let styles = copyKeys({ w: Card.sz, h: Card.sz }, cardStyles);
  let card = cRound(dParent, cardStyles, info.id);
  addKeys(info, card);
  let d = iDiv(card);
  card.pattern = fillColarr(card.colarr, card.keys);
  let symStyles = { sz: Card.sz / (card.rows + 1), fg: 'random', hmargin: 8, vmargin: 4, cursor: 'pointer' };
  let syms = [];
  mRows(iDiv(card), card.pattern, symStyles, { 'justify-content': 'center' }, { 'justify-content': 'center' }, syms);
  for (let i = 0; i < info.keys.length; i++) {
    let key = card.keys[i];
    let sym = syms[i];
    card.live[key] = sym;
    sym.setAttribute('key', key);
    sym.onclick = onClickSym;
  }
  return card;
}
function spotitDeal(rows, cols, numCards, setName) {
  let colarr = _calc_hex_col_array(rows, cols);
  let perCard = arrSum(colarr);
  let nShared = (numCards * (numCards - 1)) / 2;
  let nUnique = perCard - numCards + 1;
  let keys = choose(oneWordKeys(KeySets[setName]), nShared + numCards * nUnique);
  let dupls = keys.slice(0, nShared);
  let uniqs = keys.slice(nShared);
  let infos = [];
  for (let i = 0; i < numCards; i++) {
    let keylist = uniqs.slice(i * nUnique, i * nUnique + nUnique);
    let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols: cols, colarr: colarr };
    infos.push(info);
  }
  let iShared = 0;
  for (let i = 0; i < numCards; i++) {
    for (let j = i + 1; j < numCards; j++) {
      let c1 = infos[i];
      let c2 = infos[j];
      let dupl = dupls[iShared++];
      c1.keys.push(dupl);
      c1.shares[c2.id] = dupl;
      c2.shares[c1.id] = dupl;
      c2.keys.push(dupl);
    }
  }
  for (const info of infos) { shuffle(info.keys); }
  return infos;
}
function spotitFindCardSharingSymbol(card, key) {
  let id = firstCondDict(card.shares, x => x == key);
  return Items[id];
}
function spotitFindSymbol(card, key) { let k = firstCondDictKey(card.live, x => x == key); return card.live[k]; }
function spotitOnClickSymbol(ev) {
  let keyClicked = evToProp(ev, 'key');
  let id = evToId(ev);
  if (isdef(keyClicked) && isdef(Items[id])) {
    let item = Items[id];
    console.log('clicked key', keyClicked, 'of card', id, item);
    if (Object.values(item.shares).includes(keyClicked)) {
      console.log('success!!!');
      let otherCard = spotitFindCardSharingSymbol(item, keyClicked);
      let cardSymbol = ev.target;
      let otherSymbol = spotitFindSymbol(otherCard, keyClicked);
      Selected = { success: true, feedbackUI: [cardSymbol, otherSymbol] };
    } else {
      console.log('fail!!!!!!!!');
      let cardSymbol = ev.target;
      Selected = { success: false, feedbackUI: [cardSymbol] };
    }
  }
}
function spread_hand(path, ov) {
  let hand = lookup(UI, path.split('.'));
  assertion(hand, 'hand does NOT exist', path);
  if (hand.ctype != 'hand') return;
  if (isEmpty(hand.items)) return;
  let card = hand.items[0];
  if (nundef(ov)) ov = card.ov;
  if (hand.ov == ov) return;
  hand.ov = ov;
  let cont = hand.cardcontainer;
  let items = hand.items;
  mContainerSplay(cont, hand.splay, card.w, card.h, items.length, ov * card.w);
}
function Sprite(scene, imageFile, width, height) {
  this.canvas = scene.canvas;
  this.context = this.canvas.getContext("2d");
  this.image = new Image();
  this.image.src = imageFile;
  this.animation = false;
  this.width = width;
  this.height = height;
  this.cHeight = parseInt(this.canvas.height);
  this.cWidth = parseInt(this.canvas.width);
  this.x = 200;
  this.y = 200;
  this.dx = 10;
  this.dy = 0;
  this.imgAngle = 0;
  this.moveAngle = 0;
  this.speed = 10;
  this.camera = false;
  this.setPosition = function (x, y) {
    this.x = x;
    this.y = y;
  }
  this.setX = function (nx) { this.x = nx; }
  this.setY = function (ny) { this.y = ny; }
  this.setChangeX = function (ndx) { this.dx = ndx; }
  this.setChangeY = function (ndy) { this.dx = ndx; }
  this.changeXby = function (tdx) { this.x += tdx };
  this.changeYby = function (tdy) { this.y += tdy };
  this.draw = function () {
    ctx = this.context;
    ctx.save();
    if (this.camera) { ctx.translate(this.x - this.camera.cameraOffsetX, this.y - this.camera.cameraOffsetY); }
    else { ctx.translate(this.x, this.y); }
    ctx.rotate(this.imgAngle);
    if (this.animation != false) {
      this.animation.drawFrame(ctx);
    }
    else {
      ctx.drawImage(this.image,
        0 - (this.width / 2),
        0 - (this.height / 2),
        this.width, this.height);
    }
    ctx.restore();
  }
  this.update = function () {
    this.x += this.dx;
    this.y += this.dy;
    this.checkBounds();
    this.draw();
  }
  this.checkBounds = function () {
    camX = 0;
    camY = 0;
    if (this.camera) { camX = this.camera.cameraOffsetX; camY = this.camera.cameraOffsetY; }
    rightBorder = this.cWidth + camX;
    leftBorder = camX;
    topBorder = camY;
    bottomBorder = this.cHeight + camY;
    if (this.x > rightBorder) {
      this.x = leftBorder;
    }
    if (this.y > bottomBorder) {
      this.y = topBorder;
    }
    if (this.x < leftBorder) {
      this.x = rightBorder;
    }
    if (this.y < topBorder) {
      this.y = bottomBorder;
    }
  }
  this.loadAnimation = function (imgWidth, imgHeight, cellWidth, cellHeight) {
    this.animation = new Animation(this.image, imgWidth, imgHeight, cellWidth, cellHeight);
    this.animation.setup();
  }
  this.generateAnimationCycles = function (slicingFlag, framesArray) {
    cWidth = this.animation.cellWidth;
    cHeight = this.animation.cellHeight;
    iWidth = this.animation.imgWidth;
    iHeight = this.animation.imgHeight;
    numCycles = 0;
    nextStartingFrame = 0;
    if (typeof framesArray == "number" || typeof slicingFlag == "undefined") {
      if (slicingFlag == SINGLE_COLUMN) { numCycles = (iHeight / cHeight) / framesArray; }
      else if (typeof slicingFlag == "undefined") { numCycles = (iHeight / cHeight); framesArray = iWidth / cWidth; }
      else { numCycles = (iWidth / cWidth) / framesArray; }
      for (i = 0; i < numCycles; i++) {
        cycleName = "cycle" + (i + 1);
        this.specifyCycle(cycleName, i * framesArray, framesArray);
      }
    }
    else {
      numCycles = framesArray.length;
      for (i = 0; i < numCycles; i++) {
        cycleName = "cycle" + (i + 1);
        this.specifyCycle(cycleName, nextStartingFrame, framesArray[i]);
        nextStartingFrame += framesArray[i];
      }
    }
    this.setCurrentCycle("cycle1");
  }
  this.renameCycles = function (cycleNames) { this.animation.renameCycles(cycleNames); }
  this.specifyCycle = function (cycleName, startingCell, frames) { this.animation.addCycle(cycleName, startingCell, frames); }
  this.specifyState = function (stateName, cellName) { this.animation.addCycle(stateName, cellName, 1); }
  this.setCurrentCycle = function (cycleName) { this.animation.setCycle(cycleName); }
  this.pauseAnimation = function () { this.animation.pause(); }
  this.playAnimation = function () { this.animation.play(); }
  this.resetAnimation = function () { this.animation.reset(); }
  this.setAnimationSpeed = function (speed) { this.animation.setAnimationSpeed(speed); }
  this.calcVector = function () {
    this.dx = this.speed * Math.cos(this.moveAngle);
    this.dy = this.speed * Math.sin(this.moveAngle);
  }
  this.setSpeed = function (speed) {
    this.speed = speed;
    this.calcVector();
  }
  this.changeSpeedBy = function (diff) {
    this.speed += diff;
    this.calcVector();
  }
  this.setImgAngle = function (degrees) {
    degrees = degrees - 90;
    this.imgAngle = degrees * Math.PI / 180;
  }
  this.changeImgAngleBy = function (degrees) {
    rad = degrees * Math.PI / 180;
    this.imgAngle += rad;
  }
  this.setMoveAngle = function (degrees) {
    degrees = degrees - 90
    this.moveAngle = degrees * Math.PI / 180;
    this.calcVector();
  }
  this.changeMoveAngleBy = function (degrees) {
    diffRad = degrees * Math.PI / 180;
    this.moveAngle += diffRad;
    this.calcVector();
  }
  this.setAngle = function (degrees) {
    this.setMoveAngle(degrees);
    this.setImgAngle(degrees);
  }
  this.changeAngleBy = function (degrees) {
    this.changeMoveAngleBy(degrees);
    this.changeImgAngleBy(degrees);
  }
  this.collidesWith = function (sprite) {
    myLeft = this.x;
    myRight = this.x + this.width;
    myTop = this.y;
    myBottom = this.y + this.height;
    otherLeft = sprite.x;
    otherRight = sprite.x + sprite.width;
    otherTop = sprite.y;
    otherBottom = sprite.y + sprite.height;
    collision = true;
    if ((myBottom < otherTop) ||
      (myTop > otherBottom) ||
      (myRight < otherLeft) ||
      (myLeft > otherRight)) {
      collision = false;
    }
    return collision;
  }
  this.setCameraRelative = function (cam) { this.camera = cam; }
  this.report = function () {
    console.log("x: " + this.x + ", y: " + this.y + ", dx: "
      + this.dx + ", dy: " + this.dy
      + ", speed: " + this.speed
      + ", angle: " + this.moveAngle);
  }
}
function SQ120(sq64) { return Sq64ToSq120[(sq64)]; }
function SQ64(sq120) { return Sq120ToSq64[(sq120)]; }
function SqAttacked(sq, side) {
  var pce;
  var t_sq;
  var index;
  if (side == COLOURS.WHITE) {
    if (brd_pieces[sq - 11] == PIECES.wP || brd_pieces[sq - 9] == PIECES.wP) {
      return BOOL.TRUE;
    }
  } else {
    if (brd_pieces[sq + 11] == PIECES.bP || brd_pieces[sq + 9] == PIECES.bP) {
      return BOOL.TRUE;
    }
  }
  for (index = 0; index < 8; ++index) {
    pce = brd_pieces[sq + KnDir[index]];
    if (pce != SQUARES.OFFBOARD && PieceKnight[pce] == BOOL.TRUE && PieceCol[pce] == side) {
      return BOOL.TRUE;
    }
  }
  for (index = 0; index < 4; ++index) {
    dir = RkDir[index];
    t_sq = sq + dir;
    pce = brd_pieces[t_sq];
    while (pce != SQUARES.OFFBOARD) {
      if (pce != PIECES.EMPTY) {
        if (PieceRookQueen[pce] == BOOL.TRUE && PieceCol[pce] == side) {
          return BOOL.TRUE;
        }
        break;
      }
      t_sq += dir;
      pce = brd_pieces[t_sq];
    }
  }
  for (index = 0; index < 4; ++index) {
    dir = BiDir[index];
    t_sq = sq + dir;
    pce = brd_pieces[t_sq];
    while (pce != SQUARES.OFFBOARD) {
      if (pce != PIECES.EMPTY) {
        if (PieceBishopQueen[pce] == BOOL.TRUE && PieceCol[pce] == side) {
          return BOOL.TRUE;
        }
        break;
      }
      t_sq += dir;
      pce = brd_pieces[t_sq];
    }
  }
  for (index = 0; index < 8; ++index) {
    pce = brd_pieces[sq + KiDir[index]];
    if (pce != SQUARES.OFFBOARD && PieceKing[pce] == BOOL.TRUE && PieceCol[pce] == side) {
      return BOOL.TRUE;
    }
  }
  return BOOL.FALSE;
}
function SqFromAlg(moveAlg) {
  if (moveAlg.length != 2) return SQUARES.NO_SQ;
  if (moveAlg[0] > 'h' || moveAlg[0] < 'a') return SQUARES.NO_SQ;
  if (moveAlg[1] > '8' || moveAlg[1] < '1') return SQUARES.NO_SQ;
  file = moveAlg[0].charCodeAt() - 'a'.charCodeAt();
  rank = moveAlg[1].charCodeAt() - '1'.charCodeAt();
  return FR2SQ(file, rank);
}
function SQOFFBOARD(sq) { if (FilesBrd[sq] == SQUARES.OFFBOARD) return BOOL.TRUE; return BOOL.FALSE; }
function sss() { show_playerdatastate(); }
function sss1() {
  let [fen, A, uplayer, plorder, data] = [Z.fen, Z.A, Z.uplayer, Z.plorder, Z.uplayer_data];
  let s = 'no data.state for player ' + uplayer;
  if (isDict(data.state)) {
    s = `${uplayer} passes `;
    for (const k in data.state.di) {
      s += `${k} ${data.state.di[k]}, `;
    }
  }
  console.log(s);
}
function stabilizeBodyZoom() {
  if (Math.abs(bodyZoom - 1) < .2) bodyZoom = 1;
}
function stadtland_accept(fen, plname) {
  let message = `${plname} has accepted`;
  arrRemovip(fen.turn, plname);
  fen.players[plname].hasAccepted = true;
  if (isEmpty(fen.turn)) { stadtland_newround(fen, true); }
  sendmove(plname, fen);
}
function stadtland_answer(fen, plname) {
  let move = stadtland_createmove(fen, plname);
  let islegal = stadtland_evalmove(fen, plname, move);
  if (islegal) {
    fen.move = move;
    let message = `${move.uname} has answered first: `;
    for (const k in move.data) {
      message += `<div>${k}: ${move.data[k]}</div>`;
      fen.players[plname].answer[k] = move.data[k];
    }
    fen.first = plname;
    fen.content = message;
    fen.phase = 'accept';
    arrRemovip(fen.turn, plname);
    sendmove(plname, fen, true);
  } else {
    show_instruction('your move is not complete!')
  }
}
function stadtland_createmove(fen, plname) {
  let inputs = dParent.getElementsByTagName('input');
  let move = { uname: U.name, table: G.name, data: {} };
  for (const inp of inputs) {
    if (fen.cats.includes(inp.name)) {
      move.data[inp.name] = inp.value;
    }
  }
  return move;
}
function stadtland_evalmove(fen, plname, move) {
  for (const cat of fen.cats) {
    if (isEmpty(move.data[cat])) move.data[cat] = 'hallo';
  }
  return true;
}
function stadtland_newround(fen, score) {
  fen.phase = "create";
  fen.turn = jsCopy(fen.plorder);
  fen.round = [];
  fen.letter = rLetter(fen.letters);
  lookupAddToList(fen, ['letters'], fen.letter);
  fen.instruction = 'complete each category, then click DONE!';
  if (score && isdef(fen.first)) fen.players[fen.first].score += 1;
  for (const uname of fen.plorder) {
    for (const cat of fen.cats) fen.players[uname].answer[cat] = '';
  }
  delete fen.first;
  delete fen.move;
  delete fen.message;
}
function stadtland_present(fen, dParent, plname) {
  if (fen.phase == 'create') {
    let d1 = mDiv(dParent, { w: 400, align: 'left' }, null, `<h1>letter: ${fen.letter.toUpperCase()}</h1>`);
    for (const cat of fen.cats) {
      mLinebreak(d1, 10);
      let html = `
      <div style="display:inline-block;width:150px">${cat.toUpperCase()}:</div>
      <input class:'input' style="width:150px" type='text' name="${cat}">
      `;
      let d2 = mDiv(d1, {}, null, html);
    }
    let d2 = mDiv(d1, { w: '100%', padding: 20 });
    mButton('SUBMIT', () => interaction(fen, plname, stadtland_answer), d2, {}, 'button', 'bSendMove');
  } else if (fen.phase == 'accept') {
    let d1 = mDiv(dParent, { w: 400, align: 'left' }, null, `<h1>${fen.content}</h1>`);
    let d2 = mDiv(d1, { w: '100%', padding: 20 });
    if (!fen.turn.includes(plname)) return;
    mButton('ACCEPT', () => interaction(fen, plname, stadtland_accept), d2, { hmargin: 20 }, 'button');
    mButton('REJECT', () => interaction(fen, plname, stadtland_reject), d2, {}, 'button');
  }
}
function stadtland_reject(fen, plname) {
  let winner = fen.first;
  stadtland_newround(fen, false);
  fen.status = `last solution from ${winner} was rejected by ${plname}`;
  sendmove(fen, plname);
}
function stadtland_setup(players) {
  let fen = {};
  fen.cats = rChoose(['stadt', 'land', 'tier', 'name', 'plant', 'sport', 'object', 'brand', 'dessert', 'vegetable', 'fruit', 'profession', 'hobby', 'noun', 'emotion', 'landmark'], 4);
  fen.players = {};
  fen.plorder = rPlayerOrder(players);
  fen.letters = ['q', 'x', 'y'];
  for (const uname of players) {
    let pl = fen.players[uname] = { answer: {}, score: 0 };
  }
  stadtland_newround(fen, false);
  return fen;
}
function stage_building(fen, i_pl, type) {
  let n = type == 'chateau' ? 6 : type == 'estate' ? 5 : 4;
  type += 's';
  let uname = fen.plorder[i_pl];
  fen.players[uname].buildings[type].push({ list: deck_deal(fen.deck, n), h: null });
}
function stage_building_new(fen, i_pl, type, n_openschwein, n_closedschwein) {
  let n = type == 'chateau' ? 6 : type == 'estate' ? 5 : 4;
  let plname = fen.plorder[i_pl];
  lookupSet(fen.players[plname], ['buildings', type], []);
  let building = { list: deck_deal(fen.deck, 1), h: null, type: type, schweine: [] };
  let k = building.lead = building.list[0];
  let other = k[0] == 'Q' ? '2' : 'Q';
  let i, j;
  for (i = 1; i <= n_openschwein; i++) { building.schweine.push(i); building.list.push(other + rSuit('CSHD') + 'n'); }
  for (j = 1; j <= n_closedschwein; j++) { building.list.push(other + rSuit('CSHD') + 'n'); }
  while (building.list.length < n) { building.list.push(k); j++; }
  fen.players[plname].buildings[type].push(building);
  return building;
}
function stage_correct_buildings(fen, o) {
  let ranks = toLetters(RANKS);
  let irank = 0;
  for (const uname in o) {
    let pl = fen.players[uname];
    let bo = pl.buildings;
    let dinums = o[uname];
    for (const type in dinums) {
      let n = dinums[type];
      for (let i = 0; i < n; i++) {
        let r = ranks[irank]; irank++;
        let s = type == 'farms' ? `${r}Cy ${r}Sy ${r}Sy ${r}Dy` :
          type == 'estates' ? `${r}Cy ${r}Sy ${r}Sy ${r}Dy ${r}Cg` : `${r}Cy ${r}Sy ${r}Sy ${r}Dy ${r}Cg ${r}Hg`;
        bo[type].push({ list: s.split(' '), h: null });
      }
    }
  }
}
function stage_moves() {
  for (const a of arguments) {
    let [uname, x, cardname] = a.split('.');
    DA.chain.push(() => {
      let g = Session;
      let state = { selected: {} };
      state.selected[uname] = [a];
      let o = { uname: uname, tid: g.table.id, state: state, player_status: 'joined' };
      to_server(o, 'turn_update');
    })
  }
}
function stage1_makeUis(omap, objectPool, w, h, gap, domelFunc) {
  let olist = mapOMap(omap, objectPool);
  if (isEmpty(olist)) return null;
  let otrans = olist;
  let uis = getUis(otrans, domelFunc(w, h));
  return uis;
}
function stage2_prepArea(area) { let d = mBy(area); mClass(d, 'flexWrap'); return d; }
function stage3_prepContainer(area) { let container = mDiv(area); mPosRel(container); return container; }
function stage4_layout(uis, container, w, h, gap, layoutFunc) {
  let [wTotal, hTotal] = layoutFunc(uis, container, w, h, gap);
  mStyle(container, { width: wTotal, height: hTotal, 'border-radius': gap });
}
function standardize_color(str) {
  var c = document.createElement('canvas').getContext('2d');
  c.fillStyle = str;
  return c.fillStyle;
}
async function start() {
  initCodingUI();
  let [g, text, old] = await codebaseExtendFromProject('coding');
  AU.ta.value = text; 
}
function start_advanced() {
  dTable = mBy('dTable'); dTitle = mBy('dTitle');
  show('dTopAdvanced');
  show_tables();
  show_games();
  show_title();
  show_home_logo();
  dTitle.animate([{ opacity: 0 }, { opacity: 1 },], { fill: 'both', duration: 1000, easing: 'ease-in' });
  dTable = mBy('dTable');
  show_users();
  if (!isEmpty(Serverdata.tables)) onclick_game_in_gametable(Serverdata.tables[0].friendly);
}
function start_bots(obj) {
  if (is_admin() && DA.is_first_move == true) {
    DA.bots = [];
    let bots = { bob: 5000 };
    for (const botname in bots) {
      if (obj.table.players.includes(botname)) { start_poll_bot_send_move(botname, bots[botname]); }
    }
  }
  DA.is_first_move = false;
}
function start_challenge1() {
  DA.challenge = 1;
  DA.name = 'Login';
  scrollToTop();
  onclick_location('boa');
}
function start_challenge2() {
  DA.challenge = 2;
  DA.name = 'Bill Pay';
  scrollToTop();
  boamain_start();
  show_bill_button();
}
function start_challenge3() {
  DA.challenge = 3;
  DA.name = 'Full Bill Pay';
  scrollToTop();
  onclick_location('boa');
}
function start_challenge4() {
  DA.challenge = 4;
  DA.name = 'Password';
  scrollToTop();
  if (S.bw_state == 'loggedin') toggle_bw_symbol();
  S.bw_state = (coin(25) || !S.master_password) ? 'expired' : 'loggedout';
}
function start_chat(e) {
  e.preventDefault(); e.cancelBubble = true;
  var username = e.target.getAttribute("username");
  if (e.target.id == "") {
    username = e.target.parentNode.getAttribute("username");
  }
  CURRENT_CHAT_USER = username;
  get_chats();
  mBy("radio_chat").checked = true;
}
function start_creeping_down() {
  for (const k in Z.fen) {
    set_new_goal(k, 0);
  }
}
function start_downgrade_ticker() {
  TO.main = setTimeout(degrade_bars, 5000);
}
function start_game() {
  let gamename = DA.gamename;
  let options = collect_game_specific_options(gamename);
  let players = DA.playerlist ? DA.playerlist.map(x => ({ name: x.uname, playmode: x.playmode, strategy: valf(x.strategy, options.strategy, 'random') })) : create_random_players(options.nplayers);
  _start_game(gamename, players, options); hide('dMenu');
}
async function start_leaflet() {
  TESTING = 'nosockets';
  if (TESTING != 'nosockets') {
    Socket = TESTING == 'live' ? io('http://127.0.0.1:3000') : TESTING == 'nginx' ? io('http://216.250.112.218:3000') : io();
    Socket.on('message', x => console.log('got message', x));
    Socket.on('disconnect', x => console.log('got disconnect', x));
    Socket.on('update', x => console.log('got update', x));
  }
  var cities = L.layerGroup();
  var mLittleton = L.marker([39.61, -105.02]).bindPopup('This is Littleton, CO.').addTo(cities);
  var mDenver = L.marker([39.74, -104.99]).bindPopup('This is Denver, CO.').addTo(cities);
  var mAurora = L.marker([39.73, -104.8]).bindPopup('This is Aurora, CO.').addTo(cities);
  var mGolden = L.marker([39.77, -105.23]).bindPopup('This is Golden, CO.').addTo(cities);
  var mbAttr = 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>';
  var mbUrl = 'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw';
  var streets = L.tileLayer(mbUrl, { id: 'mapbox/streets-v11', tileSize: 512, zoomOffset: -1, attribution: mbAttr });
  var osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
  });
  var map = L.map('map', {
    center: [39.73, -104.99],
    zoom: 10,
    layers: [osm, cities]
  });
  var baseLayers = {
    'OpenStreetMap': osm,
    'Streets': streets
  };
  var overlays = {
    'Cities': cities
  };
  var layerControl = L.control.layers(baseLayers, overlays).addTo(map);
  var crownHill = L.marker([39.75, -105.09]).bindPopup('This is Crown Hill Park.');
  var rubyHill = L.marker([39.68, -105.00]).bindPopup('This is Ruby Hill Park.');
  var parks = L.layerGroup([crownHill, rubyHill]);
  var satellite = L.tileLayer(mbUrl, { id: 'mapbox/satellite-v9', tileSize: 512, zoomOffset: -1, attribution: mbAttr });
  layerControl.addBaseLayer(satellite, 'Satellite');
  layerControl.addOverlay(parks, 'Parks');
}
function start_loop() {
  TO.running = setInterval(() => {
    for (const item of G.items) {
    }
  }, 100);
}
function start_new_round_ferro() {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  let pl = fen.players[uplayer];
  Z.stage = 'card_selection';
  fen.plorder = arrCycle(plorder, 1);
  let starter = fen.plorder[0];
  Z.turn = fen.turn = [starter];
  let deck = fen.deck = create_fen_deck('n', fen.num_decks, fen.num_decks * 4);
  let deck_discard = fen.deck_discard = [];
  shuffle(deck);
  let handsize = valf(Number(Z.options.handsize), 11);
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand = deck_deal(deck, plname == starter ? handsize + 1 : handsize);
    pl.journeys = [];
    pl.roundgoal = false;
    pl.roundchange = true;
    delete pl.handsorting;
  }
  Z.round += 1;
  if (Z.round > Z.options.maxrounds) {
    ari_history_list([`game over`], 'game');
    Z.stage = 'game_over';
    fen.winners = find_players_with_min_score();
  }
}
function start_new_todo_list(otree, r) {
  let i_last = otree.plorder.indexOf(r.uname);
  let i_next = (i_last + 1) % otree.plorder.length;
  otree.todo = inno_todo_regular(otree, otree.plorder[i_next]);
}
function start_poll_bot_send_move(botname = 'bob', ms = 3000) {
  DA.bots.push(botname);
  if (DB.games[Session.cur_game].game_type == 'race') {
    let o = { tid: Session.cur_tid, player_status: 'joined', score: 0, state: 'bot', uname: botname };
    start_polling(o, 'poll_bot_send_move', on_poll_bot_send_move, ms, create_ai_move);
  } else {
  }
}
function start_polling(data, type, onsuccess, ms = 5000, func) {
  delete DA.poll; allow_polling();
  DA.poll = {
    data: data,
    type: type,
    onsuccess: onsuccess,
    ms: ms,
    func: func
  };
  poll();
}
function start_prelims() {
  Speech = new Speaker('E');
  TOMan = new TimeoutManager();
  ColorThiefObject = new ColorThief();
  init_internet();
  init_keyhandlers();
  mBy('label_games').onclick = onclick_games;
  mBy('label_play').onclick = onclick_play;
  mBy('label_account').onclick = onclick_account;
  mBy('label_login').onclick = onclick_login;
  mBy('label_settings').onclick = onclick_settings;
  Session.cur_user = valf(queryStringToJson().user, 'guest');
  Session.cur_menu = 'games';
  Session.cur_game = 'gSpotit';
  Session.def_playmode = 'multi';
  Session.def_players = ['mimi', 'felix'];
  Session.def_players = ['mimi', 'afia', 'amanda', 'annabel', 'blade', 'felix', 'gul', 'lauren', 'mac', 'nasi', 'sarah', 'valerie'];
  Session.cur_chatter = 'gul';
  go_online();
  get_data(queryStringToJson(), 'user_info');
}
function start_simple() {
  let uname = localStorage.getItem('uname');
  if (isdef(uname)) onclick_user(uname); else show_users();
}
function start_simple_ack_round(ackstage, ack_players, nextplayer, callbackname_after_ack, keeppolling = false) {
  let fen = Z.fen;
  fen.ack_players = ack_players;
  fen.lastplayer = arrLast(ack_players);
  fen.nextplayer = nextplayer;
  fen.turn_after_ack = [nextplayer];
  fen.callbackname_after_ack = callbackname_after_ack;
  fen.keeppolling = keeppolling;
  Z.stage = ackstage;
  Z.turn = [ack_players[0]];
}
function start_simple_timer(dtimer, msInterval, onTick, msTotal, onElapsed) {
  if (isdef(DA.timer)) { DA.timer.clear(); DA.timer = null; }
  let timer = DA.timer = new SimpleTimer(dtimer, msInterval, onTick, msTotal, onElapsed);
  timer.start();
}
function start_sound() { }
function start_table(uname, tid) {
  to_server({ uname: uname, tid: tid }, 'start_table');
}
function start_table_dep(tid) {
  let t = DB.tables[tid];
  Session.cur_tid = tid;
  t.status = 'started';
  t.moves = {};
  t.players.map(x => t.moves[x] = []);
  makemove(t);
}
function start_tests() {
  fentest_wise();
}
function start_transaction() {
  if (DA.simulate) return;
  DA.simulate = true;
  DA.snapshot = { fen: jsCopy(Z.fen), stage: Z.stage, round: Z.round, phase: Z.phase, turn: Z.turn };
  DA.transactionlist = [];
}
function start_with_assets() {
  DA.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1; if (DA.isFirefox) console.log('using Firefox!')
  show_home_logo();
  if (nundef(U)) { show_users(); return; }
  show_username();
  if (DA.TEST0) show('dTestButtons');
}
function start_with_basic_assets() {
  if (is_admin()) {
    hide('dIntro');
    let user = load_user(Session.cur_user);
    loader_off();
    DA.next = get_dictionary();
    get_games();
    show('b_polling');
  } else {
    close_sidebar();
    mBy('user_info_mini').style.display = 'flex';
    mBy('b_toggle_sidebar').style.display = 'none';
    show('dIntro');
    get_intro();
  }
}
async function start0() {
  TESTING = 'nosockets';
  if (TESTING != 'nosockets') {
    Socket = TESTING == 'live' ? io('http://127.0.0.1:3000') : TESTING == 'nginx' ? io('http://216.250.112.218:3000') : io();
    Socket.on('message', x => console.log('got message', x));
    Socket.on('disconnect', x => console.log('got disconnect', x));
    Socket.on('update', x => console.log('got update', x));
  }
  let [citylist, capitals] = [M.cities, M.capitals] = await get_cities_and_capitals();
  await load_syms();
  let list = dict2list(citylist).filter(x => x.pop > 1000000 && x.type == 'capital');
  console.log('list', list);
  let cities = M.layers.cities = L.layerGroup();
  let markers = M.markers = [];
  for (const c of list) {
    let m = L.marker(c.center).bindPopup(c.name);
    addKeys(c, m);
    markers.push(m);
  }
  M.layers = {};
  cities.type == 'overlay';
  let osm = M.layers.osm = get_layer('osm', { opacity: 1, type: 'base' });
  let map = M.map = L.map('map', { center: Geo.places.tuerkenschanzpark, zoom: 2, layers: [osm, cities] });
  var baseMaps = { osm: osm };
  var overlayMaps = { cities: citylist };
  var layerControl = M.layer_control = L.control.layers(baseMaps, overlayMaps).addTo(map);
  return;
  let players = [{ name: 'felix', city: 'Paris' }, { name: 'amanda', city: 'Vienna' }, { name: 'mimi', city: 'Madrid' }];
  M.markers = {};
  players.map(x => M.markers[x.name] = get_marker(map, citylist[x.city].center, { user: x.name, draggable: true }));
  map.on('zoomend', ev => {
    let x = ev.target;
    dZoom.innerHTML = 'zoom: ' + x.getZoom();
  });
  console.log('marker in geojson: ', M.markers.felix.toGeoJSON());
  map.on('click', function (e) {
    document.getElementById('dPosition').innerHTML =
      "Lat, Lon : " + e.latlng.lat + ", " + e.latlng.lng;
  });
  L.streetView({ position: 'topleft', mapillaryId: 'RC1ZRTBfaVlhWmJmUGVqRk5CYnAxQTpmMGE3OTU0MzM0MTljZTA4' }).addTo(map);
  var marker = L.marker(map.getCenter()).addTo(map);
  map.on('move', function () { marker.setLatLng(map.getCenter()); });
}
function startBlinking(item, items, unique = true) {
  if (unique) {
    let prevLetter = firstCond(items, x => x.isBlinking == true);
    stopBlinking(prevLetter);
  }
  mClass(iDiv(item), 'blink');
  item.isBlinking = true;
}
function StartChessGame() {
  InitFilesRanksBrd();
  InitSq120To64();
  InitHashKeys();
  InitBoardVars();
  InitMvvLva();
  InitBoardSquares();
  EvalInit();
  srch_thinking = BOOL.FALSE;
  $('#fenIn').val(START_FEN);
  NewGame();
  NewGameAjax();
}
async function startClientTest() {
  hide('dMainContent');
  show('dGameScreen');
  setTitle('*** Testing ***');
  setSubtitle('logged in as ' + Username);
  mStyleX(document.body, { opacity: 1 });
  initTable(null, 2); initSidebar(); initAux(); initScore();
  runClientTest();
}
function startgame(game, players, options = {}) {
  if (nundef(game)) game = 'a_game';
  let default_options = {}; for (const k in Config.games[game].options) default_options[k] = arrLast(Config.games[game].options[k].split(','));
  addKeys(default_options, options);
  if (nundef(players)) players = rChoose(Serverdata.users, 2).map(x => ({ name: x.name }));
  let playernames = players.map(x => x.name);
  let fen = window[game]().setup(playernames, options);
  if (nundef(fen.round)) fen.round = 1;
  if (nundef(fen.phase)) fen.phase = '';
  if (nundef(fen.stage)) fen.stage = 0;
  if (nundef(fen.step)) fen.step = 0;
  if (nundef(fen.turn)) fen.turn = [fen.plorder[0]]; else if (DA.TESTSTART1 && fen.turn.length == 1) fen.turn = [playernames[0]];
  players.map(x => { let pl = fen.players[x.name]; pl.playmode = valf(x.playmode, 'human'); pl.strategy = valf(x.strategy, valf(options.strategy, 'random')); });
  if (options.mode == 'solo') {
    let me = isdef(U) && isdef(fen.players[U.name]) ? U.name : rChoose(playernames);
    for (const plname of playernames) {
      if (plname == me) continue;
      fen.players[plname].playmode = 'bot';
    }
    options.mode = 'hotseat';
  }
  for (const k in options) { if (isNumber(options[k])) options[k] = parseInt(options[k]); }
  let o = {
    friendly: generate_table_name(players.length), game: game, host: playernames[0], players: playernames,
    fen: fen, options: options
  };
  ensure_polling();
  phpPost(o, 'startgame');
}
function startGame() {
  meme = new component(30, 30, 'red', 10, 120);
  meme.gravity = 0.05;
  score = new component('30px', 'Consolas', 'black', 280, 40, 'text');
  myGameArea.start();
}
function startGameML() { }
function startGameSP() { }
function startGameSPA() { }
function startGameTC() { }
function startGameTP() { }
function startGameWP() {
  onkeydown = ev => {
    if (uiPaused) return;
    if (isdef(inputBox)) { inputBox.focus(); }
  }
}
function startingSetup() { }
function startInteraction() {
  boatFilters = [];
  if (isdef(IdOwner.a)) IdOwner.a.map(x => _addStandardInteraction(x));
  if (isdef(IdOwner.l)) IdOwner.l.map(x => _addStandardInteraction(x));
  if (isdef(IdOwner.p)) IdOwner.p.map(x => _addStandardInteraction(x));
  if (isdef(IdOwner.r)) IdOwner.r.map(x => _addStandardInteraction(x));
  if (isdef(IdOwner.t)) IdOwner.t.map(x => _addStandardInteraction(x));
  _preselectFirstVisualsForBoats();
  choiceCompleted = false;
  let nBoats = getBoatIds().length;
  let autoplay = S_autoplayFunction(G) || nBoats < 2 || robbedDescInBoats();
  if (autoplay) {
    setTimeout(onClickStep, S_AIThinkingTime);
    return;
  } else if (!isEmpty(scenarioQ)) {
    let func = scenarioQ.shift();
    func();
  } else {
    scenarioRunning = false;
    setAutoplayFunctionForMode();
    unfreezeUI();
  }
}
function startLevel() {
  Speech.setLanguage(Settings.language);
  getGameValues(Username, G.id, G.level);
  G.instance.startLevel();
  if (G.keys.length < G.numPics) { updateKeySettings(G.numPics + 5); }
  startRound();
}
function startLevelML() { levelML(); }
function startLevelSP() { levelSP(); }
function startLevelSPA() { levelSPA(); }
function startLevelTC() { levelTC(); }
function startLevelTP() { levelTP(); }
function startLevelWP() { levelWP(); }
async function startloading() {
  let path = `${Basepath}/DB.yaml`;
  var DB = await route_path_yaml_dict(path);
}
function startloop() { FR = 30; DA.interval = setInterval(update_draw_items, 1000 / FR) }
function startPulsating(item, items, unique = true) {
  if (unique) {
    let prevLetter = firstCond(items, x => x.isPulsating == true);
    stopPulsating(prevLetter);
  }
  mClass(iDiv(item), 'onPulse');
  item.isPulsating = true;
}
function startQRunner() {
  if (QRunnerRunning) return;
  QRunnerRunning = true;
  QRunner();
}
function startRound() {
  if (G.addonActive != true && isTimeForAddon()) {
    G.addonActive = true;
    exitToAddon(startRound); return;
  } else G.addonActive = false;
  resetRound();
  uiActivated = false;
  G.instance.startRound();
  TOMain = setTimeout(() => prompt(), 300);
}
function startRoundML() { }
function startRoundReally() {
  clearFleetingMessage();
  showStats();
  LevelChange = false;
  if (ROUND_OUTPUT) {
  }
  trialNumber = 0;
  GFUNC[currentGame].startRound();
  promptStart();
}
function startRoundSP() { }
function startRoundSPA() { }
function startRoundTC() {
  uiActivatedTC = false;
}
function startRoundTP() {
  uiActivated = false;
}
function startRoundWP() { }
function StartSearch() {
  srch_depth = MAXDEPTH;
  var t = $.now();
  var tt = $('#ThinkTimeChoice').val();
  if (nundef(tt)) tt = 6;
  srch_time = parseInt(tt) * 1000;
  SearchPosition();
  StopThinking();
  if (FLAG_HINT_ONLY) {
    FLAG_HINT_ONLY = false;
    let info = Move2FromTo(srch_best);
    let sq = info.from.sq;
    HintAnimation(sq, 1000);
  } else {
    MakeMove(srch_best);
    MoveGUIPiece(srch_best);
    CheckAndSet();
  }
}
function startsWith(s, sSub) {
  return s.substring(0, sSub.length) == sSub;
}
function startsWithCaseIn(s, ssub) {
  return startsWith(s.toLowerCase(), ssub.toLowerCase());
}
function startsWithCaseIndep(s, ssub) {
  return startsWith(s.toLowerCase(), ssub.toLowerCase());
}
function startsWithCaseInsensitive(s, ssub) {
  return startsWith(s.toLowerCase(), ssub.toLowerCase());
}
async function startTesting() {
  hide('dMainContent');
  show('dGameScreen');
  setTitle('*** Testing ***');
  setSubtitle('logged in as ' + Username);
  let color = USERNAME_SELECTION == 'local' ? localStorage.getItem('BaseColor') : null;
  setNewBackgroundColor(color);
  mStyleX(document.body, { opacity: 1 });
  initTable(null, 2); initSidebar(); initAux(); initScore();
  runTest();
}
function startTestLoop() {
  if (isLastTestOfSeries()) {
    isTraceOn = SHOW_TRACE;
    console.log('TESTS COMPLETED!');
  } else {
    nextTestOfSeries();
    if (!isLastTestOfSeries()) setTimeout(startTestLoop, 1000);
  }
}
function startTestSeries() {
  let numSeries = Object.keys(ALLTESTS).length;
  if (iTESTSERIES >= numSeries) {
    console.log('TEST SERIES COMPLETED!');
    isTraceOn = SHOW_TRACE;
    return;
  } else if (isLastTestOfSeries()) {
    iTESTSERIES += 1;
    iTEST = 0;
  } else {
    nextTestOfSeries();
  }
  if (iTESTSERIES < numSeries) setTimeout(startTestSeries, 1000);
}
function StartThinking() {
  let img = mBy('ThinkingPng');
  show(img);
  mClass(img, 'blinkFast');
  mBy('dShield').style.display = 'block';
}
function startTime(elem) {
  if (nundef(Settings.showTime) || !Settings.showTime) return;
  if (nundef(TimestampStarted)) { TimestampStarted = msNow(); TimeElapsed = 0; }
  if (nundef(elem) && isdef(TimeElem)) { elem = TimeElem; }
  else { if (isString(elem)) elem = mBy(elem); TimeElem = elem; }
  var timeLeft = TimeLeft = Settings.minutesPerUnit * 60000 - getTimeElapsed();
  if (timeLeft > 0) {
    let t = msToTime(timeLeft);
    let s = format2Digits(t.h) + ":" + format2Digits(t.m) + ":" + format2Digits(t.s);
    elem.innerHTML = s;
    setTimeout(() => startTime(elem), 500);
  } else {
    elem.innerHTML = '00:00:00';
    if (OnTimeOver) OnTimeOver();
  }
}
function startTimeCD(elem, ms, callback) {
  if (isdef(ms)) { MSTimeClock = ms; MSTimeDiff = 0; MSTimeStart = Date.now(); MSTimeCallback = callback; }
  else { MSTimeDiff = (Date.now() - MSTimeStart); }
  if (MSTimeDiff > MSTimeClock) {
    MSTimeCallback();
    return;
  }
  let t = msToTime(MSTimeClock - MSTimeDiff);
  if (isString(elem)) elem = mBy(elem); elem.innerHTML = t.h + ":" + format2Digits(t.m) + ":" + format2Digits(t.s);
  MSTimeTO = setTimeout(() => startTimeCD(elem), 500);
}
function startTimeClock(elem) {
  if (nundef(Settings.showTime) || !Settings.showTime) return;
  var today = new Date(),
    h = format2Digits(today.getHours()),
    m = format2Digits(today.getMinutes()),
    s = format2Digits(today.getSeconds());
  if (isString(elem)) elem = mBy(elem); elem.innerHTML = h + ":" + m + ":" + s;
  TOList.clock = setTimeout(() => startTimeClock(elem), 500);
}
function startTurn() {
  let me = getTurnPlayer();
  changeUserTo(me.id)
  showHands();
  present();
  optionsFor(me);
}
function startUnit() {
  renewTimer(G, 'time');
  U.session = {};
  if (START_IN_MENU) { START_IN_MENU = false; onClickTemple(); } else GC.startGame();
}
function staticArea(areaName, oSpec) {
  func = correctFuncName(oSpec.type);
  oSpec.ui = window[func](areaName, oSpec);
}
function staticPos(ms) {
  let gameArea = UIS['a_d_game'];
  let actionArea = UIS['a_d_actions'];
  let pageHeaderArea = UIS['a_d_header'];
  let statusArea = UIS['a_d_status'];
  let x = actionArea.w + gameArea.w / 2 + ms.x;
  let y = pageHeaderArea.h + statusArea.h + gameArea.h / 2 + ms.y;
  return { x: x, y: y };
}
function staticTitle() {
  clearInterval(TO.titleInterval);
  let url = window.location.href;
  let loc = url.includes('telecave') ? 'telecave' : 'local';
  let game = isdef(Z) ? stringAfter(Z.friendly, 'of ') : '♠ GAMES ♠';
  document.title = `(${loc}) ${game}`;
}
function status_message(msg, styles = {}) {
  let d = mBy('dMessage'); show(d); clearElement(d);
  let def_styles = { padding: 20, align: 'center', position: 'absolute', fg: 'contrast', fz: 24, w: '100vw' };
  copyKeys(styles, def_styles);
  let dContent = mDiv(d, def_styles, null, msg);
  return dContent;
}
function status_message_new(msg, dParent, styles = {}) { }
function status_message_off() {
  let d = mBy('dMessage');
  clearElement(d);
  hide(d);
  onclick = null;
}
function std2fold(dMain) {
  let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto', display: 'flex', 'flex-flow': 'row wrap' });
  let dLeft = mDiv(dOuter, { bg: 'random', w: 100 }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
  return [dLeft, dMiddle];
}
function std3fold(dMain) {
  let dOuter = mDiv(dMain, { flex: '1 0 auto', display: 'flex', 'flex-flow': 'row' });
  let dLeft = mDiv(dOuter, { w: 100 }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { position: 'relative', bg: '#ffffff80', flex: '1 0 auto' }, 'dMiddle');
  let dRight = mDiv(dOuter, { w: 100, overflow: 'hidden' }, 'dRight', 'right');
  return [dLeft, dMiddle, dRight];
}
function std3title(dMain, title, titleStyles) {
  let prefix = 'title';
  let dOuter = mDiv(dMain, { bg: '#000000', alpha: .5, display: 'flex', 'flex-flow': 'row' });
  let dLeft = mDiv(dOuter, { w: 100 }, `d${prefix}Left`);
  let dMiddle = mDiv(dOuter, { align: 'center', flex: '1 0 auto' }, `d${prefix}Middle`, title);
  mCenterCenterFlex(dMiddle);
  if (isdef(titleStyles)) mStyle(dMiddle, titleStyles);
  let dRight = mDiv(dOuter, { align: 'right', wmin: 100, overflow: 'hidden' }, `d${prefix}Right`);
  return [dLeft, dMiddle, dRight];
}
function stdCardsContainer(dParent, n, ov = 80, styles = {}) { return stdRowOverlapContainer(dParent, n, n * ov + 22, ov, addKeys({ paleft: 20, patop: 10 }, styles)); }
function stdColOverlapContainer(dParent, n, wGrid, wCell, styles) {
  addKeys({
    h: wGrid,
    gap: 0,
    display: 'inline-grid',
    'grid-template-rows': `repeat(${n}, ${wCell}px)`
  }, styles);
  return mDiv(dParent, styles);
}
function stdContainerCenterColWrap(dParent) { return stdFlexContainer(dParent, { dir: 'col', 'align-content': 'center' }); }
function stdContainerCenterRowWrap(dParent) { return stdFlexContainer(dParent, { 'justify-content': 'center' }); }
function stdContainerColWrap(dParent) { return stdFlexContainer(dParent, { dir: 'col' }); }
function stdContainerRowWrap(dParent) { return stdFlexContainer(dParent); }
function stdDeckContainer(dParent, n, ov = .25, styles = {}) { return stdRowOverlapContainer(dParent, n, 140, ov, addKeys({ padding: 10 }, styles)); }
function stdFlexContainer(dParent, styles = {}) {
  addKeys({
    wmax: '96%',
    margin: 'auto',
    padding: 10,
    gap: 10,
    display: 'flex',
    flex: '1 0 auto',
    wrap: true,
  }, styles);
  return mDiv(dParent, styles);
}
function stdGridContainer(dParent, wCell, styles = {}) {
  addKeys({
    wmax: 500,
    margin: 'auto',
    padding: 10,
    gap: 0,
    display: 'grid',
    bg: 'green',
    'grid-template-columns': `repeat(${20}, ${wCell}px)`
  }, styles);
  return mDiv(dParent, styles);
}
function stdHandContainer(dParent, n, ov = 20, styles = {}) { return stdRowOverlapContainer(dParent, n, 76 + n * ov + 22, ov, addKeys({ padding: 10 }, styles)); }
function stdInput(dParent, styles) {
  let defStyles = { fz: 20, padding: 12 };
  if (nundef(styles)) styles = {};
  let newStyles = deepmergeOverride(defStyles, styles);
  return mInputX(dParent, newStyles,
    { textPadding: 4, autoComplete: 'off', autoFocus: true, autoSelect: false })
}
function stdInputSubmit(dParent, styles, handler) {
  let defStyles = { fz: 20, padding: 12 };
  if (nundef(styles)) styles = {};
  let newStyles = deepmergeOverride(defStyles, styles);
  return mInputX(dParent, newStyles,
    { textPadding: 4, autoComplete: 'off', submitOnEnter: true, autoFocus: true, autoSelect: false, handler: handler })
}
function stdInputVal(dParent, styles, val, autoSelect = true) {
  let defStyles = { fz: 20, padding: 12 };
  if (nundef(styles)) styles = {};
  let newStyles = deepmergeOverride(defStyles, styles);
  return mInputX(dParent, newStyles,
    { value: val, textPadding: 4, autoComplete: 'off', submitOnEnter: true, autoFocus: true, autoSelect: autoSelect })
}
function stdInstruction(written, dParent, spoken, { fz, voice, lang } = {}) {
  if (isdef(lang) && lang == 'D' && nundef(voice)) voice = 'deutsch';
  else if (isdef(lang) && lang == 'E' && nundef(voice)) voice = 'random';
  if (nundef(voice)) voice = 'random';
  let d;
  if (isdef(dParent)) clearElement(dParent);
  dInstruction = d = mDiv(dParent);
  mStyleX(d, { margin: 15 })
  mClass(d, 'flexWrap');
  if (nundef(fz)) fz = 36;
  let d1 = mText(written, d, { fz: fz, display: 'inline-block' });
  if (isdef(spoken)) {
    let sym = symbolDict.speaker;
    let d2 = mText(sym.text, d, {
      fz: fz + 2, weight: 900, display: 'inline-block',
      family: sym.family, 'padding-left': 14
    });
    sayRandomVoice(spoken, spoken, voice);
  }
  dInstruction.onclick = () => aniInstruction(spoken);
  return d;
}
function stdMenuButton(parent, styles = {}) { return mButton(UnicodeSymbols.menu, null, parent, styles, 'mybutton'); }
function stdRowOverlapContainer(dParent, n, wGrid, wCell, styles) {
  addKeys({
    w: wGrid,
    gap: 0,
    display: 'inline-grid',
    'grid-template-columns': `repeat(${n}, ${wCell}px)`
  }, styles);
  return mDiv(dParent, styles);
}
function stdRowsColsContainer(dParent, cols, styles = {}) {
  addKeys({
    margin: 'auto',
    padding: 10,
    gap: 10,
    display: 'grid',
    bg: 'green',
    'grid-template-columns': `repeat(${cols}, 1fr)`
  }, styles);
  return mDiv(dParent, styles);
}
function stdSidebarController(button, id) {
  let [ms, easing] = [500, 'cubic-bezier(.1,.67,.81,.68)'];
  button.onclick = () => {
    let d = mBy(id);
    let open = nundef(d.isOpen) || d.isOpen == true;
    d.isOpen = !open;
    let [from, to] = open ? [100, 0] : [0, 100];
    d.animate([{ width: `${from}px` }, { width: `${to}px` }], { duration: ms, easing: easing });
    setTimeout(() => d.style.width = `${to}px`, ms - 10);
  }
}
function stop_game() { console.log('stopgame'); }
function stop_polling() { clearTimeout(TOTicker); IS_POLLING_ALLOWED = false; if (isdef(DA.poll)) console.log('...polling is OFF'); }
function stop_simple_timer() { if (isdef(DA.timer)) { DA.timer.clear(); DA.timer = null; } }
function stop_timer() {
  if (isdef(DA.timer)) {
    let res = DA.timer.clear();
    DA.timer = null;
    return isNumber(res) ? res : 0;
  }
  return 0;
}
function stopAllHighlighting() {
  if (isdef(IdOwner.a)) IdOwner.a.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.l)) IdOwner.l.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.p)) IdOwner.p.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.r)) IdOwner.r.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.s)) IdOwner.s.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.t)) IdOwner.t.map(x => _removeAllHighlighting(x));
  setTimeout(hideTooltip, 500);
}
function stopBlinking(item) { if (isdef(item)) { item.isBlinking = false; mRemoveClass(iDiv(item), 'blink'); } }
function stopgame() {
  if (!DA.running) return;
  DA.running = false;
  DA.noshow = 0;
  clear_timeouts();
  hide('bRestartMove');
  hide('dHostButtons');
  mStyle('dAdmin', { bg: 'white' });
  mClear('dAdminMiddle')
  for (const id of ['bSpotitStart', 'bClearAck', 'bRandomMove', 'bSkipPlayer']) hide(id);
  pollStop();
  Z = null; delete Serverdata.table; delete Serverdata.playerdata; Clientdata = {};
  staticTitle();
}
function stopGame() {
  resetState();
}
function stopInteraction() {
  if (isdef(IdOwner.a)) IdOwner.a.map(x => _removeInteraction(x));
  if (isdef(IdOwner.l)) IdOwner.l.map(x => _removeInteraction(x));
  if (isdef(IdOwner.p)) IdOwner.p.map(x => _removeInteraction(x));
  if (isdef(IdOwner.r)) IdOwner.r.map(x => _removeInteraction(x));
  if (isdef(IdOwner.s)) IdOwner.s.map(x => _removeInteraction(x));
  if (isdef(IdOwner.t)) IdOwner.t.map(x => _removeInteraction(x));
  setTimeout(hideTooltip, 500);
}
function stopInteractionH() {
  if (isdef(IdOwner.a)) IdOwner.a.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.l)) IdOwner.l.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.p)) IdOwner.p.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.r)) IdOwner.r.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.s)) IdOwner.s.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.t)) IdOwner.t.map(x => removeAllHighlighting(x));
  setTimeout(hideTooltip, 500);
}
function STOPP() { stopgame(); clear_screen(); assertion(Z == null, "ZZZZZZZZZZ NOT NULL") }
function stopPolling() { pollStop(); }
function stopPulsating(item) { if (isdef(item)) { item.isPulsating = false; mRemoveClass(iDiv(item), 'onPulse'); } }
function StopThinking() {
  let img = mBy('ThinkingPng');
  mClassRemove(img, 'blinkFast');
  hide(img);
  hideShield();
}
function storePositionData(g1) {
  let ids = g1.getNodeIds();
  let x = 10; let y = 10;
  for (const id of ids) {
    g1.setProp(id, 'center', { x: x, y: y });
    x += 50; y += 50; if (y > 250) { y = 10; } if (x > 550) { x = 10; }
  }
}
function StorePvMove(move) {
  var index = brd_posKey % PVENTRIES;
  brd_PvTable[index].move = move;
  brd_PvTable[index].posKey = brd_posKey;
}
function storeRoomPositions(g1, house) {
  let ids = g1.getNodeIds();
  let di = g1.posDict = {};
  for (const id of ids) {
    let r = Items[id];
    let center = getCenter(iDiv(r));
    center.x += r.rect.x;
    center.y += r.rect.y;
    g1.setProp(id, 'center', center);
    di[id] = center;
  }
}
function strategicBoat(goodlist, badlist) {
  let boats = getBoats();
  let goodBoats = boats;
  if (isdef(badlist)) {
    goodBoats = [];
    for (const b of boats) {
      if (isEmpty(badlist.filter(x => b.o.text.join(',').includes(x)))) goodBoats.push(b);
    }
  }
  if (isdef(goodlist)) {
    for (const kw of goodlist) {
      for (const b of boats) {
        if (b.o.text.join(',').includes(kw) || b.o.desc.includes(kw)) return b;
      }
    }
  }
  return chooseRandom(goodBoats);
}
function stressTest() {
  initRSGData(); showGame(); initDom();
  timit.reset();
  let board = makeDrawingArea('board', 'a_d_game', true);
  coll = drawTest(board, 3);
}
function stressTest01(area) {
  timit.showTime('*test')
  let n = 500;
  for (let index = 0; index < n; index++) {
    showPictoDivCentered('crow', area, randomColor(), n + 25 - index);
  }
  timit.showTime('*test done...');
  if (testCounter > 0) { testCounter -= 1; setTimeout(_startStep, 0); }
  else {
    let t = timit.getTotalTimeElapsed();
    console.log('avg msecs per cycle:', t / 100, 'cycle size:', n)
  }
}
function stringAfter(sFull, sSub) {
  let idx = sFull.indexOf(sSub);
  if (idx < 0) return '';
  return sFull.substring(idx + sSub.length);
}
function stringAfterLast(sFull, sSub) {
  let parts = sFull.split(sSub);
  return arrLast(parts);
}
function stringAfterLeadingConsonants(s) {
  let regexpcons = /^([^aeiou])+/g;
  let x = s.match(regexpcons);
  return x ? s.substring(x[0].length) : s;
}
function stringBefore(sFull, sSub) {
  let idx = sFull.indexOf(sSub);
  if (idx < 0) return sFull;
  return sFull.substring(0, idx);
}
function stringBeforeLast(sFull, sSub) {
  let parts = sFull.split(sSub);
  return sFull.substring(0, sFull.length - arrLast(parts).length - 1);
}
function stringBetween(sFull, sStart, sEnd) {
  return stringBefore(stringAfter(sFull, sStart), isdef(sEnd) ? sEnd : sStart);
}
function stringBetweenLast(sFull, sStart, sEnd) {
  let s1 = stringBeforeLast(sFull, isdef(sEnd) ? sEnd : sStart);
  return stringAfterLast(s1, sStart);
}
function stringCount(s, sSub, caseInsensitive = true) {
  let temp = "Welcome to W3Docs";
  let m = new RegExp(sSub, 'g' + (caseInsensitive ? 'i' : ''));
  let count = (s.match(m)).length;
  return count;
}
function stringDivider(str, width, spaceReplacer) {
  if (str.length > width) {
    let p = width;
    while (p > 0 && str[p] != ' ' && str[p] != '-') {
      p--;
    }
    if (p > 0) {
      let left;
      if (str.substring(p, p + 1) == '-') {
        left = str.substring(0, p + 1);
      } else {
        left = str.substring(0, p);
      }
      const right = str.substring(p + 1);
      return left + spaceReplacer + stringDivider(right, width, spaceReplacer);
    }
  }
  return str;
}
function stringLast(s, n) { return s.substring(s.length - n, s.length); }
function stringMinusLast(s, n = 1) {
  return s.substring(0, s.length - n);
}
function stringToMatrix(s, rows, cols) {
  if (isNumber(s)) s = String(s);
  let letters = toLetterArray(s);
  let nums = letters.map(x => Number(x));
  let matrix = arrToMatrix(nums, rows, cols);
}
function stripObject(o, keysToDelete) {
  for (const k of keysToDelete) {
    if (isdef(o[k])) delete o[k];
  }
}
function stripSet(x) {
  if (isListOfListOfActions(x)) return x;
  else if (isActionElement(x)) return [[x]];
  else if (isList(x) && isActionElement(x[0])) return [x];
  else return [].concat(...x.map(stripSet));
}
function stripToKeys(o, di) {
  let res = {};
  for (const k in o) {
    if (isdef(di[k])) res[k] = o[k];
  }
  return res;
}
function strKeys(dict) { return getKeys(dict).toString(); }
function stubPlayerConfig(gameInfo) {
  gcs = {};
  for (const gName in gameInfo) {
    let info = gameInfo[gName]
    let nPlayers = info.num_players[0];
    let pls = [];
    for (let i = 0; i < nPlayers; i++) {
      let pl = { id: info.player_names[i], playerType: 'me', agentType: null, username: USERNAME + (i > 0 ? i : '') };
      pls.push(pl);
    }
    gcs[gName] = { numPlayers: nPlayers, players: pls };
  }
  return gcs;
}
function style_not_playing(item, game, list) {
  console.log('item', item, 'game', game, 'list', list)
  let ui = iDiv(item); let uname = ui.getAttribute('username');
  mStyle(ui, { bg: 'transparent', fg: 'black' });
  arrLast(arrChildren(ui)).innerHTML = uname;
  item.ifunc = 0; item.playmode = 'none'; removeInPlace(list, item);
}
function style_playing_as_bot(item, game, list) {
  let ui = iDiv(item); let uname = ui.getAttribute('username'); let bg = get_game_color(game);
  mStyle(ui, { bg: bg, fg: colorIdealText(bg) });
  arrLast(arrChildren(ui)).innerHTML = uname.substring(0, 3) + 'bot';
  item.ifunc = 2; item.playmode = 'bot';
}
function style_playing_as_human(item, game, list) {
  let ui = iDiv(item); let uname = ui.getAttribute('username');
  mStyle(ui, { bg: get_user_color(uname), fg: colorIdealText(get_user_color(uname)) });
  arrLast(arrChildren(ui)).innerHTML = uname;
  item.ifunc = 1; item.playmode = 'human'; list.push(item);
}
function styles_to_leaflet_options(o) {
  let res = {};
  let di = {
    fg: 'color', bg: 'fillColor', opacity: 'fillOpacity', sz: 'radius'
  };
  for (const k in o) {
    if (k == 'sz') o[k] /= 2;
    res[isdef(di[k]) ? di[k] : k] = o[k];
  }
  return res;
}
function subDict(d, keys) {
  let dNew = {};
  for (const key of keys) {
    if (key in d) {
      dNew[key] = d[key];
    }
  }
  return dNew;
}
function subdictOf(dict1, keylist) {
  let res = {};
  for (const k of keylist) {
    res[k] = dict1[k];
  }
  return res;
}
function submit_form(fname) {
  if (typeof document.getElementById(fname).submit === "object") {
    document.getElementById(fname).submit.remove();
  }
  document.getElementById(fname).submit();
}
function substringOfMinLength(s, minStartIndex, minLength) {
  let res = s.substring(minStartIndex).trim();
  let i = 0;
  let res1 = '';
  while (res1.trim().length < minLength && i < res.length) { res1 += res[i]; i += 1; }
  return res1.trim();
}
function success_pic_goal(withComment = true) {
  let lang = G.language;
  if (withComment && G.spokenFeedback) {
    const comments = {
      E: ['YEAH!', 'Excellent!!!', 'CORRECT!', 'Great!!!'],
      D: ['gut', 'Sehr Gut!!!', 'richtig!!', 'Bravo!!!'],
      S: ['bien', 'muy bien!!!', 'eccelente!!', 'bravo!!!'],
      F: ['bien', 'tres bien!!!', 'fantastique!!', 'bravo!!!', 'excellent!!!'],
      C: ['优秀', '好的!!!', '正确的!!', 'Bravo!!!'],
    }[lang];
    say(chooseRandom(comments), lang);
  }
  if (isdef(Selected) && isdef(Selected.feedbackUI)) {
    let uilist;
    if (isdef(Selected.positiveFeedbackUI)) uilist = [Selected.positiveFeedbackUI];
    else uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
    let sz = getRect(uilist[0]).h;
    for (const ui of uilist) {
      let d = markerSuccess();
      mpOver(d, ui, sz * (4 / 5), 'limegreen', 'segoeBlack');
    }
  }
}
function successPictureGoal(withComment = true) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['YEAH!', 'Excellent!!!', 'CORRECT!', 'Great!!!'] : ['gut', 'Sehr Gut!!!', 'richtig!!', 'Bravo!!!']);
    sayRandomVoice(chooseRandom(comments));
  }
  if (isdef(Selected) && isdef(Selected.feedbackUI)) {
    let uilist;
    if (isdef(Selected.positiveFeedbackUI)) uilist = [Selected.positiveFeedbackUI];
    else uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
    let sz = getRect(uilist[0]).h;
    for (const ui of uilist) {
      let d = markerSuccess();
      mpOver(d, ui, sz * (4 / 5), 'limegreen', 'segoeBlack');
    }
  }
}
function successThumbsUp(withComment = true) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['YEAH!', 'Excellent!!!', 'CORRECT!', 'Great!!!'] : ['gut', 'Sehr Gut!!!', 'richtig!!', 'Bravo!!!']);
    sayRandomVoice(chooseRandom(comments));
  }
  let p1 = firstCond(Pictures, x => x.key == 'thumbs up');
  iDiv(p1).style.opacity = 1;
  let p2 = firstCond(Pictures, x => x.key == 'thumbs down');
  iDiv(p2).style.display = 'none';
}
function successThumbsUpPlus(withComment = true) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['YEAH!', 'Excellent!!!', 'CORRECT!', 'Great!!!'] : ['gut', 'Sehr Gut!!!', 'richtig!!', 'Bravo!!!']);
    sayRandomVoice(chooseRandom(comments));
  }
  let p1 = firstCond(Pictures, x => x.key == 'thumbs up');
  iDiv(p1).style.opacity = 1;
  let p2 = firstCond(Pictures, x => x.key == 'thumbs down');
  iDiv(p2).style.display = 'none';
  if (isdef(Selected) && isdef(Selected.feedbackUI)) {
    let uilist;
    if (isdef(Selected.positiveFeedbackUI)) uilist = [Selected.positiveFeedbackUI];
    else uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
    let sz = getRect(uilist[0]).h;
    for (const ui of uilist) {
      let d = markerSuccess();
      mpOver(d, ui, sz * (4 / 5), 'limegreen', 'segoeBlack');
    }
  }
}
function sudoku99Examples() {
  var veryeasyGameArr = [
    [2, 0, 3, 0, 0, 8, 6, 0, 7],
    [1, 4, 0, 7, 2, 6, 0, 0, 9],
    [5, 0, 7, 1, 3, 9, 4, 2, 8],
    [0, 2, 5, 0, 8, 1, 9, 0, 4],
    [4, 1, 0, 9, 0, 3, 2, 0, 5],
    [0, 7, 9, 2, 0, 5, 0, 3, 6],
    [6, 0, 2, 0, 1, 0, 0, 9, 3],
    [7, 0, 0, 5, 0, 2, 0, 0, 1],
    [0, 8, 1, 3, 6, 7, 0, 4, 0]
  ];
  var easyGameArr = [
    [0, 3, 0, 0, 0, 0, 0, 0, 0],
    [0, 2, 0, 9, 0, 6, 3, 0, 0],
    [0, 6, 0, 4, 0, 2, 0, 9, 0],
    [1, 0, 0, 0, 9, 0, 4, 0, 0],
    [0, 0, 8, 1, 0, 3, 5, 0, 0],
    [0, 0, 5, 0, 7, 0, 0, 0, 3],
    [0, 5, 0, 3, 0, 1, 0, 6, 0],
    [0, 0, 4, 6, 0, 7, 0, 3, 0],
    [0, 0, 0, 0, 0, 0, 0, 8, 0]
  ];
  var mediumGameArr = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 3, 0, 8, 5],
    [0, 0, 1, 0, 2, 0, 0, 0, 0],
    [0, 0, 0, 5, 0, 7, 0, 0, 0],
    [0, 0, 4, 0, 0, 0, 1, 0, 0],
    [0, 9, 0, 0, 0, 0, 0, 0, 0],
    [5, 0, 0, 0, 0, 0, 0, 7, 3],
    [0, 0, 2, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 9]
  ];
  var hardGameArr = [
    [0, 0, 0, 0, 0, 7, 0, 0, 0],
    [0, 0, 2, 4, 0, 6, 3, 0, 0],
    [0, 1, 7, 0, 0, 0, 9, 6, 0],
    [5, 8, 0, 0, 0, 0, 0, 3, 0],
    [0, 0, 0, 0, 9, 0, 0, 0, 0],
    [0, 7, 0, 0, 0, 0, 0, 4, 2],
    [0, 9, 4, 0, 0, 0, 6, 5, 0],
    [0, 0, 5, 2, 0, 8, 1, 0, 0],
    [0, 0, 0, 5, 0, 0, 0, 0, 0]
  ];
  var hardGameArr2 = [
    [0, 4, 3, 0, 1, 0, 0, 0, 0],
    [0, 0, 2, 0, 7, 0, 0, 3, 1],
    [8, 0, 0, 0, 0, 9, 0, 0, 0],
    [3, 0, 9, 0, 0, 5, 0, 0, 0],
    [0, 2, 5, 0, 0, 0, 4, 7, 0],
    [0, 0, 0, 7, 0, 0, 3, 0, 6],
    [0, 0, 0, 9, 0, 0, 0, 0, 5],
    [9, 5, 0, 0, 2, 0, 1, 0, 0],
    [0, 0, 0, 0, 5, 0, 6, 9, 0]
  ];
  var hardGameArr3 = [
    [0, 3, 0, 0, 5, 0, 2, 0, 8],
    [0, 0, 4, 0, 0, 0, 9, 0, 0],
    [0, 0, 0, 6, 0, 0, 0, 1, 0],
    [0, 6, 7, 5, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 8, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 9, 8, 4, 0],
    [0, 7, 0, 0, 0, 6, 0, 0, 0],
    [0, 0, 8, 0, 0, 0, 3, 0, 0],
    [1, 0, 2, 0, 4, 0, 0, 8, 0]
  ];
  var evilGameArr = [
    [8, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 3, 6, 0, 0, 0, 0, 0],
    [0, 7, 0, 0, 9, 0, 2, 0, 0],
    [0, 5, 0, 0, 0, 7, 0, 0, 0],
    [0, 0, 0, 0, 4, 5, 7, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 3, 0],
    [0, 0, 1, 0, 0, 0, 0, 6, 8],
    [0, 0, 8, 5, 0, 0, 0, 1, 0],
    [0, 9, 0, 0, 0, 0, 4, 0, 0]
  ];
  var evilGameArr2 = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 3, 0, 8, 5],
    [0, 0, 1, 0, 2, 0, 0, 0, 0],
    [0, 0, 0, 5, 0, 7, 0, 0, 0],
    [0, 0, 4, 0, 0, 0, 1, 0, 0],
    [0, 9, 0, 0, 0, 0, 0, 0, 0],
    [5, 0, 0, 0, 0, 0, 0, 7, 3],
    [0, 0, 2, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 9]
  ];
  console.log("");
  console.log("Starting game - VERY EASY")
  print_board(veryeasyGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(veryeasyGameArr))
  console.log("");
  console.log("Starting game - EASY")
  print_board(easyGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(easyGameArr))
  console.log("");
  console.log("Starting game - MEDIUM")
  print_board(mediumGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(mediumGameArr))
  console.log("");
  console.log("Starting game - HARD")
  print_board(hardGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(hardGameArr))
  console.log("");
  console.log("Starting game - HARD #2")
  print_board(hardGameArr2)
  console.log("");
  console.log("Completed solution")
  print_board(solve(hardGameArr2))
  console.log("");
  console.log("Starting game - HARD #3")
  print_board(hardGameArr3)
  console.log("");
  console.log("Completed solution")
  print_board(solve(hardGameArr3))
  console.log("");
  console.log("Starting game - EVIL")
  print_board(evilGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(evilGameArr))
  console.log("");
  console.log("Starting game - EVIL #2")
  print_board(evilGameArr2)
  console.log("");
  console.log("Completed solution")
  print_board(solve(evilGameArr2))
}
function sudokuSampleToIndexMatrix(s, rows, cols) {
  if (isNumber(s)) s = String(s);
  let letters = toLetterArray(s);
  let nums = letters.map(x => Number(x));
  let res = [];
  for (const n of nums) {
    if (n === 0) res.push(' ');
    else res.push(n - 1);
  }
  let matrix = arrToMatrix(res, rows, cols);
  return matrix;
}
function sumProp(olist, prop) {
  let res = 0;
  for (const d of olist) {
    res += d[prop];
  }
  return res;
}
function suTest00() {
  let [rows, cols] = [4, 4];
  let pattern = getSudokuPattern(rows, cols);
  printMatrix(pattern, 'pattern');
  let colarrs = bGetCols(pattern); printMatrix(colarrs, 'transposed');
  let rowarrs = bGetCols(colarrs); printMatrix(rowarrs, 'normal');
  let cFlat = arrFlatten(rowarrs);
  let aRows = bGetRows(pattern);
  let rFlat = arrFlatten(aRows);
  console.assert(sameList(cFlat, rFlat), 'TRANSPOSE DOES NOT WORK!!!!!!!!!!!!!!!')
  let correct = checkSudokuRule(pattern);
}
function switch_uname(plname) {
  set_user(plname);
  show_username();
}
function switchPlayerArea() {
  if (G.previousPlayer) {
    let msPrevPlayerArea = getPlayerArea(G.previousPlayer);
    if (msPrevPlayerArea) {
      msPrevPlayerArea.hide();
    }
  }
  let msPlayerArea = getPlayerArea(G.player);
  if (msPlayerArea) {
    msPlayerArea.show();
  }
}
function symbolcolor(card, color) {
  let d = iDiv(card);
  let els = d.getElementsByTagName('symbol');
  console.log('list', els)
  for (const el of els) {
    let html = el.innerHTML;
    let html1 = replaceAll(html, 'red', color);
    let html2 = replaceAll(html1, 'black', color);
    el.innerHTML = html2;
  }
}
function symbolMeasuring() {
  clearElement('wrapper');
  dTable = mDiv(mBy('wrapper'), { position: 'absolute', padding: 10, bg: 'white', overflow: 'scroll' });
  let items = []; let n = SymKeys.length;
  for (let i = 0; i < n; i++) {
    let k = SymKeys[i];
    let info = Syms[k];
    let d = mDiv(dTable, { fz: 100, family: info.family, bg: 'random', display: 'inline' }, null, info.text);
    let item = { div: d, k: k, info: info };
    items.push(item);
  }
  setTimeout(() => symbolMeasuring2(items), 5000);
}
function symbolMeasuring2(items) {
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    let r = getRect(item.div);
    item.info.w = Math.round(r.w);
    item.info.h = Math.round(r.h);
  }
  let newDict = {};
  for (const item of items) {
    newDict[item.k] = item.info;
  }
  downloadAsYaml(newDict, 'syms');
}
function sync_users(php_users) {
  let result = [];
  let changed = false;
  for (const udata of php_users) {
    if (nundef(udata.id)) return php_users;
    let name = udata.username;
    let u = DB.users[name];
    if (nundef(u)) {
      changed = true;
      let db_user = { name: name, color: randomColor(), motto: random_motto(), image: startsWith(udata.image, name), games: {}, tables: {}, };
      add_new_user(db_user, false);
      result.push(db_user);
    } else result.push(u)
  }
  if (changed) db_save();
  if (!is_online()) return result;
  let di = {}; php_users.map(x => di[x.username] = x);
  let not_in_sql_db = [];
  for (const name in DB.users) {
    let u = DB.users[name];
    if (nundef(di[name]) && name != Session.cur_user) { not_in_sql_db.push(name); addIf(result, u); }
  }
  if (!isEmpty(not_in_sql_db)) add_users_to_sql_db(not_in_sql_db);
  return result;
}
function sysColor(iPalette, ipal) { return S.pals[iPalette][ipal]; }
function t0_textarea() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  mDiv(dTable, { w: '100%' }, null, 'Enter Code:');
  let d = mTextArea(25, 120, dTable, { fz: 16, margin: 'auto', padding: 10, outline: 'none', border: 'none' }, 'dCode');
  let dButtons = mDiv(dTable, { display: 'flex', w: '100%' });
  let asave = mLink("javascript:void(0)", dButtons, {}, null, 'Save Code', 'a');
  asave.onclick = db_add_code;
  let aclear = mLink("javascript:void(0)", dButtons, {}, null, 'Clear Code', 'a');
  aclear.onclick = () => console.log('click clear code!');
}
async function t00_makeWordProblemsDict() { let wp = await makeWordProblemsDict(); }
async function t00_oldTests() { }
async function t00_timitTests() {
  timit.show('*'); console.assert(isdef(DB));
  timit.show('DONE')
}
async function t00_wpInstantiate() {
  let wp = await route_path_yaml_dict('../assets/math/allWP.yaml');
  let p = firstCond(wp, x => x.index == 40);
  instantiateWP(p);
}
function t01() {
  showPictureGrid(['cockroach'], dTable)
}
function t01_fractions() {
  console.log(math.add(math.fraction(0.1), math.fraction(0.2)))
  console.log(math.divide(math.fraction(0.3), math.fraction(0.2)))
  console.log(math.subtract(math.fraction(0.1), math.fraction(0.2)))
}
function t01_getTextForFraction() { mText('you have 5 ' + getTextForFraction(1, 2) + ' muffins', dTable, { fz: 100 }); }
function t01_numbers() {
  var array1 = [0, 1, 2];
  var array2 = [3, 4, 5];
  let x = numbers.matrix.addition(array1, array2);
  console.log(x);
  numbers.matrix.transpose(x);
  console.log(numbers.prime.simple(171));
}
function t1() {
  let a1 = { type: 1 };
  let a2 = { type: 2 };
  let a3 = { type: 3 };
  let a = {
    tic: {
      actions:
      {
        _set:
          [{ _tuple: [{ _set: [a1, a2, a3] }] }]
      }
    }
  };
}
function t2(act) {
  let res = [];
  for (const key in act) {
    let data = act[key].actions;
    let e = exp(data);
    res.push(e)
  }
  return res;
}
function table_options_to_game_options(t) {
  console.log('t', t);
  let settings = { game: {} };
  copyKeys(t.options, settings.game);
  return settings;
}
function table_shield_off() {
  if (isdef(dTableShield)) { dTableShield.remove(); dTableShield = null; }
}
function table_shield_on() {
  if (nundef(dTableShield)) {
    dTableShield = mDiv(dTable, { position: 'absolute', bg: '#0000ff80', w: '100%', h: '100%' });
    dTableShield.style.zIndex = 1000;
  }
}
function tableDimensions(w, h) {
  setCSSVariable('--wGame', '' + w + 'px');
  setCSSVariable('--hGame', '' + h + 'px');
  return { w: w, h: h };
}
function tableElem(o, keys) {
  let t = document.createElement('table');
  t.classList.add('tttable');
  let s = '';
  for (const k in o) {
    if (isdef(keys) && !keys.includes(k)) continue;
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) {
      sval = `<div class='up10 hallo'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    } else if (val && isDict(val) && '_obj' in val) {
      sval = `<div class='up10 hallo'>${val._obj.toString()}</div>`;
    }
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? tableHTML(val, 4) : simpleRep(val);
    s += sval + '</td>';
  }
  t.innerHTML = s;
  return t;
}
function tableElemX(o, keys) {
  let t = document.createElement('table');
  t.classList.add('tttable');
  let refs = [];
  let s = '';
  for (const k in o) {
    if (isdef(keys) && !keys.includes(k)) continue;
    s += '<tr><th>' + k + '</th><td>';
    let sval = transformToString(k, o[k], refs);
    s += sval + '</td>';
  }
  t.innerHTML = s;
  return { table: t, refs: refs };
}
function tableElemY(o, keys) {
  let t = document.createElement('table');
  t.classList.add('tttable');
  let refs = [];
  let s = '';
  for (const k in o) {
    if (isdef(keys) && !keys.includes(k)) continue;
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf(val, '_obj')) {
      let cl = 't_r_' + getUID(); let ref = { oids: val.filter(x => isdef(x)).map(x => x._obj), id: cl }; refs.push(ref);
      sval = `<div id=${cl} class='up10 hallo'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    } else if (val && isDict(val) && '_obj' in val) {
      let cl = 't_r_' + getUID(); let ref = { oids: [val._obj], id: cl }; refs.push(ref);
      sval = `<div id=${cl} class='up10 hallo'>${val._obj.toString()}</div>`;
    } else if (val && isDict(val) && '_ndarray' in val) {
      let rows = val._ndarray;
      sval = `<div>`;
      let rowClass = 'up2 hallo';
      for (const row of rows) {
        let cl = 't_r_' + getUID(); let ref = { oids: row.filter(x => isdef(x)).map(x => x._obj), id: cl }; refs.push(ref);
        sval += `<div id=${cl} class='${rowClass}'>${row.map(x => !x ? '_' : x._obj).toString()}</div><br>`;
        rowClass = 'hallo';
      }
      sval += '</div>';
    } else if (val && isDict(val) && '_player' in val) {
      let cl = 'p_r_' + getUID(); let ref = { oids: [val._player], id: cl }; refs.push(ref);
      sval = `<div id=${cl} class='up10 hallo'>${val._player.toString()}</div>`;
    }
    if (!sval) {
      sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? tableHTMLY(val, refs) : simpleRep(val);
    }
    s += sval + '</td>';
  }
  t.innerHTML = s;
  return { table: t, refs: refs };
}
function tableHTML(o) {
  let s = '<table class="tttable up10">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) sval = `<div class='up10 hallo'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    else if (val && isDict(val) && '_obj' in val) sval = `<div class='up10 hallo'>${val._obj.toString()}</div>`;
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? tableHTML(val) : simpleRep(val);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function tableHTMLX(o, refs) {
  let s = '<table class="tttable up10">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let sval = transformToString(k, o[k], refs);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function tableHTMLY(o, refs) {
  let s = '<table class="tttable up10">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) {
      let cl = 't_r_' + getUID(); let ref = { oids: val.filter(x => isdef(x)).map(x => x._obj), id: cl }; refs.push(ref);
      sval = `<div class='up10 hallo'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    } else if (val && isDict(val) && '_obj' in val) {
      let cl = 't_r_' + getUID(); let ref = { oids: [val._obj], id: cl }; refs.push(ref);
      sval = `<div class='up10 hallo'>${val._obj.toString()}</div>`;
    }
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? tableHTMLY(val, refs) : simpleRep(val);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function tableLayoutMR(dParent, m = 7, r = 1) {
  let ui = UI; ui.players = {};
  clearElement(dParent);
  let bg = 'transparent';
  let [dMiddle, dRechts] = [ui.dMiddle, ui.dRechts] = mColFlex(dParent, [m, r], [bg, bg]);
  mCenterFlex(dMiddle, false);
  let dOben = ui.dOben = mDiv(dMiddle, { w: '100%', display: 'block' }, 'dOben');
  let dSelections = ui.dSelections = mDiv(dOben, {}, 'dSelections');
  for (let i = 0; i <= 5; i++) { ui[`dSelections${i}`] = mDiv(dSelections, {}, `dSelections${i}`); }
  let dActions = ui.dActions = mDiv(dOben, { w: '100%' });
  for (let i = 0; i <= 5; i++) { ui[`dActions${i}`] = mDiv(dActions, { w: '100%' }, `dActions${i}`); }
  ui.dError = mDiv(dOben, { w: '100%', bg: 'red', fg: 'yellow', hpadding: 12, box: true }, 'dError');
  let dSubmitOrRestart = ui.dSubmitOrRestart = mDiv(dOben, { w: '100%' });
  let dOpenTable = ui.dOpenTable = mDiv(dMiddle, { w: '100%', padding: 10 }); mFlexWrap(dOpenTable);
  return [dOben, dOpenTable, dMiddle, dRechts];
}
function take_feedback_host(write_fen = true, write_player = false, clear_players = false, player_status = null) {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly };
  if (isdef(Z.fen)) o.fen = Z.fen;
  if (write_fen) { assertion(isdef(Z.fen) && isdef(Z.fen.turn), 'write_fen without fen!!!!'); o.write_fen = true; }
  if (write_player) { o.write_player = true; o.state = Z.state; }
  if (clear_players) o.clear_players = true;
  o.player_status = player_status;
  o.auto = true;
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn(write_fen = true, write_player = false, clear_players = false, player_status = null) {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly };
  if (isdef(Z.fen)) o.fen = Z.fen;
  if (write_fen) { assertion(isdef(Z.fen) && isdef(Z.fen.turn), 'write_fen without fen!!!!'); o.write_fen = true; }
  if (write_player) { o.write_player = true; o.state = Z.state; }
  if (clear_players) o.clear_players = true;
  o.player_status = player_status;
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn_ack() {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly, fen: Z.fen, state: { ack: true }, write_player: true };
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn_clear() {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly, fen: Z.fen, players: Z.playerlist };
  let cmd = 'clear';
  send_or_sim(o, cmd);
}
function take_turn_collect_open() {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly, fen: Z.fen, state: Z.state, write_player: true };
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn_fen() { take_turn(); }
function take_turn_fen_clear() { take_turn(true, false, true); }
function take_turn_fen_write() { take_turn(true, true); }
function take_turn_multi() { if (isdef(Z.state)) take_turn(false, true); else take_turn(false, false); }
function take_turn_resolve(notes) {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly, fen: Z.fen, write_fen: true, write_notes: notes };
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn_spotit() { take_turn(true, true); }
function take_turn_waiting() { take_turn(true, false, false, null); }
function take_turn_write() { take_turn_multi(); }
function takeFromStart(ad, n) {
  if (isDict(ad)) {
    let keys = Object.keys(ad);
    return keys.slice(0, n).map(x => (ad[x]));
  } else return ad.slice(0, n);
}
function takeFromTo(ad, from, to) {
  if (isDict(ad)) {
    let keys = Object.keys(ad);
    return keys.slice(from, to).map(x => (ad[x]));
  } else return ad.slice(from, to);
}
function TakeMove() {
  brd_hisPly--;
  brd_ply--;
  var move = brd_history[brd_hisPly].move;
  var from = FROMSQ(move);
  var to = TOSQ(move);
  if (brd_enPas != SQUARES.NO_SQ) HASH_EP();
  HASH_CA();
  brd_castlePerm = brd_history[brd_hisPly].castlePerm;
  brd_fiftyMove = brd_history[brd_hisPly].fiftyMove;
  brd_enPas = brd_history[brd_hisPly].enPas;
  if (brd_enPas != SQUARES.NO_SQ) HASH_EP();
  HASH_CA();
  brd_side ^= 1;
  HASH_SIDE();
  if ((MFLAGEP & move) != 0) {
    if (brd_side == COLOURS.WHITE) {
      AddPiece(to - 10, PIECES.bP);
    } else {
      AddPiece(to + 10, PIECES.wP);
    }
  } else if ((MFLAGCA & move) != 0) {
    switch (to) {
      case SQUARES.C1: MovePiece(SQUARES.D1, SQUARES.A1); break;
      case SQUARES.C8: MovePiece(SQUARES.D8, SQUARES.A8); break;
      case SQUARES.G1: MovePiece(SQUARES.F1, SQUARES.H1); break;
      case SQUARES.G8: MovePiece(SQUARES.F8, SQUARES.H8); break;
      default: break;
    }
  }
  MovePiece(to, from);
  var captured = CAPTURED(move);
  if (captured != PIECES.EMPTY) {
    AddPiece(to, captured);
  }
  if (PROMOTED(move) != PIECES.EMPTY) {
    ClearPiece(from);
    AddPiece(from, (PieceCol[PROMOTED(move)] == COLOURS.WHITE ? PIECES.wP : PIECES.bP));
  }
}
function takeYourSeats() {
  Zones = {};
  if (T.numPlayers == 2) {
    Zones[T.players[0].id] = createPlayerZone(T.players[0]);
    mLinebreak(dTable);
    Zones.table = createTableZone(true);
    mLinebreak(dTable);
    Zones[T.players[1].id] = createPlayerZone(T.players[1], 'bottom');
  }
}
function test() {
  for (i = 0; i < 10; i++) {
    circles += 1;
    createcircle((i * w / 10), "50%", "100", "0", "hsla(" + (i * 36) + ",100%,50%,0.5)", "url(#f" + circles + ")"); createfilter("-50%", "-50%", "200%", "200%", ["feGaussianBlur"], ["stdDeviation", "5"]);
  }
}
function test_1() {
  deck.mount(d);
}
function test_add_building() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  let type = rChoose(['farm', 'estate', 'chateau']);
  add_a_correct_building_to(fen, uname, type);
  take_turn_fen();
}
function test_add_schwein() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  let type = rChoose(['farm', 'estate', 'chateau']);
  let keys = deck_deal(fen.deck, type[0] == 'f' ? 4 : type[0] == 'e' ? 5 : 6);
  fen.players[uname].buildings[type].push({ list: keys, h: null });
  take_turn_fen();
}
function test_endgame() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  fen.actionsCompleted = [];
  for (const plname of fen.plorder) {
    add_a_correct_building_to(fen, plname, 'chateau');
    add_a_correct_building_to(fen, plname, rChoose(['farm', 'estate', 'chateau']));
    if (coin()) add_a_correct_building_to(fen, plname, rChoose(['farm', 'estate', 'chateau']));
    fen.actionsCompleted.push(plname);
  }
  Z.stage = 5;
  Z.phase = 'king';
  take_turn_fen();
}
function test_engine_run_next(list) {
  if (nundef(list)) {
    list = TestList = arrRange(100, TestNumber - 1);
  }
  if (isEmpty(list)) {
    console.log('*** all tests finished ***');
    TestSuiteRunning = TestRunning = false;
    shield_off();
    return;
  }
  let n = list.shift();
  ITER = 0;
  onclick_ut_n('ari', n);
}
function test_ferro_goal_sorting() {
  let av = ['7R', '3', '5', '33'];
  av = ['33', '3', '5', '4'];
  av.sort((a, b) => Z.fen.allGoals.indexOf(a) - Z.fen.allGoals.indexOf(b));
  return av;
}
function test_ferro_is_set() {
  let cards = ['9Sn', '7Sn', '8Sn', '9Sn'].map(x => fritz_get_card(x));
  let set = ferro_is_set(cards, 1, 3);
  console.log(set);
}
function test_formula0() {
  let fi = nerdamer(`integrate(formula1(x),x)`).buildFunction();
  let y = fi(100);
  console.log('')
  let f = x => formula0(x, 100, 115);
  let sum = 0;
  for (let x = 100; x <= 145; x++) {
    let y = formula0(x, 100, 15);
    sum += y;
    console.log('x', x, 'y', Math.round(y * 100), Math.round(sum));
  }
}
function test_mNode0() {
  console.log('liste', [1, 2, 3].toString());
  let o = dixit_setup(['felix', 'amanda', 'mimi']);
  console.log('o', o);
  recConvertLists(o);
  console.log('converted', o);
  mNode(o, mBy('inpre'), 'setup');
  inpost.innerHTML = jsonToYaml(o)
}
function test_skip_to_actions() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  Z.phase = 'king';
  Z.stage = 5;
  fen.actionsCompleted = [];
  let i = arrMinMax(fen.plorder, x => fen.players[x].hand.length).imin;
  let pl_min_hand = fen.plorder[i];
  console.log('pl w/ min hand is', pl_min_hand);
  let pl = fen.players[pl_min_hand];
  pl.hand = pl.hand.concat(fen.market);
  fen.market = deck_deal(fen.deck, 2);
  for (const plname of fen.plorder) {
    pl = fen.players[plname];
    let n = rNumber(1, pl.hand.length);
    pl.stall = pl.hand.splice(0, n);
  }
  Z.turn = [fen.plorder[rNumber(0, fen.plorder.length - 1)]];
  fen.total_pl_actions = fen.num_actions = fen.players[Z.turn[0]].stall.length;
  fen.action_number = 1;
  take_turn_fen();
}
function test_skip_to_tax() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  Z.phase = 'jack';
  Z.stage = 5;
  let iturn = fen.plorder.length - 1;
  Z.turn = [fen.plorder[iturn]];
  fen.actionsCompleted = fen.plorder.slice(0, iturn);
  console.log('fen.actionsCompleted', fen.actionsCompleted);
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    pl.hand = pl.hand.concat(deck_deal(fen.deck, rNumber(0, 5)));
  }
  take_turn_fen();
}
function test_start_aristo(n = 3, mode = 'multi') {
  let game = 'aristo';
  let playernames = arrTake(['mimi', 'felix', 'amanda', 'lauren', 'gul', 'nasi'], n);
  let playmodes = ['human', 'human', 'human', 'human', 'human', 'human'];
  let strategies = ['random', 'random', 'random', 'random', 'random', 'random', 'random'];
  let i = 0; let players = playernames.map(x => ({ name: x, strategy: strategies[i], playmode: playmodes[i++] }));
  let options = { mode: mode, commission: 'no' };
  start_game(game, players, options);
}
function test_start_ferro(mode = 'multi') {
  let game = 'ferro';
  let playernames = ['mimi', 'lauren', 'felix'];
  let playmodes = ['human', 'human', 'human'];
  let strategies = ['random', 'random', 'random'];
  let i = 0; let players = playernames.map(x => ({ name: x, strategy: strategies[i], playmode: playmodes[i++] }));
  let options = { mode: mode, thinking_time: 20 };
  start_game(game, players, options);
}
async function test_start_test_user_endscreen() {
  console.log('na geh');
  let fen = "felix:20,amanda:14,mimi:13,gul:12";
  DB = await route_path_yaml_dict('./DB.yaml');
  console.log('DB', DB);
  present_non_admin_user('gul');
}
function test_timestep_js_vs_php() {
  console.log('js', get_timestamp());
  to_server({}, 'timestamp_test');
}
function test_ui_extended() {
  mClear(document.body);
  let d1 = mDom(document.body, {}, { classes: 'fullpage airport' });
  let [dl, dr] = mColFlex(d1, [7, 2]);
  for (const d of [dl, dr]) mStyle(d, { bg: rColor('blue', 'green', .5) })
  mStyle(dr, { h: '100vh', fg: 'white' })
  dSidebar = mDiv100(dr, { wmax: 240, overy: 'auto', overx: 'hidden' }, 'dSidebar'); //,{h:window.innerHeight},'dSidebar')
  dLeft = dl;
  onresize = create_left_side_extended;
  create_left_side_extended();
}
function test0() {
  dTable.onclick = game_add_default_item;
}
function test0_ari_flip_one_card() {
  let c = ari_get_card('QHo');
  mAppend(dTable, iDiv(c));
  face_down(c);
  iDiv(c).onclick = () => anim_toggle_face(c);
}
function test0_aristo_setup() {
  let g = { func: aristo(), options: get_default_options('aristo') };
  g.fen = g.func.setup(['felix', 'mimi'], {});
  console.log('fen', g.fen);
}
function test0_boa_bw_fa() {
  let d = mDiv('dHome', { w: 200, h: 200, bg: 'red' }, 'd', `<i class="fa fa-car"></i>`);
  d.onclick = () => toggle_bw_symbol(d.firstChild);
}
function test0_canvas_overlay() {
  let pin = canvas_overlay();
  let f = x => x + rGaussian(-.01, .04);
  run_for_seconds(2, () => map_moveby(pin, f, f))
}
function test0_car_nomath() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop);
  C.add({ w: 30, h: 25, color: 'red', draw: draw_car, update: update_car, turn_inc: 10, v: { a: 280, mag: 5 } });
  C.add({ x: 30, y: -100, color: 'green', w: 35, h: 25, draw: draw_car, update: update_car, v: { a: 0, mag: 3 } });
  C.draw();
}
function test0_divRestOfPage() {
  console.log('DB', DB);
  console.log('C52', C52);
  let state = DB.tables.t0;
  console.log('state', state);
  var dMain = document.getElementById('dMain');
  let dMenu = mDiv(dMain, { bg: 'blue' }, null, '<span>hallo</span>');
  let bMenu = mButton(UnicodeSymbols.menu, null, null, null, 'mybutton');
  mInsertFirst(dMenu, bMenu);
  let dRest = mDivRestOfPage(dMain, dMenu);
  let bTest = mButton('test', () => mSize(dMenu, 20, 80, '%'), dMenu, null, 'mybutton');
}
function test0_load_user() {
  let user = load_user(queryStringToJson().user);
}
function test0_nerd() {
  var core = nerdamer.getCore();
  var _ = core.PARSER;
  core.Math2.custom = function (x) { return (100 * formula1(x)).toFixed(4); };
  _.functions.custom = [, 1];
  var x = nerdamer('custom(140)').evaluate();
  console.log(x.toString());
}
function test0_orig() {
  var map = L.map('map');
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  L.Routing.control({
    waypoints: [
      L.latLng(57.74, 11.94),
      L.latLng(57.6792, 11.949)
    ],
    routeWhileDragging: true
  }).addTo(map);
}
function test0_random() {
  let n = rNumber(12, 20);
  console.log('n', n)
}
function test0_show_all_inno_cards() {
  clearElement(dTable);
  for (const k in InnoById) {
    let ci = InnoById[k];
    console.log('ci', ci);
    if (ci.exp[0] == 'F') inno_present_card(dTable, k);
  }
}
async function test0_simulateClick() {
  let info = await route_path_yaml_dict('../base/assets/lists/info.yaml');
  downloadAsYaml(info, 'info');
}
function test0_turn_loader_off() {
  mClassReplace(mBy('loader_holder'), 'loader_off');
}
async function test00() {
  set_run_state_no_server();
  onpagedeactivated(() => { fiddleSave(); dbSave(); });
  await load_syms();
  await load_db();
  let dicode = CODE.di = await route_path_yaml_dict('../basejs/z_all.yaml');
  let dijustcode = CODE.justcode = await route_path_yaml_dict('../basejs/z_allcode.yaml');
  let dihistory = CODE.history = await route_path_yaml_dict('../basejs/z_allhistory.yaml');
  dTable = mSection({ h: window.innerHeight - 68 }, 'dTable');
  fiddleInit();
  show_sidebar(sortCaseInsensitive(get_keys(dicode.func)), onclickCodeInSidebar);
  onclickCodeInSidebar('mAutocomplete')
}
function test00_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let d = mDiv100(dMain, { bg: 'blue', position: 'relative', });
  let d1 = mDiv(d, { h: '100%', w: 100, position: 'absolute', z: 1, top: 0, left: 0, overflow: 'hidden', transition: '0.5s' }, null, 'hallo', ['w3-blue']);
  let d2 = mDiv(d, { maleft: 100, h: '100%', box: true, transition: '0.5s' }, null, null, ['w3-orange'])
  d2.onclick = () => {
    mToggle(d1, 'width', 0, 100); mToggle(d2, 'margin-left', 0, 100);
  }
}
function test0000000() {
  return 4;
}
function test01() {
  UIS.a_d_game.elem.style.textAlign = 'center';
  let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults().attach();
  let g = new MMS({ parent: svg, type: 'g' }).attach();
  addManualCircle(g);
}
function test01_modifyUser() {
  lookupAddToList(U, ['games', 'gAristocracy', 'running'], 2);
  changeUserTo('mia');
}
function test01_one_deck() {
  let d1 = document.createElement('div');
  d1.id = 'myContainer';
  document.body.appendChild(d1);
  var d = d1;
  let deck = createDeckWithJokers();
  attachTo(d, deck);
}
function test01_show_w3colors() {
  let dMain = mBy('dMain');
  mCenterCenterFlex(dMain);
  for (const c of [wblue, wred, worange, wgreen, wamber, wyellow, wbrown]) {
    let d = mDiv(dMain, { w: 100, h: 100, bg: c, margin: 10 });
  }
}
function test02() {
  let code = AU.ta.value;
  let disub = computeClosure(code);
  let keys = {};
  for (const type in disub) {
    let klist = sortCaseInsensitive(get_keys(disub[type]));
    klist.map(x => keys[x] = disub[type][x]);
  }
  CODE.lastClosure = disub;
  CODE.closureKeys = keys;
  let ksorted = [];
  for (const k of CODE.keysSorted) {
    if (isdef(CODE.closureKeys[k])) ksorted.push(k);
  }
  CODE.closureKeysSorted = ksorted;
}
function test02_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let d = mDiv100(dMain, { position: 'relative', });
  let d1 = mDiv(d, { bg: wdeeporange });
  let d2 = mDiv(d, { bg: worange });
  makeSidebar00(d, d1, d2);
}
function test02_grid_rxc() {
  let d = addGridToBody(8, 8);
  d.style.setProperty('height', '50%')
}
function test02_show4Decks() {
  let hand = G.instance.players[0].hand.getIndices();
  console.log(hand)
  showCards52(hand, 'down');
  showCards52(hand);
  showCards52(hand, 'up');
  showCards52(hand, 'left');
  mLinebreak(dTable);
}
function test02_showCard() {
  G.instance.players[0].hand.map(x => Card52.show(x, dTable));
  mLinebreak(dTable, 25);
  G.instance.players[1].hand.map(x => Card52.show(x, dTable));
}
function test02_showDeckFaceDown() {
  let hand = G.instance.players[0].hand;
  hand.showDeck(dTable);
  console.log(hand[0].faceUp)
  hand.turnFaceDown();
}
function test02_turnCard() {
  let pl = G.instance.players[0];
  let card = pl.hand.topCard();
  console.log(card);
  Card52.show(card, dTable);
  setTimeout(() => Card52.turnFaceDown(card), 1000)
  setTimeout(() => Card52.turnFaceUp(card), 2000)
}
function test02_turnDeckFaceDown() {
  let hand = G.instance.players[0].hand;
  showCards52(hand, 'down');
  console.log(hand[0].faceUp)
  hand.turnFaceDown();
}
function test03() {
  if (nundef(CODE.closureKeysSorted)) test1();
  console.log('closure', CODE.closureKeysSorted);
  let text = CODE.closureKeysSorted.map(x => CODE.justcode[x]).join('\r\n');
  downloadAsText(text, 'hallo', 'js');
}
function test03_2Hands() {
  let h1 = iMakeHand([0, 1, 2, 3, 4], 'h1');
  let h2 = iMakeHand([13, 14, 15, 16, 17], 'h2');
  setTimeout(test03_2Hands_transferStarts, 1000);
}
function test03_2Hands_transfer() {
  let deck1 = Daat.h1.deck;
  let deck2 = Daat.h2.deck;
  let item = Daat.item;
  deck1.addTop(item.val);
  deck2.remove(item.val);
  iPresentHand(Daat.h1);
  iPresentHand(Daat.h2);
  iSortHand(Daat.h1)
}
function test03_2Hands_transferStarts() {
  let h1 = Daat.h1.iHand;
  let n1 = h1.items.length;
  let h2 = Daat.h2.iHand;
  let n2 = h2.items.length;
  let c = chooseRandom(h2.items);
  Daat.item = c;
  let w = c.w;
  let ov = w / 4;
  let xOffset = n1 * ov;
  iMoveFromTo(c, h2.div, h1.div, test03_2Hands_transfer, { x: xOffset, y: 0 });
}
function test03_2HandsRandom() {
  let h1 = iMakeHand([0, 1, 2, 3, 4], 'h1');
  let h2 = iMakeHand([13, 14, 15, 16, 17], 'h2');
  setTimeout(test03_2Hands_transferStarts, 1000);
}
function test03_addCard() {
  let h = Daat.hand;
  let n = h.count();
  console.log('hand has', n, 'cards');
  let c = Daat.item;
  let w = c.w;
  let ov = w / 4;
  let xOffset = n * ov;
  iMoveFromTo(Daat.item, Daat.item.div.parentNode, Daat.zone, transferElement, { x: xOffset, y: 0 });
}
function test03_addToZone() {
  let items = i52([3, 13, 23]);
  let z1 = mZone(dTable);
  iAppend(z1, items[0]);
  iStyle(z1, { padding: 20, box: true });
  let item2 = i52(20);
  iAppend(z1, item2)
  iCenter(item2, -25, 0);
  return;
  let iHand = iSplay(items, z1.div, null, 'right', 20, '%', false, false);
  console.log(iHand);
  mStyleX(iHand.div, { padding: 20, rounding: 10, bg: 'pink' });
}
function test03_basics() {
  let b = getBounds(dTable); console.log(b.width, b.height); mStyleX(dTable, { bg: 'red' });
  let deck = range(0, 51).map(x => i52(x));
  iResize52(deck, 40);
  iSplay(deck, dTable)
  mLinebreak(dTable, 10);
  let d = mCanvas(dTable);
  let item = iAppend52(13, d);
  mRot(item.div, 45);
  mLinebreak(dTable, 10);
}
function test03_centerToCenter() {
  let styles = { w: 200, h: 200, bg: 'random' };
  mStyleX(dTable, { bg: 'yellow' });
  let z1 = mZone(dTable, styles); z1.id = 'z1';
  mLinebreak(dTable, 10);
  let z2 = mZone(dTable, styles); z2.id = 'z2';
  let item1 = iAppend52(24, z1);
  let di1 = item1.div;
  mCenterAbs(di1);
  let item2 = iAppend52(28, z2);
  let di2 = item2.div;
  mCenterAbs(di2);
  console.log(di1.parentNode)
  iMoveFromTo(item2, z2, z1);
  setTimeout(() => iMoveFromTo(item1, z1, z2), 1000);
  setTimeout(() => iMoveFromTo(item2, z1, z2), 2000);
}
function test03_centerToCenter_trial1() {
  let z1 = mZone(dTable); z1.id = 'z1';
  mLinebreak(dTable, 10);
  let item = iAppend52(24, z1);
  let di = item.div;
  mCenterAbs(di);
  return;
  let z2 = mZone(dTable); z2.id = 'z2';
  let item2 = iAppend52(28, z2);
  let di2 = item2.div;
  mCenter(di2);
  console.log(di.parentNode)
  di.onclick = moveFromTo(item2, z2, z1);
}
function test03_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let d = mDiv100(dMain, { position: 'relative', });
  let d1 = mDiv(d, { bg: wdeeporange });
  let d2 = mDiv(d, { bg: worange });
  let sb = iSidebar01(d, d1, d2, d2, 200);
  sb.fToggle();
}
function test03_grid_whrc() {
  let d1 = addDivToBody(100, 50, '%')
  addGridTo(d1, 8, 8);
}
function test03_habenItemsEinZNachSplay() {
  let items = i52([3, 13, 23]);
  console.log(items)
  console.log(items[0].z);
  iSplay(items, dTable);
  console.log(items[0].z);
}
function test03_komischeBubbles() {
  let dover = mDover(dTable); mStyleX(dover, { bg: '#00000080' });
  item = i52(25);
  item.div = mText('hallo', dover, { padding: 25 });
  container = dover;
  mClass(container, 'container');
  mClass(item.div, 'bubble2')
  item.div.style.setProperty('--xStart', '0px');
  item.div.style.setProperty('--xEnd', '100px');
  item.div.style.setProperty('--yStart', '0px');
  item.div.style.setProperty('--yEnd', '-100px');
  dTable.addEventListener("mousemove", updateBubbleColors);
}
function test03_left() {
  let d = mDover(dTable);
  let item = iAppend52(13, d);
  item.div.animate([
    { position: 'absolute', left: '0px', top: '0px' },
    { position: 'absolute', left: '220px', top: '110px' },
  ], {
    duration: 500,
    fill: 'forwards',
  });
}
function test03_richtungCenter() {
  let d = mDover(dTable);
  let item = iAppend52(13, d);
  let di = item.div;
  di.style.position = 'absolute';
  let parent = d;
  let tablePos = getBounds(di, false, dTable);
  console.log('tablePos', tablePos.x, tablePos.y);
  mLinebreak(dTable, 100)
  let dParent = mDiv(dTable, { w: 200, h: 200, bg: 'yellow' });
  let center = actualCenter(dParent, false, dTable);
  let b = getBounds(dParent, false, dTable);
  console.log('center of yellow', center.x, center.y, b)
  let offset = { w: 35, h: 55 };
  center.x -= offset.w;
  center.y -= offset.h;
  item.div.animate([
    { position: 'absolute', left: '0px', top: '0px' },
    { position: 'absolute', left: '' + center.x + 'px', top: center.y + 'px' },
  ], {
    duration: 500,
    fill: 'forwards',
  });
}
function test03_rotate() {
  let d = mCanvas(dTable);
  let item = iAppend52(13, d);
  item.div.animate([
    { transform: 'rotate(90deg)' },
  ], {
    duration: 500,
  });
}
function test03_sortDeck() {
  let h1 = iMakeHand([7, 10, 21, 2, 43, 4], 'h1');
  iSortHand(h1);
}
function test03_splayHand() {
  let h = Daat.hand = new Deck();
  h.init([3, 4, 5, 6, 13, 23]);
  console.log(h); let cards = h.cards(); console.log(cards);
  let zHand = Daat.zone = iHandZone();
  let items = i52(h.cards());
  let handItem = Daat.iHand = iSplay(items, zHand);
  let z = iHandZone();
  let item = Daat.item = iAppend52(18, z);
  console.log('Daat', Daat)
  setTimeout(test03_addCard, 1000);
}
function test03_translate() {
  let d = mCanvas(dTable);
  let item = iAppend52(13, d);
  item.div.animate([
    { transform: 'translate(0px,0px)' },
    { transform: 'translate(300px,200px)' }
  ], {
    duration: 500,
    iterations: Infinity,
    direction: 'alternate'
  });
}
function test03_trash() {
  let dover = mDover(dTable); mStyleX(dover, { bg: 'pink' });
  b = getBounds(dover); console.log('dover', b.width, b.height);
  mRemoveStyle(dover, ['background-color']);
  item = i52(35);
  mAppend(item.div, dover);
  anim1(item.div, 'left', 0, 200, 1000);
}
function test04() {
  dTable = mSection({ h: window.innerHeight - 68 }, 'dTable');
  dSearch = mSection({}, 'dSearch'); mInputLineWithButtons(dSearch, { Go: fiddleSearch }, 'grid');
  show_sidebar(sortCaseInsensitive(get_keys(CODE.di.func)), onclickCodeInSidebar);
  onclickCodeInSidebar(rChoose(CODE.keylist)); 
}
function test04_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let d = mDiv100(dMain, { position: 'relative', });
  let d1 = mDiv(d, { bg: wdeeporange });
  let d2 = mDiv(d, { bg: worange });
  let sb = iSidebar04(d, d1, d2, d2, 50);
  sb.addContent('wwwwwwwwwwwwwwwwwwwwwwwwww');
  sb.toggle();
  sb.addContent('s');
  sb.toggle();
}
function test04_grid9_whrc() {
  let d1 = addDivToBody(100, 50, '%')
  let cells = addGrid9To(d1, 1, 1);
  console.log(cells)
  let d = cells[1][1];
  describe(d);
  clearElement(d);
  describe(d);
  addGrid9To(d, 1, 1);
  describe(d);
}
function test04_textItems() {
  clearElement(dTable);
  let items = getRandomItems(24, 'object', true, false);
  registerItems(items);
  items.map(x => x.div.onclick = togglePic)
  console.log('items', items)
  presentItems(items, dTable, 4);
}
function test05() {
  dTable = mSection({ h: window.innerHeight - 128 }, 'dTable');
  dSearch = mSection({ padding: 2 }, 'dSearch'); mInputLineWithButtons(dSearch, { Go: fiddleSearch }, 'grid');
  show_sidebar(sortCaseInsensitive(get_keys(CODE.di.func)), onclickCodeInSidebar);
  onclickCodeInSidebar('SimpleGrid');
}
function test05_deck_in_grid() {
  let d1 = addDivToBody(100, 50, '%')
  let deck = createDeckWithJokers();
  attachTo(d1, deck);
}
function test05_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let b = mButton('☰', null, dMain, { fz: 36 }, 'mybutton');
  let d = mDiv100(dMain, { matop: 4, position: 'relative', });
  let dSide = mDiv(d, { bg: 'silver' });
  let dContent = mDiv(d, { bg: worange });
  let sb = iSidebar(d, dSide, dContent, b, 120, false);
}
function test06() {
  let divnames = get_keys(CODE.di.var);
  divnames = divnames.filter(x => x[0] == 'd' && x[1] == x[1].toUpperCase() && !isNumber(x[x.length - 1]));
  show_sidebar(sortCaseInsensitive(divnames), onclickCodeInSidebar);
  console.log('divnames', divnames.join());
  let s = 'dActions,dAux,dAuxContent,dBottom,dButtons,dCenter,dCode,dConsole,dContent,dCurrent,dError';
  let s1 = 'dFeedback,dFiddle,dFleetingMessage,dFooter,dGameControls,dGames,dGameTitle,dHeader,dHelp,dHint';
  let s2 = 'dInstruction,dLeft,dLeiste,dLevel';
  let s3 = 'dLineBottom,dLineBottomLeft,dLineBottomMiddle,dLineBottomOuter,dLineBottomRight';
  let s4 = 'dLineTable,dLineTableLeft,dLineTableMiddle,dLineTableOuter,dLineTableRight';
  let s5 = 'dLineTitle,dLineTitleLeft,dLineTitleMiddle,dLineTitleOuter,dLineTitleRight';
  let s6 = 'dLineTop,dLineTopLeft,dLineTopMiddle,dLineTopOuter,dLineTopRight';
  let s7 = 'dLinks,dLoggedIn,dLogo,dMain,dMap,dMenu,dMessage,dMoveControls,dOben';
  let s7a = 'dPage,dParent,dPlayerNames,dPlayerStats';
  let s8 = 'dPuppet,dRechts,dRight,dScore,dSettings,dSidebar,dStatus,dSubmitMove';
  let s9 = 'dTable,dTableName,dTables,dTableShield,dTitle,dTop,dUnten,dUserControls,dUsers';
}
function test06_coButtonSidebarDiv() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let co = coButtonSidebarDiv(dMain);
  console.log('co', co)
  let co2 = coButtonSidebarDiv(co.div);
}
function test06_one_deck() {
  let d1 = document.createElement('div');
  d1.id = 'myContainer';
  document.body.appendChild(d1);
  var d = d1;
  d.style.width = '100px';
  d.style.height = '100px';
  d.style.backgroundColor = 'blue';
  let deck = createDeckWithJokers();
  let card = deck.cards[54];
  deck.flip()
  attachTo(d, card);
  let domel = card.elem;
  let info = getTransformInfoDOM(domel)
}
function test07() {
  document.body.style.height = '100vh';
  let div1 = addDivToBody(100, 50, '%', 'blue');
  let div2 = addDivToBody(100, 50, '%', 'green');
  var deck1 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  let ms1 = new DeckMS('deck1', deck1);
  ms1.attachTo(div1);
  deck1.cards.forEach(function (card, i) { card.enableDragging(); card.enableFlipping(); });
  var deck2 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  let ms2 = new DeckMS('deck2', deck2);
  ms2.attachTo(div2);
}
function test07_menu_sidebar_div() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  setRect(dMain);
  let item = iMenuSidebarDiv(dMain, options);
  let dover = mDover(dMain, { bg: 'red', alpha: .25 });
  setTimeout(() => iDelete(item.live.sidebar), 5000)
}
function test08() {
  document.body.style.height = '100vh';
  let div1 = addDivToBody(100, 50, '%', 'blue');
  let div2 = addDivToBody(100, 50, '%', 'green');
  var deck1 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  let ms1 = new DeckMS('deck1', deck1);
  ms1.attachTo(div1);
  let cells = addGridTo(div2, 2, 2, '10px');
  let d = cells[0][1];
  clearElement(d);
  var deck2 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  let ms2 = new DeckMS('deck2', deck2);
  ms2.attachTo(d);
}
function test08_WTF() {
  let d = mBy('dMain');
  let menu = iMenuLine(d, { bg: 'dark' });
  console.log('iDiv', iDiv(menu));
  let title = mText('hello!', iDiv(menu), { fz: 30 });
}
function test09() {
  document.body.style.height = '100vh';
  let div1 = addDivToBody(100, 50, '%', 'blue');
  let div2 = addDivToBody(100, 50, '%', 'green');
  let rows1 = 3;
  let cols1 = 3;
  let cells = addGridTo(div2, rows1, cols1, '10px');
  console.log(cells);
  for (let i = 0; i < rows1; i++) {
    for (let j = 0; j < cols1; j++) {
      let cell = cells[i][j];
      clearElement(cell);
      let mobj = new DeckMS('d' + rows1 + '_' + cols1, makeDeck({ kind: 'deck52', N: 30, nJokers: 5 }));
      mobj.attachTo(cell);
      enableFlipForDeck(mobj.o);
      enableDragForDeck(mobj.o);
    }
  }
}
function test09_WTF_das_ist_ambra() {
  let comp = qPageMST(mBy('dMain'), qOptions());
  ex00_sidebar(comp.sidebar);
}
function test09_WTF_start() {
  ex01_table(comp.dContent);
  mCenterFlex(dTable);
  let tileStyles1 = { bg: 'pink', w: 300, h: 300, margin: 20 };
  let [rows, cols] = [5, 5];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let d1 = mDiv(dTable, tileStyles1);
      if (coin()) iMenuSidebarDiv(d1, qOptions());
    }
    mGap(dTable, 0);
  }
}
function test1(map) {
  var baseballIcon = L.icon({
    iconUrl: '../leaf94/baseball-marker.png',
    iconSize: [32, 37],
    iconAnchor: [16, 37],
    popupAnchor: [0, -28]
  });
  function onEachFeature(feature, layer) {
    var popupContent = '<p>I started out as a GeoJSON ' +
      feature.geometry.type + ', but now I\'m a Leaflet vector!</p>';
    if (feature.properties && feature.properties.popupContent) {
      popupContent += feature.properties.popupContent;
    }
    layer.bindPopup(popupContent);
  }
  var bicycleRentalLayer = L.geoJSON([bicycleRental, campus], {
    style: function (feature) {
      return feature.properties && feature.properties.style;
    },
    onEachFeature: onEachFeature,
    pointToLayer: function (feature, latlng) {
      return L.circleMarker(latlng, {
        radius: 8,
        fillColor: '#ff7800',
        color: '#000',
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8
      });
    }
  }).addTo(map);
  var freeBusLayer = L.geoJSON(freeBus, {
    filter: function (feature, layer) {
      if (feature.properties) {
        return feature.properties.underConstruction !== undefined ? !feature.properties.underConstruction : true;
      }
      return false;
    },
    onEachFeature: onEachFeature
  }).addTo(map);
  var coorsLayer = L.geoJSON(coorsField, {
    pointToLayer: function (feature, latlng) {
      return L.marker(latlng, { icon: baseballIcon });
    },
    onEachFeature: onEachFeature
  }).addTo(map);
}
function test1_3colHeaderFooter() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: '#ABC', hmin: 150 }, 'dHeader', 'header');
  let dOuter = mDiv(dMain, { bg: '#678', hmin: 500, display: 'flex', 'flex-flow': 'row wrap' }, 'dOuter');
  let dLeft = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
  let dRight = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dRight', 'right');
  let dFooter = mDiv(dMain, { bg: '#456', hmin: 100 }, 'dFooter', 'footer');
}
function test1_ari_10cards(otree) {
  let n = 10;
  let list = choose(get_keys(Aristocards), n);
  let items = list.map(x => ari_get_card(x));
  let cont = ui_make_deck_container(n, dTable, { bg: 'random', padding: 4 });
  let topmost = ui_add_cards_to_deck_container(cont, items, list);
  iDiv(topmost).onclick = () => anim_toggle_face(topmost);
}
function test1_basic() {
  var map = L.map('map');
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  console.log('geo', Geo)
  let [p1, p2] = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse];
  map.setView(p1, 16)
  M = L.Routing.control({
    waypoints: [
      L.latLng(p1[0], p1[1]),
      L.latLng(p2[0], p2[1])
    ],
    routeWhileDragging: true
  }).addTo(map);
}
function test1_bw_widget_boa() {
  let dpop = mBy('dPopup');
  show(dpop);
  mStyle(dpop, { top: 50, right: 10 });
  let prefix = 'boa';
  let d = mDiv(dpop, { wmin: 200, hmin: 200, bg: 'red' }, 'dBw');
  let d2 = mDiv(d, { bg: 'dodgerblue', fg: 'white' }, null, 'your bitwarden vault');
  let d3 = mDiv(d, { bg: '#eee', fg: 'dimgray', padding: 8 }, null, 'LOGINS');
  let d4 = mDiv(d, { bg: 'white', fg: 'black' });
  let d5 = mDiv(d4, { display: 'flex' });
  let dimg = mDiv(d5, { bg: 'white', fg: 'black' }, null, `<img src='../rechnung/images/boa.png' height=14 style="margin:8px">`);
  let dtext = mDiv(d5, { cursor: 'pointer' }, null, `<div>boa</div><div style="font-size:12px;color:gray">gleeb69</div>`);
  dtext.onclick = () => onclick_bw_symbol(prefix)
  let d6 = mDiv(d4, { display: 'flex', padding: 2 });
  let disyms = {
    bwtext: { postfix: 'userid', matop: 2, maright: 0, mabottom: 0, maleft: 0, sz: 27 },
    bwcross: { postfix: 'cross', matop: 2, maright: 0, mabottom: 0, maleft: -13, sz: 25 },
    bwkey: { postfix: 'pwd', matop: 0, maright: 0, mabottom: 0, maleft: -12, sz: 27 },
    bwclock: { postfix: 'clock', matop: 0, maright: 0, mabottom: 0, maleft: 0, sz: 25 },
  }
  for (const k of ['bwtext', 'bwcross', 'bwkey']) {
    let o = disyms[k];
    let [filename, styles] = [k, disyms[k]];
    let path = `../rechnung/images/${filename}.png`;
    let [sz, ma] = [styles.sz, `${styles.matop}px ${styles.maright}px ${styles.mabottom}px ${styles.maleft}px`];
    console.log('ma', ma);
    let img = mDiv(d6, { paright: 16 }, null, `<img src='${path}' height=${sz} style="margin:${ma}">`);
    if (k != 'bwcross') {
      mStyle(img, { cursor: 'pointer' });
      img.onclick = () => onclick_bw_symbol(prefix, o.postfix);
    }
  }
  mFlexSpacebetween(d4);
  let d7 = mDiv(d, { bg: '#eee', fg: 'dimgray', padding: 7 }, null, 'CARDS');
  let d8 = mDiv(d, { bg: 'dodgerblue', fg: 'white' }, null, `<img src='../rechnung/images/rest_bw.jpg'>`);
}
async function test1_can_I_get_new_cities(min = 25000) {
  let info = await route_path_yaml_dict('../base/assets/lists/info.yaml');
  let text = await route_path_text('../base/mapdata/cities.csv');
  let cities = M.cities = csv2list(text);
  let capitals = [];
  let new_cities = {};
  let num = 0;
  for (const o of cities) {
    let n = o.population;
    if (nundef(n)) continue;
    n = Number(n);
    if (n < min) continue;
    let w1 = o.city_ascii.toLowerCase();
    if (nundef(o.country)) {
      console.log('missing country', o);
      continue;
    }
    num += 1;
    let land1 = o.country.toLowerCase();
    for (const k of info.capital) {
      let w = k.toLowerCase();
      if (w.includes(w1) && w.includes(land1)) {
        capitals.push(o);
        o.capital = 'capital';
      }
      let name = o.name = o.city_ascii;
      if (isdef(new_cities[name]) && new_cities[name].includes('capital')) continue;
      new_cities[name] = `${o.lng},${o.lat},${o.country},${o.capital},${o.population}`;
    }
  }
  downloadAsYaml(new_cities, 'cities');
  return new_cities;
}
function test1_car_math() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', null, true);
  C.add({ w: 30, h: 25, color: 'red', draw: draw_car, update: update_car, turn_inc: 10, v: { a: 280, mag: 5 } });
  C.add({ x: 30, y: -100, color: 'green', w: 35, h: 25, draw: draw_car, update: update_car, v: { a: 0, mag: 3 } });
  C.draw();
}
function test1_change_user() {
  setTimeout(() => {
    mStyle(mBy('user_info'), { opacity: 0 });
    setTimeout(() => {
      let name = chooseRandom(get_user_names(), x => x != Session.cur_user);
      load_user(name);
    }, 1000);
  }, 2000)
}
function test1_maxBounds() { let m1 = create_map({ zoom: 0 }); }
function test1_nerd() {
  test0_nerd();
  let fi = nerdamer(`integrate(custom(x),x)`).buildFunction();
  let y = fi(100);
  console.log('fi(100)', y)
}
function test1_open_sidebar() {
  mBy('b_test').onclick = open_sidebar;
}
function test1_p5_init() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
  iAdd(o, {}, { draw: draw_random_walk });
}
function test1_show_users() {
  show_users();
}
function test10(list) {
  console.log('codebase list', list);
  let text = list.map(x => x.text).join('\n');
  let funcnames = list[0].di.func;
  addModuleExports(funcnames);
}
function test10_0() {
  lookupSet(DA, ['svgsym', suit, color], html);
  let color = 'orange';
  let treff = `
  <path  d="M30 150C35 385 85 400 130 500L-130 500C-85 400 -35 385 -30 150A10 10 0 0 0 -50 150A210 210 0 1 1 -124 -51A10 10 0 0 0 -110 -65A230 230 0 1 1 110 -65A10 10 0 0 0 124 -51A210 210 0 1 1 50 150A10 10 0 0 0 30 150Z"  fill="${color}"></path>
  `;
  let idsym = getUID('x');
  let sym = `
  <symbol id="Treff" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
  `
}
function test10_autocomplete() {
  let map = M.map = create_map({ zoom: 16 });
  map.on('moveend', function (e) { calc_map_dims(); console.log("dims", M.dims); });
  let tb = M.toolbar = create_toolbar(map);
  mButton('Dummy', dummy_reaction, tb);
  mAutocomplete(tb);
}
function test10_function() {
  C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
  let canvas = C.cv;
  C.add({ astep: .1, a: 0, bstep: .1, b: 0, func: x => Math.sin(x), update: test10_update });
}
function test10_queen_html() {
  let htmlWORKS = `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      face="QS"
      height="100%"
      preserveAspectRatio="none"
      viewBox="-120 -168 240 336"
      width="100%"
      fill="#ffff00"
      stroke="green"
      >
      <defs><rect id="XSQ" width="164.8" height="260.8" x="-82.4" y="-130.4"></rect></defs>
      <symbol id="VSQ" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
        <path
          d="M-260 100C40 100 -40 460 260 460M-175 0L-175 -285A175 175 0 0 1 175 -285L175 285A175 175 0 0 1 -175 285Z"
          stroke="green"
          stroke-width="80"
          stroke-linecap="square"
          stroke-miterlimit="1.5"
          fill="none"
        ></path>
      </symbol>
      <symbol id="SSQ" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
        <path
          d="M0 -500C100 -250 355 -100 355 185A150 150 0 0 1 55 185A10 10 0 0 0 35 185C35 385 85 400 130 500L-130 500C-85 400 -35 385 -35 185A10 10 0 0 0 -55 185A150 150 0 0 1 -355 185C-355 -100 -100 -250 0 -500Z"
          fill="green"
        ></path>
      </symbol>
      <symbol id="SQ1" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="green"
          d="M635.39648,0 851.86719,312.33789C895.10685,299.11869 938.83136,290.34833 975,285 924.90197,188.22401 899.89439,94.153799 874.11133,0ZM295.52539,27.285156C246.27551,180.9799 142.75435,335.54042 209.25195,483.08398l-17.43359,13.44922c1.76531,151.10099 30.08527,286.57163 74.54102,398.60938 18.12594,21.287 38.56227,42.11564 61.47851,64.11523 3.61128,3.46683 7.28461,6.96262 11.33789,10.61914L901.47852,970l-0.41407,-0.51953c-0.12219,-0.138 -0.23745,-0.27418 -0.35937,-0.41211 15.27725,17.28278 32.6506,35.12574 52.3164,53.54294C1030.1434,1094.8366 1080,1150 1130,1250c52.9819,-70.6425 98.186,-110.0972 170,-152.7871v-37.6016c-68.6196,39.3343 -116.9422,76.6549 -164.5547,131.9668 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51367,-102.35489 139.07032,-133.86328l-26.7793,-21.49024C896.53697,588.11019 793.22595,665.67487 806.10938,786.48828L699.86133,787.5 568.0625,939.89258 429.48438,939.86328C578.06034,763.29892 745.82856,594.02803 899.1875,455.09961l-9.56836,-10.99023c-28.86687,-3.02061 -55.64392,-10.37642 -80.51758,-21.42774 -1.77605,4.17261 -4.43372,8.02096 -7.94336,11.23438C665.11643,558.39566 525.46983,665.166 419.78906,829.43164L392.45703,811.84766C501.69344,642.05529 644.58723,533.12674 779.21875,409.9375l17.51367,6.86328c-17.74437,-8.98707 -34.48695,-19.8921 -50.29101,-32.48437 -124.71285,29.03155 -208.27492,36.48099 -267.26758,31.98242 0,0 -19.31641,14.60547 -29.31641,14.60547 -15,0 -25.58008,-5.64453 -30.58008,-5.64453 -5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -1.51422,-2.01895 -3.01443,-4.07919 -4.23242,-5.79297l-39.21875,30.25586 10.50977,-0.54493c7.17244,138.45299 -1.25836,281.23598 43.02929,408.13477l-27.41796,17.66602c-1.32891,-2.13106 -2.43311,-4.45616 -3.26758,-6.95704C288.22851,692.7888 295.29422,552.70428 289.59766,421.09961l-69.70313,53.77344 20.20508,-16.59375C187.08454,297.85994 265.54029,182.85491 300.0957,58.960938ZM85,80c-55.000004,50 -100.000004,145 -35,145 9.343263,0 15.215964,-5.70961 19.599609,-15.58984l-0.05469,54.80664C63.116922,255.80043 55.218717,250 45,250c-34.999996,0 -39.999996,70 -5,70 24.46345,0 22.957588,-43.08208 10.8125,-44.93164 53.48157,5.0855 -15.809214,250.16385 -15.302734,296.2207 0.268193,24.38822 6.628431,48.73678 31.46289,56.20899C48.176742,632.49354 35,645.1697 35,660 35,674.30844 47.265656,686.61054 65.384766,692.25586 41.674751,699.57565 35,720.74035 35,740 35,776.24391 48.1356,836.13212 55.517578,866.33008 82.604368,846.54619 106.08392,825.42866 128.83984,800.21875 132.14826,778.91478 135,756.88968 135,740 135,720.60063 128.2285,699.26867 104.15234,691.95898 118.02756,686.75065 129.28173,676.58841 135,660c0,-14.83344 -13.18185,-27.51102 -30.78711,-32.89844 24.05654,-8.65812 30.01787,-32.21714 30.27734,-55.8125C134.99671,525.23221 65.705931,280.15386 119.1875,275.06836 107.04241,276.91792 105.53655,320 130,320c35,0 30,-70 -5,-70 -10.83425,0 -19.06007,6.52154 -25.074219,15.02148L100.25195,209.2793C104.49041,218.99863 110.42097,225 120,225 185,225 140,130 85,80Zm641.48047,287.83789c-86.62544,19.83455 -151.78802,28.17022 -200.80469,29.24219 -14.2248,6.27415 -30.07191,11.92239 -45.7793,18.95898 58.99266,4.49857 142.55438,-2.95118 267.19727,-32.03711 -7.7527,-5.20716 -14.38853,-10.76914 -20.61328,-16.16406zm-370.49024,88.29102c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891ZM1182.5,473.75c-24.0403,0 -48.0562,17.34722 -29.8594,52.02344A45,42.5 0 0 1 1182.5,515a45,42.5 0 0 1 29.8652,10.76367C1230.552,491.09427 1206.538,473.75 1182.5,473.75Zm-54.6914,47.48047c-45.2477,0.77462 -37.6424,97.7377 22.793,66.2168A45,42.5 0 0 1 1137.5,557.5a45,42.5 0 0 1 13.1113,-29.94336c-8.6891,-4.53343 -16.2978,-6.43753 -22.8027,-6.32617zm109.3828,0c-6.5027,-0.11132 -14.1076,1.79222 -22.793,6.32226A45,42.5 0 0 1 1227.5,557.5a45,42.5 0 0 1 -13.1094,29.94336c60.4429,31.53409 68.0505,-65.43824 22.8008,-66.21289zm-24.8301,67.99414A45,42.5 0 0 1 1182.5,600 45,42.5 0 0 1 1152.6348,589.23633c-11.9875,22.85174 -5.6311,38.16959 6.9726,45.95898 -23.6821,34.46419 -48.941,66.02584 -74.9492,96.20703C1079.1653,675.69528 1058.4509,645.45798 1005,670c37.225,16.12754 38.5709,70.31699 75.9492,65.69727 -5.8664,6.76063 -11.768,13.45662 -17.6972,20.10156l15.207,1.88672c7.2551,-8.19076 14.4623,-16.46748 21.6113,-24.85352 5.1929,39.08146 35.0698,-7.57452 67.2129,-5.5 -16.4802,-41.743 -32.0495,-10.50502 -66.4785,4.63672 24.5708,-28.86629 48.4073,-59.08334 70.8027,-91.95508 26.5679,6.12811 61.7407,-10.79807 40.7539,-50.78906zM1255,655c-32.9633,38.74398 -63.8666,77.97963 -125,110 16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110zM811.88477,817.78516c10.86486,41.66548 35.34229,88.00659 78.58593,139.42382 -4.92291,-5.82285 -9.66276,-11.58316 -14.2207,-17.2539l-286.46289,-0.0586 64.60547,-0.45703 75.1914,-86.93945 93.88282,-0.33984c-4.9028,-11.9067 -8.74345,-23.39087 -11.58203,-34.375zM377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5Z"
        ></path>
      </symbol>
      <symbol id="SQ2" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="red"
          d="M557.51758,0 805.9668,330.45703 851.01367,311.99805 635.36719,0Zm78.02148,0 63.76563,90.75C709.99966,65.000167 725,65 725,65 716.50651,26.779299 728.31462,17.104416 733.20117,0ZM820,265 851.86719,312.33789C877.5079,304.49903 903.31958,298.22492 927.6543,293.26562 907.75762,290.72138 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5zm99.12695,216.28711C764.14521,621.01648 595.55342,787.07572 470.35547,940.01172L525,940 685,755h120.41797l-0.0547,-0.41211c6.37431,-102.76161 97.50088,-170.65811 160.41211,-212.22851zm-727.41992,15.5625 -59.86133,46.34766 -0.39648,0.30468c1.93099,12.0459 3.10803,21.69313 3.04101,27.78711 -0.25947,23.59536 -6.2208,47.15438 -30.27734,55.8125C121.81815,632.48898 135,645.16656 135,660 129.28173,676.58841 118.02756,686.75065 104.15234,691.95898 128.2285,699.26867 135,720.60063 135,740c0,16.88968 -2.85174,38.91478 -6.16016,60.21875 -1.95154,2.162 -3.90854,4.29257 -5.87304,6.39453C138.56664,789.96704 153.92711,771.43051 170,750 200.25102,810.50205 230.44886,854.59181 266.85742,895.71484 221.90196,783.10482 193.58426,647.63449 191.70703,496.84961ZM44.53125,610.36133 0,644.61523V902.7832C30.797744,884.46615 56.707359,866.73637 80.427734,846.89844 72.427991,853.57027 64.158102,860.01913 55.517578,866.33008 48.1356,836.13212 35,776.24391 35,740 35,720.74035 41.674751,699.57565 65.384766,692.25586 47.265656,686.61054 35,674.30844 35,660 35,645.1697 48.176742,632.49354 66.972656,627.49805 56.528563,624.35562 49.361734,618.22105 44.53125,610.36133Zm1190.09765,68.79687 -1.1211,1.04688c-20.0542,23.0427 -41.8711,45.665 -71.7441,65.72265 27.117,39.37142 36.6532,80.37363 27.7441,123.12891 25.4392,14.76465 47.2329,33.87001 67.875,55.8418 -10.0896,-28.95393 -26.9566,-68.05217 -64.6191,-89.36328C1229.865,829.72137 1245.3631,819.51581 1260,800c-28.5778,-21.24841 -50.4759,-15.94491 -77.3027,-15.66992 39.149,-21.89578 49.9371,-64.78262 51.9316,-105.17188zM110.74609,819.23828c-0.7889,0.78628 -1.58065,1.56702 -2.37304,2.3457 0.792,-0.77791 1.58362,-1.55961 2.37304,-2.3457zm-5.15234,5.05078c-0.76819,0.74251 -1.53476,1.48679 -2.30664,2.22266 0.77112,-0.73534 1.53841,-1.48017 2.30664,-2.22266zm-5.26172,5.00586c-2.077449,1.94603 -4.165139,3.87648 -6.273436,5.7793 2.104356,-1.90192 4.194747,-3.83083 6.273436,-5.7793zm-6.539061,6.02149c-1.467973,1.32281 -2.945132,2.63598 -4.429688,3.93945 1.482456,-1.30407 2.961518,-2.61456 4.429688,-3.93945zM377.5,862.5a11,22.5 0 0 0 -11,22.5 11,22.5 0 0 0 11,22.5 11,22.5 0 0 0 11,-22.5 11,22.5 0 0 0 -11,-22.5zm225.17578,127.46484a10,10 0 0 0 -10,10 10,10 0 0 0 10,9.99996 10,10 0 0 0 10,-9.99996 10,10 0 0 0 -10,-10zM420,990a10,10 0 0 0 -10,10 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10zm91.13281,0.41016a10,10 0 0 0 -10,10.00004 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10.00004z"
        ></path>
      </symbol>
      <symbol id="SQ3" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#44F"
          d="M472.5,150a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm-140,5a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm23.49023,301.12891c3.54904,108.54757 3.24814,214.77856 28.25977,309.58398 83.90967,-121.45694 183.76187,-211.71291 282.33398,-298.83789 -85.00816,14.89038 -149.26165,18.48851 -200.56445,14.4043 -45.1152,-3.59162 -80.40237,-13.40501 -110.0293,-25.15039zm42.92579,22.92187c22.57573,0.10326 52.52779,2.34383 83.49804,6.2461 65.74558,8.28415 118.15335,21.65893 117.05469,29.87304 -1.09829,8.2139 -56.30922,5.07893 -122.05273,-3.20508 -65.73948,-8.28354 -117.1185,-18.57868 -116.02735,-26.79296 0.53448,-4.02047 14.07178,-6.22853 37.52735,-6.1211zM1117.5,492.5c2.4011,8.40385 4.2266,18.24941 5.4746,28.84375v0.36133c7.3876,-1.36391 16.4655,0.0837 27.2324,5.62304l-21.2675,-21.26757a1.50015,1.50015 0 0 1 1.0449,-2.57617 1.50015,1.50015 0 0 1 1.0761,0.45507l21.2676,21.26758c-5.5291,-10.74776 -6.9807,-19.81297 -5.6289,-27.19336 -10.7286,-1.24895 -20.7021,-3.08593 -29.1992,-5.51367zm130,0c-8.4251,2.40718 -18.2988,4.23414 -28.9238,5.48242h-0.2793c1.3613,7.38557 -0.087,16.46062 -5.6231,27.22266l21.2657,-21.26563a1.50015,1.50015 0 0 1 1.0312,-0.45312 1.50015,1.50015 0 0 1 1.0898,2.57422l-21.2675,21.26757c10.7565,-5.53399 19.8272,-6.98416 27.2109,-5.62695v-0.17187c1.2486,-10.6649 3.081,-20.57644 5.4961,-29.0293zm-853.59961,15.25781c20.38428,0.10329 47.42876,2.34386 75.39258,6.2461 59.36368,8.28422 106.68388,21.65899 105.69141,29.87304 -0.99271,8.21355 -49.91699,8.15671 -109.27735,-0.12695 -59.36371,-8.28422 -106.68391,-21.659 -105.69141,-29.87305 0.48636,-4.01928 12.70935,-6.22659 33.88477,-6.11914zm7.69531,34.67969c15.09367,-0.0753 32.61454,0.81411 50.47852,2.5625 51.50146,5.04084 94.00823,14.75226 93.67578,23.00391 -0.32891,8.2521 -42.34749,10.85536 -93.84961,5.81445C400.39893,568.77752 358.91755,558.00165 359.25,549.75c0.20345,-5.08688 15.52034,-7.17888 42.3457,-7.3125zm590.81446,21.09375c-26.28817,17.83124 -58.00395,39.71623 -85.84375,65.82227L1063.252,755.79883c5.9292,-6.64494 11.8308,-13.34093 17.6972,-20.10156C1043.5709,740.31699 1042.225,686.12754 1005,670c53.4509,-24.54202 74.1653,5.69528 79.6582,61.40234 18.288,-21.22222 36.2025,-43.13214 53.4609,-66.25 -50.4965,-31.89003 -99.3677,-65.63189 -145.70894,-101.62109zm92.24804,167.87109c-1.2353,1.43353 -2.4703,2.86748 -3.709,4.29493 1.3064,-0.16146 2.6533,-0.388 4.0508,-0.69727 -0.1038,-1.21628 -0.2241,-2.40447 -0.3418,-3.59766zm-21.4062,24.39649 1.3242,1.02344C1092.8236,758.22045 1130,765 1130,765c33.2353,-17.40792 57.5278,-36.95014 78.082,-57.38477 -19.9562,-11.65548 -39.7017,-23.55345 -59.2109,-35.71875 -15.5528,20.88792 -31.6462,40.7815 -48.0664,60.07227 34.429,-15.14174 49.9983,-46.37972 66.4785,-4.63672 -32.1431,-2.07452 -62.02,44.58146 -67.2129,5.5 -7.149,8.38604 -14.3562,16.66276 -21.6113,24.85352zM399.88477,574.98828c12.13924,-0.0753 26.23048,0.81416 40.59765,2.5625 41.42116,5.04089 74.78321,15.81675 74.51563,24.06836 -0.26463,8.25206 -34.05885,10.85531 -75.48047,5.81445 -41.42116,-5.04089 -74.78321,-15.81675 -74.51563,-24.06836 0.16364,-5.08693 13.30756,-8.24338 34.88282,-8.37695zm814.90823,12.6836 21.2675,21.26757a1.50015,1.50015 0 1 1 -2.121,2.1211l-21.2657,-21.26563c5.5369,10.76367 6.9837,19.84044 5.6211,27.22656h0.3223c10.6094,1.24816 20.4685,3.07443 28.8828,5.47852 -2.4278,-8.49731 -4.2627,-18.47029 -5.5117,-29.19922 -7.3807,1.35234 -16.4468,-0.0994 -27.1953,-5.6289zm-64.5879,0.002c-10.7501,5.53028 -19.8161,6.98044 -27.1973,5.62695v0.0723c-1.2488,10.70195 -3.0853,20.64836 -5.5078,29.12695 8.4975,-2.42785 18.4701,-4.26471 29.1992,-5.51367 -1.3518,-7.38039 0.1,-16.44561 5.6289,-27.19336l-21.2676,21.26758a1.50015,1.50015 0 1 1 -2.121,-2.1211zM399.95117,608.2207c7.75591,-0.014 16.33902,0.59569 25.04883,1.7793 30.51033,4.14665 55.19775,16.74619 55.24414,25 0.0491,8.25469 -24.64792,11.5847 -55.16016,7.4375 -30.51033,-4.14665 -55.28173,-14.19933 -55.32812,-22.45312 -0.0324,-5.62262 11.68692,-11.73096 30.19531,-11.76368zm2.94141,36.28321c3.92832,-0.0157 8.00124,0.15115 12.10742,0.49609 25.08573,2.10744 44.77796,7.02839 45.42188,14.97852 0.64298,7.94981 -19.17087,12.68576 -44.25586,10.57812 -25.08573,-2.10744 -45.94398,-10.26081 -46.5879,-18.21094 -0.52278,-6.4668 13.79255,-7.76393 33.31446,-7.84179zm-6.3711,30.78125c1.53788,10e-4 3.10151,0.0612 4.67383,0.17968 15.24356,1.1523 28.12847,7.43255 28.7793,14.02735 0.6519,6.59512 -11.17778,11.00764 -26.42188,9.85547 -15.24356,-1.1523 -28.12847,-7.43255 -28.77929,-14.02735 -0.57317,-5.81151 8.60794,-10.04793 21.74804,-10.03515zm-2.7207,30.4707c0.97501,0.002 1.96625,0.0499 2.96289,0.14453 9.66123,0.91446 17.82809,5.89851 18.24219,11.13281 0.4126,5.23472 -7.08576,8.73687 -16.74805,7.82227 -9.66123,-0.91446 -17.82809,-5.89851 -18.24219,-11.13281 -0.3645,-4.61356 5.45528,-7.97697 13.78516,-7.9668zm906.19922,0.0781 -34.2773,2.85547c0.2249,20.00253 -6.7832,39.15319 -30.7188,56.31055 24.0241,2.30082 45.4719,10.59792 60,35 -9.9971,24.98116 -26.6502,40.00143 -50,45 19.6816,21.91005 28.1768,47.18324 30.0293,74.45312l0.01,0.008 24.957,11.09375zm-167.2656,64.20508c0.2372,0.44647 0.4708,0.89347 0.7051,1.33985 -0.2343,-0.44637 -0.4679,-0.89339 -0.7051,-1.33985zm3.041,5.88282c0.083,0.16606 0.171,0.33199 0.2539,0.49804 -0.083,-0.16604 -0.1705,-0.33202 -0.2539,-0.49804zm2.6758,5.48437c0.2147,0.45253 0.425,0.90499 0.6367,1.35742 -0.2117,-0.45239 -0.4219,-0.90493 -0.6367,-1.35742zm2.455,5.32422c0.1795,0.40036 0.3641,0.80089 0.5411,1.20117 -0.177,-0.40029 -0.3615,-0.80081 -0.5411,-1.20117zm2.5958,5.98437c0.2099,0.50184 0.413,1.00415 0.6191,1.50586 -0.2062,-0.5018 -0.4092,-1.00393 -0.6191,-1.50586zm2.0703,5.11719c0.1975,0.50277 0.4,1.00516 0.5937,1.50781 -0.1937,-0.50252 -0.3962,-1.00516 -0.5937,-1.50781zm2.3418,6.1875c0.1922,0.53072 0.3764,1.06121 0.5644,1.5918 -0.188,-0.53055 -0.3722,-1.06112 -0.5644,-1.5918zm1.7324,4.96485c0.2042,0.60477 0.4106,1.20984 0.6094,1.81445 -0.1988,-0.60461 -0.4051,-1.20971 -0.6094,-1.81445zm2.0273,6.26562c0.1846,0.60177 0.3579,1.20308 0.5371,1.80469 -0.1792,-0.60139 -0.3525,-1.20313 -0.5371,-1.80469zm1.4688,5.00977c0.1799,0.63781 0.3593,1.27644 0.5332,1.91406 -0.174,-0.63786 -0.3532,-1.27602 -0.5332,-1.91406zM377.5,842.5c-4.42321,0 -9.31831,2.00257 -14.86719,9.24023C357.08394,858.97789 352.5,871.0223 352.5,885c0,13.9777 4.58394,26.0221 10.13281,33.25977 5.54888,7.23766 10.44398,9.24023 14.86719,9.24023 4.42321,0 9.31831,-2.00257 14.86719,-9.24023C397.91606,911.0221 402.5,898.9777 402.5,885c0,-13.9777 -4.58394,-26.02211 -10.13281,-33.25977C386.81831,844.50257 381.92321,842.5 377.5,842.5Zm-0.27344,4.79492c2.95574,0.0879 5.94922,5.08008 5.94922,10.70508 10.93128,-0.11104 14.67749,3.31056 5.67578,13 13.69744,3.7436 10.6454,8.69968 2.83789,14 7.80751,5.30032 10.85955,10.2564 -2.83789,14 9.00171,9.68944 5.2555,13.11104 -5.67578,13 0,10 -9.4596,18 -11.35156,0 -10.93128,0.11104 -14.67748,-3.31056 -5.67578,-13 -13.69744,-3.7436 -10.6454,-8.69968 -2.83789,-14 -7.80751,-5.30032 -10.85955,-10.2564 2.83789,-14 -9.0017,-9.68944 -5.2555,-13.11104 5.67578,-13 0.82773,-7.875 3.10344,-10.77344 5.40234,-10.70508zm352.35742,5.20508 -75.1914,86.93945 43.0039,-0.041L744.44531,885H840l-15,-32.5zm29.72266,65 -19.23047,22.23633L876.25,939.95508 860,917.5Zm-104.13476,52.41992 -315.75977,0.17969c2.43984,2.47881 4.98787,4.87423 7.56641,7.28906 15.37025,14.39437 29.32058,28.43253 41.91015,42.12693 1.06974,-4.4442 6.04965,-11.1309 16.11133,-19.5156 -30,-25 -15,-34.99999 15,-15 30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -11.06914,7.3794 -20.08451,10.6644 -25.5625,10.6289 1.31057,1.4627 2.62767,2.9262 3.90625,4.3809l256.41797,-0.1328zm-170.01172,4.44531C490.60938,974.21875 499.75,977.5 511,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477zm91,0C581.60938,974.21875 590.75,977.5 602,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477z"
        ></path>
      </symbol>
      <symbol id="SQ4" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="green"
          d="M499.67383,0C598.83088,212.42554 698.5156,423.78371 891.07812,444.24805L557.50781,0ZM299.89844,59.855469C265.54099,182.85387 187.08454,297.85994 240.09961,458.2793L349.875,372.94531C322.20549,333.64118 300,282.28964 300,255c0,-20 5.00324,-149.9992 5,-155 -10e-4,-2.004308 -2.41143,-19.27436 -5.10156,-40.144531zM899.91016,454.8418C746.55122,593.77022 578.78424,763.04072 429.50781,939.46875l40.84766,0.54297C595.55342,787.07576 764.14431,621.01748 918.95508,481.37891Zm65.79101,87.45703c-28.87179,19.18723 -64.12524,44.12835 -93.97851,75.52344l25.55078,20.04296c30.22964,-29.84438 65.96002,-54.59002 95.59961,-73.97851 -9.28135,-6.87909 -18.47109,-14.10656 -27.17188,-21.58789zM685,755 525.10156,939.88281 570,940 699.86133,787.5H806.65039L805,755Z"
        ></path>
      </symbol>
      <symbol id="SQ5" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="6"
          fill="none"
          d="M435,885A57.5,75.000002 0 0 1 377.5,960.00001 57.5,75.000002 0 0 1 320,885 57.5,75.000002 0 0 1 377.5,810 57.5,75.000002 0 0 1 435,885v0M417.07718,940H876.02627M308.27069,940h28.75722M339.49097,970H901.47783M131.84482,543.19629 351.03451,374.58883M6.9310566e-5,644.61533 44.832165,610.1291M1138.1663,665.18229C1077.9926,627.18313 1020.1253,586.55302 965.29601,542.45758M1208.5796,707.90733c-20.1878,-11.78458 -40.1599,-23.81534 -59.8906,-36.12132M557.51806,-3.5577172e-4 965.44559,542.57786M1299.7291,1059.765c-68.4773,39.2778 -116.7334,76.5733 -164.2838,131.8131 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51285,-102.35515 139.0695,-133.86354M499.68528,0.03748108C598.83742,212.45251 698.51437,423.77834 890.34164,443.851M364.36489,812.31243C320.07724,685.41364 328.50886,542.63024 321.33642,404.17725c76.71711,39.85219 163.35704,77.44074 457.8821,5.76082C644.587,533.12731 501.69292,642.05444 392.45651,811.84681M355.97656,456.125c29.62956,11.74764 64.92126,21.56216 110.04297,25.1543 51.30556,4.08443 115.56309,0.48617 200.57813,-14.40625 -98.57798,87.12824 -198.39177,177.48156 -282.2461,298.86133 -24.96545,-94.92731 -24.7974,-201.06283 -28.375,-309.60938v0M867.34252,440.4065C719.62961,574.07588 560.4386,730.57461 436.09373,879.43791M223.89186,472.86906c-0.82324,183.16931 37.98603,343.48203 98.11552,466.27071M191.49798,496.71315c2.08648,150.92196 30.40471,286.39171 75.55251,398.73891M429.507,939.46794C578.78343,763.03991 746.55158,593.76963 899.91052,454.84121M470.35494,940.01166C595.55289,787.0757 764.14488,621.01728 918.95565,481.37871M525,940 685,755h120.41872M567.92551,940.0502 699.86133,787.5h106.78892M611.46541,939.39021 714.72266,820h97.2642M654.39213,939.43943 729.58398,852.5h93.89714M697.39662,939.39902 744.44531,885h95.04566M740.07521,939.73575 759.30664,917.5H860M906.39152,629.42293 1063.7852,756.67736M871.92369,617.813 1043.2441,757.01082M459.61865,481.34795C414.86903,573.51288 406.45192,669.62669 385,765M303.65592,-0.00221915C259.09343,162.78907 138.61386,327.07777 209.42337,483.4732M240.09997,458.27954C187.0849,297.86018 265.54056,182.85405 300.09597,58.960082M805.81085,330.134c14.88787,-6.44544 30.42237,-12.16006 46.14865,-17.2138M0.09725143,902.73906C71.866196,860.06685 117.03718,820.61709 170,750c50,100 99.8567,155.1639 176.97865,227.3892 281.56105,263.6842 94.15072,409.6105 -13.08443,480.4695M377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5v0M1130,765c16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110 -32.9633,38.74398 -63.8666,77.97963 -125,110v0M1300,705.83334l-34.3239,2.86032M1299.9997,930.55544l-26.1711,-11.63161M1192.7269,836.42558c37.6985,20.41997 54.5672,59.51932 65.2796,89.01033M1182.9686,784.9233c26.555,-0.86899 48.4536,-6.17171 77.0314,15.0767 -14.6369,19.51581 -30.1358,29.72065 -67.2011,34.6433M1234.6287,679.15791c-1.9945,40.38926 -12.7829,83.27561 -52.2037,104.5774M1162.3431,745.42454c26.5383,39.87481 36.0743,80.87688 26.979,123.43436M1130,765c0,0 -82.1675,-15 -95,-5 -12.8325,10 -32.9691,31.30714 -40,40 -31.97044,39.52731 3.64509,49.72935 20,30M1050,800c-59.31161,25.45028 -64.22618,120.61499 20,25M1041.1933,853.52948c-14.9444,32.29436 0.7581,60.30105 58.5,-5.24847M1062.1853,882.59071C1040.9944,921.29246 1103.755,918.14402 1160,855M1063.2524,755.79961c33.572,-37.62441 66.2866,-76.82735 96.4461,-120.73492M1078.4582,757.6865c32.4929,-36.68328 64.0954,-75.00591 93.2554,-117.82589M1085,735c-4.9523,-58.0017 -25.4042,-90.06768 -80,-65 38.526,16.69119 38.6175,74.15849 80,65v0M1005,670c37.8073,-6.25375 56.1399,40.79694 80,65M1100,732.33169c35,-15 50.6726,-47.07119 67.2824,-5 -32.2824,-2.08351 -62.2824,45 -67.2824,5v0M1100.0662,732.84533c26.3257,8.26747 52.4616,-23.9051 67.2162,-5.51364M1155.0001,585.00001C1080.0001,630 1080,484.99999 1155,530c-45,-75 100,-75 55,0 75,-45 75,100 10e-5,55 45,75.00001 -100.0001,74.99999 -55,10e-6v0M1242.5,557.5c-60,0 -60,0 -60,-60 0,60 0,60 -60,60 60,0 60,0 60,60 0,-60 0,-60 60,-60v0M1122.9743,521.34338c-1.248,-10.59434 -3.0726,-20.43952 -5.4737,-28.84337 8.5766,2.45046 18.6544,4.30045 29.4977,5.54996M1146.7554,616.97813c-10.7509,1.24908 -20.7424,3.08971 -29.255,5.52188 2.4225,-8.47859 4.2581,-18.42426 5.5069,-29.12621M1241.9485,592.9857c1.2496,10.84959 3.1002,20.93331 5.5519,29.5143 -8.4143,-2.40409 -18.2735,-4.23021 -28.8829,-5.47837M1218.5761,497.98319c10.625,-1.24828 20.4988,-3.07601 28.9239,-5.48319 -2.4151,8.45286 -4.2469,18.3639 -5.4955,29.0288M357.95908,386.26136c-4.7848,-2.30618 -9.52375,-4.6875 -14.28345,-7.12611M748.06895,383.93902C622.45119,413.08814 538.88863,420.5377 479.79194,417.07826M355.99023,456.12891c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891v0M85,135c10.787262,31.12992 5,90 35,90 65,0 20,-95 -35,-145 -55.000004,50 -100.000004,145 -35,145 30,0 24.21273,-58.87008 35,-90v0M40,285c0,0 0,-10 10,-10 12.88094,0 15,45 -10,45 -34.999996,0 -29.999996,-70 5,-70 30,0 40,50 40,50 0,0 10,-50 40,-50 35,0 40,70 5,70 -25,0 -22.88094,-45 -10,-45 10,0 10,10 10,10M120,275c-55,2.66831 15,250 14.49097,296.289C134.16784,600.67311 125,630 85,630 45,630 35.832163,600.67311 35.509031,571.289 35,525 105,277.66831 50,275M70,264.98358V208.33333M100,265.18883V208.74384M103.20611,627.39263C121.81764,632.48836 135,645.16656 135,660c0,19.32997 -22.38576,35 -50,35 -27.614237,0 -50,-15.67003 -50,-35 0,-14.8303 13.176786,-27.50627 31.782083,-32.60414M65.931232,692.4756C41.674852,699.57662 35,720.74035 35,740c0,36.24391 13.136211,96.133 20.364326,126.34321M128.36935,800.67704C132.14739,778.91407 135,756.88968 135,740c0,-19.39937 -6.77205,-40.73054 -31.46191,-47.67672M256.89224,885h6.38602M1.1417102e-4,884.99999 28.737098,885M245.57157,870h11.90122M2.5229169e-5,870.00002 51.088175,870M233.67034,855h18.57752M4.1609595e-5,854.99999 52.539543,855M222.93022,840h24.09272M7.6084636e-5,840.00001 49.346532,840M212.77064,825h29.89819M4.2336546e-5,825.00002 46.443795,825M203.1916,810h34.54258M4.0905762e-6,810.00002 43.541058,810M194.48339,795h38.89668M129.46208,795h5.22493M-3.8457096e-5,795.00001 40.638321,795M186.06545,780h42.96051M131.78427,780h14.51368M-3.1733115e-5,780.00001 38.316131,780M178.22806,765h46.73407M133.81618,765h24.67327M10,765H36.284215M134.68701,750h86.50156M10,750H34.542573M134.97728,735h83.01828M15,735H35.12312M132.65509,720H205M15,720H37.844594M155,705h45M325,510c-11.82334,-17.57111 -24.45521,-31.94743 -45.42097,-47.16261 -21.67788,-15.73198 -32.01525,9.6364 -23.86278,22.70472M325,540c-13.68399,-15.7169 -40.72661,-39.31758 -62.25684,-51.80699 -20.39713,-11.83211 -26.52283,15.09906 -9.53546,27.99468M326.64903,572.53873c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -33.04187,-18.08643 -43.83934,14.15892 -2.74316,31.80699M329.68204,632.14459c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -30.81157,-16.86561 -37.65608,16.8659 -5.11631,35.80661M328.06764,597.68777c-13.86078,-13.59047 -33.31597,-27.70524 -50.77313,-39.51278 -22.07438,-14.9305 -34.10496,4.47364 -22.83565,17.22609M332.19576,659.38835c-13.77031,-13.23256 -32.62008,-26.88451 -49.58329,-38.35795 -24.04479,-16.26322 -36.17268,12.27173 -19.25152,25.31598M335.48063,686.60634C319.24375,673.64242 295.51352,659.7442 277.4252,650.3376c-31.2697,-16.26141 -36.88691,20.47944 -3.29829,37.12122M339.44241,709.94356C293.812,671.34406 241.20364,684.64228 285,715M345.57813,743.85785c-49.78299,-42.23381 -140.14002,-42.27022 -51.45386,5.50004M359.15379,797.42734C296.30783,757.35598 217.41506,767.9862 315.25691,808.08817M356.15219,815.71589c-43.41581,-18.1629 -92.79129,0.20988 -43.97099,13.65755M335.79649,833.55074c-36.46249,-11.38361 -55.92576,9.42664 -11.42381,20.21059M323.63736,467.38673c-7.1925,-7.58612 -15.51039,-14.89158 -25.85855,-22.4014 -17.52111,-12.71535 -26.71907,0.32727 -25.12324,12.4885M322.15877,428.22708c-1.31784,-1.00168 -2.67007,-2.00587 -4.05887,-3.01374 -19.41173,-14.0874 -28.60717,3.4419 -24.22651,16.36102M351.5017,769.34668c-41.8286,-32.62324 -87.13007,-22.98664 -57.82646,2.59886M396.50984,805.03398c97.55186,1.04019 65.93584,25.61549 21.19412,25.63392M410.20409,785.71584c31.87867,-11.92022 60.58013,-9.17207 74.95842,-1.62887 16.81695,8.82258 14.04006,24.2047 -26.16419,30.34906M430.54986,757.7319c58.57662,-11.0001 103.69453,13.94896 55.48459,26.1888M451.62343,729.60393c67.42086,-18.09697 125.45489,10.74224 49.42624,33.66324M469.15226,707.61747c69.25339,-23.47062 135.42699,4.47512 67.15155,28.14525M497.03474,675.73394c50.50234,-8.00778 88.6752,9.66559 55.551,28.0217M514.06286,656.56715c77.25396,-19.94453 157.95502,17.262 48.7626,27.75334M550.91529,618.31036c57.1762,-5.00205 100.00874,18.02731 40.2256,35.03407M568.89077,600.93936c75.24789,-19.79781 151.84194,14.60918 51.22446,34.33609M596.84001,574.15634c55.64482,-7.64299 102.46778,11.7471 64.24628,28.76475M620.73761,552.10789c71.56974,-16.51587 140.66537,14.62009 53.45997,34.06378M660.73433,515.56983c57.1151,-4.52529 99.00079,18.87447 36.45506,35.78648M684.38719,494.58861c73.88041,-16.89549 144.8643,16.89901 43.68109,36.08147M722.79564,460.82624c57.76542,-5.50387 101.75016,17.65976 42.02455,34.7974M748.43052,437.7647c68.01755,-11.92015 127.59071,17.4385 43.80212,36.02686M645.55164,273.86211C640.4516,285.47932 635.59316,297.26013 610,295c-14.37233,81.30224 -73.77303,98.38804 -130,120 0,0 -19.41945,15.64589 -29.41945,15.64589C435.58055,430.64589 425,425 420,425c-5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -30,-40 -55,-96.04455 -55,-125 0,-20 5.003,-149.9992 5,-155 -0.002,-3.089335 -5.72781,-42.445846 -10.1037,-72.07356M622.93321,240.32144C616.61632,250.552 609.19352,264.74236 615,265c2.73428,0.12132 6.96971,-10.37759 10.24354,-19.90618M904.16018,494.81448l50.56379,54.17549M889.99031,508.2039l48.73454,52.21558M875.34795,521.08709l48.01937,51.44933M861.63691,534.96812l46.15447,49.45122M847.01655,547.87487l45.96336,49.24646M832.83302,561.24966l35.28817,37.80876M818.66315,574.63908l24.02599,25.74214M803.86532,587.3557l17.84203,19.11646M790.06402,601.14003l8.92784,9.56554M482.75862,925h55.41872M495.89491,910h55.00821M508.21018,895h55.82923M521.34647,880h55.41872M534.48276,865h55.41872M552.95566,845H585M790,820v32.5M765,820v32.5M740,820v32.5M703.26765,833.26765l22.578,22.578M684.08867,854.08867l23.39901,23.39901M665.93596,875.93596l22.78325,22.78325M648.19376,898.19376l22.578,22.578M629.22003,919.22003l20.73071,20.73071M791.29599,310.75526c15.62961,-6.29692 31.83381,-11.83473 48.11454,-16.69002M776.15664,290.35133c15.84539,-6.35519 32.2728,-11.93292 48.76488,-16.81275M760.82223,270.4856c16.18061,-6.50419 32.97255,-12.19625 49.8241,-17.16102M746.54814,252.22866c16.42632,-6.7965 33.54246,-12.73644 50.75899,-17.91046M739.12096,229.17409c11.71799,-4.608 23.73402,-8.79725 35.84163,-12.5995M726.54679,208.22774c8.46394,-3.2756 17.07495,-6.33535 25.75602,-9.1911M711.68624,188.33917c5.39484,-2.00758 10.85695,-3.94932 16.37032,-5.82515M900.40882,94.431781C848.5463,114.25376 796.72828,69.769511 761.4322,93.621964 715,125.00001 755,185 789.33498,165.18883 821.13528,146.84017 790,105 775,115c-9.30261,6.20174 -14.88842,18.30946 -10,25 6.18042,8.45885 10.48873,9.62814 20,5M901.46652,97.13303C861.76115,135.4564 879.34663,201.01228 842.74068,222.52055 794.42332,250.91 757.5027,188.96753 790.17065,166.51363c30.25635,-20.79631 54.6061,25.32412 39.1205,34.55428 -9.60379,5.72429 -22.93675,5.55043 -26.86936,-1.74304 -4.972,-9.22111 -4.17161,-13.61293 4.10189,-20.20332M765,180l90,-60M845,160c-10,-10 -45.467,-11.35662 -55,5 22.00764,-11.03808 34.76336,-24.75676 25,-45M795,230c25,30 50,20 75,10 24.05541,32.7653 64.66095,38.66637 105,45M725,130C715,110 740,85 755,75 749.14905,51.948962 757.70702,26.00987 766.59362,0.00490542M700,90c10,-25 25,-25 25,-25 -8.48271,-38.172217 3.28893,-47.867055 8.18679,-64.93099617M427.96416,0.01822477C445.06535,51.748024 483.31343,78.400493 539.31946,83.994433M446.67053,0.04362022C462.63103,38.843647 492.03631,61.699978 533.14043,70.683071M461.24526,0.01603427C475.22521,27.447203 496.92922,45.718691 525.58366,55.74792M476.99588,0.10806452C487.38028,16.453559 500.99836,28.964352 517.63646,37.893813M371.26432,0.04443925C356.34418,40.196712 340.91798,80.075485 304.69652,100.28589M355.60874,0.04353776C343.34293,31.804187 329.13875,61.845937 302.67098,80.298673M339.57059,0.02060224C329.73362,23.196287 317.89132,44.53011 299.71459,59.883794M325.15652,0.08430598C317.46458,14.722402 308.27692,27.964826 296.26758,38.544057M305,120c41.1016,-25.066138 61.56092,-14.28714 80,0 20,55 -15,110 -14.41945,151.6763 0.21559,15.47674 11.72696,13.44856 19.41945,13.3237 4.99934,-0.0811 15,10 15,10M305,125c29.58587,-20.97635 55.47603,-17.50669 80,-5M430,245c20,0 20,30 5,30 -40,5 -40,-10 -5,0M365,315v10l5,-5 -5,-5v0M455,320l5,-5v10l-5,-5v0M370,320c0,0 5,5 10,5 5,0 5.24415,-4.00984 12.32219,-4.4848C400,320 400,325 405,325c5,0 15,-10 20,-10 5,0 15,5 20,5h10M390,340c3.06957,28.45212 45.6136,8.68856 45,5 -5,5 -44.77199,31.85105 -45,-5v0M430,135c51.53607,-36.718861 85.86501,-16.18211 120,5 -35.40475,-25.98218 -85,-45 -120,-5v0M540,160C525,160 503.52953,134.61544 483.61398,136.45137 453.79885,139.1999 445,175 430,180 447.93464,158.59181 463.7944,151.78059 478.07024,151.93493 507.27438,152.25068 515,185 550,175M430,180c15,-10 32.80939,10.04302 45.17423,9.94542C504.08195,189.71723 519.49385,175 530,175M380,175c-20,0 -30.87367,-19.1648 -47.03192,-20.29027 -12.3413,-0.85961 -29.19452,12.61246 -29.19452,17.61246 0,7.07107 11.23734,20.70784 22.74316,23.25836C342.90794,199.21402 362.81244,175.3491 380,175v0M305,165c22.64276,-42.75014 64.95345,-9.49214 65,-5M820,265c15,15 35,10 45,5 20.5191,14.6565 42.75671,20.72048 62.68286,23.22939M851.86653 312.33707C895.10619 299.11787 938.83136 290.34833 975 285C924.90149 188.22308 899.90057 94.152754 874.11725 -0.0019513659 M851.86653,312.33707C895.10619,299.11787 938.83136,290.34833 975,285 924.90149,188.22308 899.90057,94.152754 874.11725,-0.00195137M851.01315,311.99775 635.36748,-2.4089679e-4M927.65339,293.26472C907.75671,290.72048 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5"
        ></path>
      </symbol>
      <symbol id="SQ6" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="3"
          fill="none"
          d="M986.60333,811.20184l17.52527,26.83701m3.5763,5.47663 14.2883,21.88014M993.49031,800.86775c12.59499,20.81314 26.36539,39.79428 40.67199,57.93996m3.6811,4.63683c6.0574,7.57938 12.2001,15.02588 18.3803,22.41378m3.5795,4.26824c4.9357,5.87225 9.8895,11.71638 14.8372,17.56998M1002.2895,791.27746c25.6547,42.89167 56.3312,77.95704 86.5273,113.77117M1011.3206,782.24417c26.5981,44.89853 58.7236,81.18275 90.1523,118.55299M1018.2105,775.40469C1045.4382,820.51985 1078.1971,857.01507 1110,895M91.990234,409.08984c5.346491,34.39969 12.364566,69.89746 17.978516,99.54297 5.61395,29.64551 9.60751,54.84672 9.52344,62.49219 -0.14502,13.18721 -2.60383,25.09508 -7.35157,32.2207C107.39289,610.47133 101.33414,615 85,615 68.665861,615 62.607113,610.47133 57.859375,603.3457M95.230469,511.42383c2.783382,14.69817 5.162021,28.28252 6.812501,38.99023 1.65048,10.70771 2.46055,19.51658 2.44922,20.54688 -0.12561,11.42229 -3.03694,21.37127 -4.833987,24.06836 -1.554361,2.33286 -1.96098,2.67133 -3.316406,3.33203C94.986371,599.02203 91.780811,600 85,600M99.244141,641.85938C113.48363,645.75807 120,654.05348 120,660c0,3.87456 -2.13436,8.18273 -8.24609,12.46094C105.64218,676.73915 95.96981,680 85,680 74.030191,680 64.357824,676.73915 58.246094,672.46094M99.476562,706.76367c8.835718,2.48582 12.847888,6.43575 15.929688,11.99805C118.48805,724.32402 120,732.04575 120,740c0,15.20071 -2.70618,36.77501 -6.41016,58.11133M102.94922,660.2832C99.903483,662.33803 92.860098,665 85,665c-7.997241,0 -15.198086,-2.76015 -18.152344,-4.82812M102.28516,726.03125C103.52282,728.2651 105,733.94656 105,740c0,13.42041 -2.56634,34.6744 -6.189453,55.54492M726.75998,368.27894C639.85431,387.67178 574.6926,396.00751 524.83867,397.57475M715.61309,356.58894C649.94086,370.7787 597.12268,378.4618 554.16847,381.63062M703.03893,344.25945c-49.76763,10.38288 -91.8849,16.91189 -127.75629,20.52287M690.7875,331.76901c-38.30305,7.6982 -71.90839,13.04175 -101.50758,16.49148M680.13806,318.87243c-30.03631,5.82677 -57.08899,10.16495 -81.51547,13.25269M670.20516,305.76564c-23.347,4.36958 -44.8345,7.81564 -64.64196,10.45774M659.57286,292.71511c-18.04772,3.23925 -34.94556,5.91034 -50.78275,8.07274M390,380c11.94547,-13.95601 27.22073,-12.69836 45,0M440,195c10,15 30,15 45,15M310,205c50,25 60,-30 70,-30M350.01995,162.05531c1.14299,3.17833 1.7863,6.76631 1.7863,10.56373 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-5.79795 1.49965,-11.10766 3.98776,-15.21654M488.55832,153.60687c1.90775,3.81995 3.02626,8.46304 3.02626,13.4703 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-4.03258 0.72545,-7.82898 2.00436,-11.14943"
        ></path>
        <use xlink:href="#SSQ" height="90" transform="translate(1188,935)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1194,1043)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1096,1033)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1022,947)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(918,851)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(897,726)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
      </symbol>
      <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="green"></rect>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
      <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
      <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      <g transform="rotate(180)">
        <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
        <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
        <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      </g>
      <use xlink:href="#XSQ" stroke="#44F" fill="none"></use>
    </svg>
    `;
  let d1 = mDiv();
  d1.innerHTML = html;
  mAppend(dTable, d1);
}
function test10_update(canvas, item) {
  let [astep, a, bstep, b, func] = [item.astep, item.a, item.bstep, item.b, item.func];
  canvas.clear();
  [a, astep] = oscillate_between(a, 0, 5, astep);
  [b, bstep] = oscillate_between(b, 0, 5, bstep);
  [item.astep, item.a, item.bstep, item.b] = [astep, a, bstep, b];
  canvas.plot(x => b * func(a * x), "rgb(11,153,11)", 1);
  return false;
}
function test10_verrueckt() {
  let styles = { bg: 'yellow', fg: 'red', border: 'random', thickness: 20, shadow: 'green', rotate: 45, scale: 2 };
  let html = `
      <svg
      xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      class="card"
      face="QS"
      height="100%"
      preserveAspectRatio="none"
      viewBox="-120 -168 240 336"
      width="100%"
      fill="#ffff00"
      stroke="#ff0000"
      >
      <defs><rect id="XSQ" width="164.8" height="260.8" x="-82.4" y="-130.4"></rect></defs>
      <symbol id="VSQ" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
        <path
          d="M-260 100C40 100 -40 460 260 460M-175 0L-175 -285A175 175 0 0 1 175 -285L175 285A175 175 0 0 1 -175 285Z"
          stroke="black"
          stroke-width="80"
          stroke-linecap="square"
          stroke-miterlimit="1.5"
          fill="none"
        ></path>
      </symbol>
      <symbol id="SSQ" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
        <path
          d="M0 -500C100 -250 355 -100 355 185A150 150 0 0 1 55 185A10 10 0 0 0 35 185C35 385 85 400 130 500L-130 500C-85 400 -35 385 -35 185A10 10 0 0 0 -55 185A150 150 0 0 1 -355 185C-355 -100 -100 -250 0 -500Z"
          fill="black"
        ></path>
      </symbol>
      <symbol id="SQ1" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#FC4"
          d="M635.39648,0 851.86719,312.33789C895.10685,299.11869 938.83136,290.34833 975,285 924.90197,188.22401 899.89439,94.153799 874.11133,0ZM295.52539,27.285156C246.27551,180.9799 142.75435,335.54042 209.25195,483.08398l-17.43359,13.44922c1.76531,151.10099 30.08527,286.57163 74.54102,398.60938 18.12594,21.287 38.56227,42.11564 61.47851,64.11523 3.61128,3.46683 7.28461,6.96262 11.33789,10.61914L901.47852,970l-0.41407,-0.51953c-0.12219,-0.138 -0.23745,-0.27418 -0.35937,-0.41211 15.27725,17.28278 32.6506,35.12574 52.3164,53.54294C1030.1434,1094.8366 1080,1150 1130,1250c52.9819,-70.6425 98.186,-110.0972 170,-152.7871v-37.6016c-68.6196,39.3343 -116.9422,76.6549 -164.5547,131.9668 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51367,-102.35489 139.07032,-133.86328l-26.7793,-21.49024C896.53697,588.11019 793.22595,665.67487 806.10938,786.48828L699.86133,787.5 568.0625,939.89258 429.48438,939.86328C578.06034,763.29892 745.82856,594.02803 899.1875,455.09961l-9.56836,-10.99023c-28.86687,-3.02061 -55.64392,-10.37642 -80.51758,-21.42774 -1.77605,4.17261 -4.43372,8.02096 -7.94336,11.23438C665.11643,558.39566 525.46983,665.166 419.78906,829.43164L392.45703,811.84766C501.69344,642.05529 644.58723,533.12674 779.21875,409.9375l17.51367,6.86328c-17.74437,-8.98707 -34.48695,-19.8921 -50.29101,-32.48437 -124.71285,29.03155 -208.27492,36.48099 -267.26758,31.98242 0,0 -19.31641,14.60547 -29.31641,14.60547 -15,0 -25.58008,-5.64453 -30.58008,-5.64453 -5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -1.51422,-2.01895 -3.01443,-4.07919 -4.23242,-5.79297l-39.21875,30.25586 10.50977,-0.54493c7.17244,138.45299 -1.25836,281.23598 43.02929,408.13477l-27.41796,17.66602c-1.32891,-2.13106 -2.43311,-4.45616 -3.26758,-6.95704C288.22851,692.7888 295.29422,552.70428 289.59766,421.09961l-69.70313,53.77344 20.20508,-16.59375C187.08454,297.85994 265.54029,182.85491 300.0957,58.960938ZM85,80c-55.000004,50 -100.000004,145 -35,145 9.343263,0 15.215964,-5.70961 19.599609,-15.58984l-0.05469,54.80664C63.116922,255.80043 55.218717,250 45,250c-34.999996,0 -39.999996,70 -5,70 24.46345,0 22.957588,-43.08208 10.8125,-44.93164 53.48157,5.0855 -15.809214,250.16385 -15.302734,296.2207 0.268193,24.38822 6.628431,48.73678 31.46289,56.20899C48.176742,632.49354 35,645.1697 35,660 35,674.30844 47.265656,686.61054 65.384766,692.25586 41.674751,699.57565 35,720.74035 35,740 35,776.24391 48.1356,836.13212 55.517578,866.33008 82.604368,846.54619 106.08392,825.42866 128.83984,800.21875 132.14826,778.91478 135,756.88968 135,740 135,720.60063 128.2285,699.26867 104.15234,691.95898 118.02756,686.75065 129.28173,676.58841 135,660c0,-14.83344 -13.18185,-27.51102 -30.78711,-32.89844 24.05654,-8.65812 30.01787,-32.21714 30.27734,-55.8125C134.99671,525.23221 65.705931,280.15386 119.1875,275.06836 107.04241,276.91792 105.53655,320 130,320c35,0 30,-70 -5,-70 -10.83425,0 -19.06007,6.52154 -25.074219,15.02148L100.25195,209.2793C104.49041,218.99863 110.42097,225 120,225 185,225 140,130 85,80Zm641.48047,287.83789c-86.62544,19.83455 -151.78802,28.17022 -200.80469,29.24219 -14.2248,6.27415 -30.07191,11.92239 -45.7793,18.95898 58.99266,4.49857 142.55438,-2.95118 267.19727,-32.03711 -7.7527,-5.20716 -14.38853,-10.76914 -20.61328,-16.16406zm-370.49024,88.29102c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891ZM1182.5,473.75c-24.0403,0 -48.0562,17.34722 -29.8594,52.02344A45,42.5 0 0 1 1182.5,515a45,42.5 0 0 1 29.8652,10.76367C1230.552,491.09427 1206.538,473.75 1182.5,473.75Zm-54.6914,47.48047c-45.2477,0.77462 -37.6424,97.7377 22.793,66.2168A45,42.5 0 0 1 1137.5,557.5a45,42.5 0 0 1 13.1113,-29.94336c-8.6891,-4.53343 -16.2978,-6.43753 -22.8027,-6.32617zm109.3828,0c-6.5027,-0.11132 -14.1076,1.79222 -22.793,6.32226A45,42.5 0 0 1 1227.5,557.5a45,42.5 0 0 1 -13.1094,29.94336c60.4429,31.53409 68.0505,-65.43824 22.8008,-66.21289zm-24.8301,67.99414A45,42.5 0 0 1 1182.5,600 45,42.5 0 0 1 1152.6348,589.23633c-11.9875,22.85174 -5.6311,38.16959 6.9726,45.95898 -23.6821,34.46419 -48.941,66.02584 -74.9492,96.20703C1079.1653,675.69528 1058.4509,645.45798 1005,670c37.225,16.12754 38.5709,70.31699 75.9492,65.69727 -5.8664,6.76063 -11.768,13.45662 -17.6972,20.10156l15.207,1.88672c7.2551,-8.19076 14.4623,-16.46748 21.6113,-24.85352 5.1929,39.08146 35.0698,-7.57452 67.2129,-5.5 -16.4802,-41.743 -32.0495,-10.50502 -66.4785,4.63672 24.5708,-28.86629 48.4073,-59.08334 70.8027,-91.95508 26.5679,6.12811 61.7407,-10.79807 40.7539,-50.78906zM1255,655c-32.9633,38.74398 -63.8666,77.97963 -125,110 16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110zM811.88477,817.78516c10.86486,41.66548 35.34229,88.00659 78.58593,139.42382 -4.92291,-5.82285 -9.66276,-11.58316 -14.2207,-17.2539l-286.46289,-0.0586 64.60547,-0.45703 75.1914,-86.93945 93.88282,-0.33984c-4.9028,-11.9067 -8.74345,-23.39087 -11.58203,-34.375zM377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5Z"
        ></path>
      </symbol>
      <symbol id="SQ2" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="red"
          d="M557.51758,0 805.9668,330.45703 851.01367,311.99805 635.36719,0Zm78.02148,0 63.76563,90.75C709.99966,65.000167 725,65 725,65 716.50651,26.779299 728.31462,17.104416 733.20117,0ZM820,265 851.86719,312.33789C877.5079,304.49903 903.31958,298.22492 927.6543,293.26562 907.75762,290.72138 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5zm99.12695,216.28711C764.14521,621.01648 595.55342,787.07572 470.35547,940.01172L525,940 685,755h120.41797l-0.0547,-0.41211c6.37431,-102.76161 97.50088,-170.65811 160.41211,-212.22851zm-727.41992,15.5625 -59.86133,46.34766 -0.39648,0.30468c1.93099,12.0459 3.10803,21.69313 3.04101,27.78711 -0.25947,23.59536 -6.2208,47.15438 -30.27734,55.8125C121.81815,632.48898 135,645.16656 135,660 129.28173,676.58841 118.02756,686.75065 104.15234,691.95898 128.2285,699.26867 135,720.60063 135,740c0,16.88968 -2.85174,38.91478 -6.16016,60.21875 -1.95154,2.162 -3.90854,4.29257 -5.87304,6.39453C138.56664,789.96704 153.92711,771.43051 170,750 200.25102,810.50205 230.44886,854.59181 266.85742,895.71484 221.90196,783.10482 193.58426,647.63449 191.70703,496.84961ZM44.53125,610.36133 0,644.61523V902.7832C30.797744,884.46615 56.707359,866.73637 80.427734,846.89844 72.427991,853.57027 64.158102,860.01913 55.517578,866.33008 48.1356,836.13212 35,776.24391 35,740 35,720.74035 41.674751,699.57565 65.384766,692.25586 47.265656,686.61054 35,674.30844 35,660 35,645.1697 48.176742,632.49354 66.972656,627.49805 56.528563,624.35562 49.361734,618.22105 44.53125,610.36133Zm1190.09765,68.79687 -1.1211,1.04688c-20.0542,23.0427 -41.8711,45.665 -71.7441,65.72265 27.117,39.37142 36.6532,80.37363 27.7441,123.12891 25.4392,14.76465 47.2329,33.87001 67.875,55.8418 -10.0896,-28.95393 -26.9566,-68.05217 -64.6191,-89.36328C1229.865,829.72137 1245.3631,819.51581 1260,800c-28.5778,-21.24841 -50.4759,-15.94491 -77.3027,-15.66992 39.149,-21.89578 49.9371,-64.78262 51.9316,-105.17188zM110.74609,819.23828c-0.7889,0.78628 -1.58065,1.56702 -2.37304,2.3457 0.792,-0.77791 1.58362,-1.55961 2.37304,-2.3457zm-5.15234,5.05078c-0.76819,0.74251 -1.53476,1.48679 -2.30664,2.22266 0.77112,-0.73534 1.53841,-1.48017 2.30664,-2.22266zm-5.26172,5.00586c-2.077449,1.94603 -4.165139,3.87648 -6.273436,5.7793 2.104356,-1.90192 4.194747,-3.83083 6.273436,-5.7793zm-6.539061,6.02149c-1.467973,1.32281 -2.945132,2.63598 -4.429688,3.93945 1.482456,-1.30407 2.961518,-2.61456 4.429688,-3.93945zM377.5,862.5a11,22.5 0 0 0 -11,22.5 11,22.5 0 0 0 11,22.5 11,22.5 0 0 0 11,-22.5 11,22.5 0 0 0 -11,-22.5zm225.17578,127.46484a10,10 0 0 0 -10,10 10,10 0 0 0 10,9.99996 10,10 0 0 0 10,-9.99996 10,10 0 0 0 -10,-10zM420,990a10,10 0 0 0 -10,10 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10zm91.13281,0.41016a10,10 0 0 0 -10,10.00004 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10.00004z"
        ></path>
      </symbol>
      <symbol id="SQ3" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#44F"
          d="M472.5,150a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm-140,5a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm23.49023,301.12891c3.54904,108.54757 3.24814,214.77856 28.25977,309.58398 83.90967,-121.45694 183.76187,-211.71291 282.33398,-298.83789 -85.00816,14.89038 -149.26165,18.48851 -200.56445,14.4043 -45.1152,-3.59162 -80.40237,-13.40501 -110.0293,-25.15039zm42.92579,22.92187c22.57573,0.10326 52.52779,2.34383 83.49804,6.2461 65.74558,8.28415 118.15335,21.65893 117.05469,29.87304 -1.09829,8.2139 -56.30922,5.07893 -122.05273,-3.20508 -65.73948,-8.28354 -117.1185,-18.57868 -116.02735,-26.79296 0.53448,-4.02047 14.07178,-6.22853 37.52735,-6.1211zM1117.5,492.5c2.4011,8.40385 4.2266,18.24941 5.4746,28.84375v0.36133c7.3876,-1.36391 16.4655,0.0837 27.2324,5.62304l-21.2675,-21.26757a1.50015,1.50015 0 0 1 1.0449,-2.57617 1.50015,1.50015 0 0 1 1.0761,0.45507l21.2676,21.26758c-5.5291,-10.74776 -6.9807,-19.81297 -5.6289,-27.19336 -10.7286,-1.24895 -20.7021,-3.08593 -29.1992,-5.51367zm130,0c-8.4251,2.40718 -18.2988,4.23414 -28.9238,5.48242h-0.2793c1.3613,7.38557 -0.087,16.46062 -5.6231,27.22266l21.2657,-21.26563a1.50015,1.50015 0 0 1 1.0312,-0.45312 1.50015,1.50015 0 0 1 1.0898,2.57422l-21.2675,21.26757c10.7565,-5.53399 19.8272,-6.98416 27.2109,-5.62695v-0.17187c1.2486,-10.6649 3.081,-20.57644 5.4961,-29.0293zm-853.59961,15.25781c20.38428,0.10329 47.42876,2.34386 75.39258,6.2461 59.36368,8.28422 106.68388,21.65899 105.69141,29.87304 -0.99271,8.21355 -49.91699,8.15671 -109.27735,-0.12695 -59.36371,-8.28422 -106.68391,-21.659 -105.69141,-29.87305 0.48636,-4.01928 12.70935,-6.22659 33.88477,-6.11914zm7.69531,34.67969c15.09367,-0.0753 32.61454,0.81411 50.47852,2.5625 51.50146,5.04084 94.00823,14.75226 93.67578,23.00391 -0.32891,8.2521 -42.34749,10.85536 -93.84961,5.81445C400.39893,568.77752 358.91755,558.00165 359.25,549.75c0.20345,-5.08688 15.52034,-7.17888 42.3457,-7.3125zm590.81446,21.09375c-26.28817,17.83124 -58.00395,39.71623 -85.84375,65.82227L1063.252,755.79883c5.9292,-6.64494 11.8308,-13.34093 17.6972,-20.10156C1043.5709,740.31699 1042.225,686.12754 1005,670c53.4509,-24.54202 74.1653,5.69528 79.6582,61.40234 18.288,-21.22222 36.2025,-43.13214 53.4609,-66.25 -50.4965,-31.89003 -99.3677,-65.63189 -145.70894,-101.62109zm92.24804,167.87109c-1.2353,1.43353 -2.4703,2.86748 -3.709,4.29493 1.3064,-0.16146 2.6533,-0.388 4.0508,-0.69727 -0.1038,-1.21628 -0.2241,-2.40447 -0.3418,-3.59766zm-21.4062,24.39649 1.3242,1.02344C1092.8236,758.22045 1130,765 1130,765c33.2353,-17.40792 57.5278,-36.95014 78.082,-57.38477 -19.9562,-11.65548 -39.7017,-23.55345 -59.2109,-35.71875 -15.5528,20.88792 -31.6462,40.7815 -48.0664,60.07227 34.429,-15.14174 49.9983,-46.37972 66.4785,-4.63672 -32.1431,-2.07452 -62.02,44.58146 -67.2129,5.5 -7.149,8.38604 -14.3562,16.66276 -21.6113,24.85352zM399.88477,574.98828c12.13924,-0.0753 26.23048,0.81416 40.59765,2.5625 41.42116,5.04089 74.78321,15.81675 74.51563,24.06836 -0.26463,8.25206 -34.05885,10.85531 -75.48047,5.81445 -41.42116,-5.04089 -74.78321,-15.81675 -74.51563,-24.06836 0.16364,-5.08693 13.30756,-8.24338 34.88282,-8.37695zm814.90823,12.6836 21.2675,21.26757a1.50015,1.50015 0 1 1 -2.121,2.1211l-21.2657,-21.26563c5.5369,10.76367 6.9837,19.84044 5.6211,27.22656h0.3223c10.6094,1.24816 20.4685,3.07443 28.8828,5.47852 -2.4278,-8.49731 -4.2627,-18.47029 -5.5117,-29.19922 -7.3807,1.35234 -16.4468,-0.0994 -27.1953,-5.6289zm-64.5879,0.002c-10.7501,5.53028 -19.8161,6.98044 -27.1973,5.62695v0.0723c-1.2488,10.70195 -3.0853,20.64836 -5.5078,29.12695 8.4975,-2.42785 18.4701,-4.26471 29.1992,-5.51367 -1.3518,-7.38039 0.1,-16.44561 5.6289,-27.19336l-21.2676,21.26758a1.50015,1.50015 0 1 1 -2.121,-2.1211zM399.95117,608.2207c7.75591,-0.014 16.33902,0.59569 25.04883,1.7793 30.51033,4.14665 55.19775,16.74619 55.24414,25 0.0491,8.25469 -24.64792,11.5847 -55.16016,7.4375 -30.51033,-4.14665 -55.28173,-14.19933 -55.32812,-22.45312 -0.0324,-5.62262 11.68692,-11.73096 30.19531,-11.76368zm2.94141,36.28321c3.92832,-0.0157 8.00124,0.15115 12.10742,0.49609 25.08573,2.10744 44.77796,7.02839 45.42188,14.97852 0.64298,7.94981 -19.17087,12.68576 -44.25586,10.57812 -25.08573,-2.10744 -45.94398,-10.26081 -46.5879,-18.21094 -0.52278,-6.4668 13.79255,-7.76393 33.31446,-7.84179zm-6.3711,30.78125c1.53788,10e-4 3.10151,0.0612 4.67383,0.17968 15.24356,1.1523 28.12847,7.43255 28.7793,14.02735 0.6519,6.59512 -11.17778,11.00764 -26.42188,9.85547 -15.24356,-1.1523 -28.12847,-7.43255 -28.77929,-14.02735 -0.57317,-5.81151 8.60794,-10.04793 21.74804,-10.03515zm-2.7207,30.4707c0.97501,0.002 1.96625,0.0499 2.96289,0.14453 9.66123,0.91446 17.82809,5.89851 18.24219,11.13281 0.4126,5.23472 -7.08576,8.73687 -16.74805,7.82227 -9.66123,-0.91446 -17.82809,-5.89851 -18.24219,-11.13281 -0.3645,-4.61356 5.45528,-7.97697 13.78516,-7.9668zm906.19922,0.0781 -34.2773,2.85547c0.2249,20.00253 -6.7832,39.15319 -30.7188,56.31055 24.0241,2.30082 45.4719,10.59792 60,35 -9.9971,24.98116 -26.6502,40.00143 -50,45 19.6816,21.91005 28.1768,47.18324 30.0293,74.45312l0.01,0.008 24.957,11.09375zm-167.2656,64.20508c0.2372,0.44647 0.4708,0.89347 0.7051,1.33985 -0.2343,-0.44637 -0.4679,-0.89339 -0.7051,-1.33985zm3.041,5.88282c0.083,0.16606 0.171,0.33199 0.2539,0.49804 -0.083,-0.16604 -0.1705,-0.33202 -0.2539,-0.49804zm2.6758,5.48437c0.2147,0.45253 0.425,0.90499 0.6367,1.35742 -0.2117,-0.45239 -0.4219,-0.90493 -0.6367,-1.35742zm2.455,5.32422c0.1795,0.40036 0.3641,0.80089 0.5411,1.20117 -0.177,-0.40029 -0.3615,-0.80081 -0.5411,-1.20117zm2.5958,5.98437c0.2099,0.50184 0.413,1.00415 0.6191,1.50586 -0.2062,-0.5018 -0.4092,-1.00393 -0.6191,-1.50586zm2.0703,5.11719c0.1975,0.50277 0.4,1.00516 0.5937,1.50781 -0.1937,-0.50252 -0.3962,-1.00516 -0.5937,-1.50781zm2.3418,6.1875c0.1922,0.53072 0.3764,1.06121 0.5644,1.5918 -0.188,-0.53055 -0.3722,-1.06112 -0.5644,-1.5918zm1.7324,4.96485c0.2042,0.60477 0.4106,1.20984 0.6094,1.81445 -0.1988,-0.60461 -0.4051,-1.20971 -0.6094,-1.81445zm2.0273,6.26562c0.1846,0.60177 0.3579,1.20308 0.5371,1.80469 -0.1792,-0.60139 -0.3525,-1.20313 -0.5371,-1.80469zm1.4688,5.00977c0.1799,0.63781 0.3593,1.27644 0.5332,1.91406 -0.174,-0.63786 -0.3532,-1.27602 -0.5332,-1.91406zM377.5,842.5c-4.42321,0 -9.31831,2.00257 -14.86719,9.24023C357.08394,858.97789 352.5,871.0223 352.5,885c0,13.9777 4.58394,26.0221 10.13281,33.25977 5.54888,7.23766 10.44398,9.24023 14.86719,9.24023 4.42321,0 9.31831,-2.00257 14.86719,-9.24023C397.91606,911.0221 402.5,898.9777 402.5,885c0,-13.9777 -4.58394,-26.02211 -10.13281,-33.25977C386.81831,844.50257 381.92321,842.5 377.5,842.5Zm-0.27344,4.79492c2.95574,0.0879 5.94922,5.08008 5.94922,10.70508 10.93128,-0.11104 14.67749,3.31056 5.67578,13 13.69744,3.7436 10.6454,8.69968 2.83789,14 7.80751,5.30032 10.85955,10.2564 -2.83789,14 9.00171,9.68944 5.2555,13.11104 -5.67578,13 0,10 -9.4596,18 -11.35156,0 -10.93128,0.11104 -14.67748,-3.31056 -5.67578,-13 -13.69744,-3.7436 -10.6454,-8.69968 -2.83789,-14 -7.80751,-5.30032 -10.85955,-10.2564 2.83789,-14 -9.0017,-9.68944 -5.2555,-13.11104 5.67578,-13 0.82773,-7.875 3.10344,-10.77344 5.40234,-10.70508zm352.35742,5.20508 -75.1914,86.93945 43.0039,-0.041L744.44531,885H840l-15,-32.5zm29.72266,65 -19.23047,22.23633L876.25,939.95508 860,917.5Zm-104.13476,52.41992 -315.75977,0.17969c2.43984,2.47881 4.98787,4.87423 7.56641,7.28906 15.37025,14.39437 29.32058,28.43253 41.91015,42.12693 1.06974,-4.4442 6.04965,-11.1309 16.11133,-19.5156 -30,-25 -15,-34.99999 15,-15 30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -11.06914,7.3794 -20.08451,10.6644 -25.5625,10.6289 1.31057,1.4627 2.62767,2.9262 3.90625,4.3809l256.41797,-0.1328zm-170.01172,4.44531C490.60938,974.21875 499.75,977.5 511,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477zm91,0C581.60938,974.21875 590.75,977.5 602,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477z"
        ></path>
      </symbol>
      <symbol id="SQ4" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="black"
          d="M499.67383,0C598.83088,212.42554 698.5156,423.78371 891.07812,444.24805L557.50781,0ZM299.89844,59.855469C265.54099,182.85387 187.08454,297.85994 240.09961,458.2793L349.875,372.94531C322.20549,333.64118 300,282.28964 300,255c0,-20 5.00324,-149.9992 5,-155 -10e-4,-2.004308 -2.41143,-19.27436 -5.10156,-40.144531zM899.91016,454.8418C746.55122,593.77022 578.78424,763.04072 429.50781,939.46875l40.84766,0.54297C595.55342,787.07576 764.14431,621.01748 918.95508,481.37891Zm65.79101,87.45703c-28.87179,19.18723 -64.12524,44.12835 -93.97851,75.52344l25.55078,20.04296c30.22964,-29.84438 65.96002,-54.59002 95.59961,-73.97851 -9.28135,-6.87909 -18.47109,-14.10656 -27.17188,-21.58789zM685,755 525.10156,939.88281 570,940 699.86133,787.5H806.65039L805,755Z"
        ></path>
      </symbol>
      <symbol id="SQ5" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="6"
          fill="none"
          d="M435,885A57.5,75.000002 0 0 1 377.5,960.00001 57.5,75.000002 0 0 1 320,885 57.5,75.000002 0 0 1 377.5,810 57.5,75.000002 0 0 1 435,885v0M417.07718,940H876.02627M308.27069,940h28.75722M339.49097,970H901.47783M131.84482,543.19629 351.03451,374.58883M6.9310566e-5,644.61533 44.832165,610.1291M1138.1663,665.18229C1077.9926,627.18313 1020.1253,586.55302 965.29601,542.45758M1208.5796,707.90733c-20.1878,-11.78458 -40.1599,-23.81534 -59.8906,-36.12132M557.51806,-3.5577172e-4 965.44559,542.57786M1299.7291,1059.765c-68.4773,39.2778 -116.7334,76.5733 -164.2838,131.8131 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51285,-102.35515 139.0695,-133.86354M499.68528,0.03748108C598.83742,212.45251 698.51437,423.77834 890.34164,443.851M364.36489,812.31243C320.07724,685.41364 328.50886,542.63024 321.33642,404.17725c76.71711,39.85219 163.35704,77.44074 457.8821,5.76082C644.587,533.12731 501.69292,642.05444 392.45651,811.84681M355.97656,456.125c29.62956,11.74764 64.92126,21.56216 110.04297,25.1543 51.30556,4.08443 115.56309,0.48617 200.57813,-14.40625 -98.57798,87.12824 -198.39177,177.48156 -282.2461,298.86133 -24.96545,-94.92731 -24.7974,-201.06283 -28.375,-309.60938v0M867.34252,440.4065C719.62961,574.07588 560.4386,730.57461 436.09373,879.43791M223.89186,472.86906c-0.82324,183.16931 37.98603,343.48203 98.11552,466.27071M191.49798,496.71315c2.08648,150.92196 30.40471,286.39171 75.55251,398.73891M429.507,939.46794C578.78343,763.03991 746.55158,593.76963 899.91052,454.84121M470.35494,940.01166C595.55289,787.0757 764.14488,621.01728 918.95565,481.37871M525,940 685,755h120.41872M567.92551,940.0502 699.86133,787.5h106.78892M611.46541,939.39021 714.72266,820h97.2642M654.39213,939.43943 729.58398,852.5h93.89714M697.39662,939.39902 744.44531,885h95.04566M740.07521,939.73575 759.30664,917.5H860M906.39152,629.42293 1063.7852,756.67736M871.92369,617.813 1043.2441,757.01082M459.61865,481.34795C414.86903,573.51288 406.45192,669.62669 385,765M303.65592,-0.00221915C259.09343,162.78907 138.61386,327.07777 209.42337,483.4732M240.09997,458.27954C187.0849,297.86018 265.54056,182.85405 300.09597,58.960082M805.81085,330.134c14.88787,-6.44544 30.42237,-12.16006 46.14865,-17.2138M0.09725143,902.73906C71.866196,860.06685 117.03718,820.61709 170,750c50,100 99.8567,155.1639 176.97865,227.3892 281.56105,263.6842 94.15072,409.6105 -13.08443,480.4695M377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5v0M1130,765c16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110 -32.9633,38.74398 -63.8666,77.97963 -125,110v0M1300,705.83334l-34.3239,2.86032M1299.9997,930.55544l-26.1711,-11.63161M1192.7269,836.42558c37.6985,20.41997 54.5672,59.51932 65.2796,89.01033M1182.9686,784.9233c26.555,-0.86899 48.4536,-6.17171 77.0314,15.0767 -14.6369,19.51581 -30.1358,29.72065 -67.2011,34.6433M1234.6287,679.15791c-1.9945,40.38926 -12.7829,83.27561 -52.2037,104.5774M1162.3431,745.42454c26.5383,39.87481 36.0743,80.87688 26.979,123.43436M1130,765c0,0 -82.1675,-15 -95,-5 -12.8325,10 -32.9691,31.30714 -40,40 -31.97044,39.52731 3.64509,49.72935 20,30M1050,800c-59.31161,25.45028 -64.22618,120.61499 20,25M1041.1933,853.52948c-14.9444,32.29436 0.7581,60.30105 58.5,-5.24847M1062.1853,882.59071C1040.9944,921.29246 1103.755,918.14402 1160,855M1063.2524,755.79961c33.572,-37.62441 66.2866,-76.82735 96.4461,-120.73492M1078.4582,757.6865c32.4929,-36.68328 64.0954,-75.00591 93.2554,-117.82589M1085,735c-4.9523,-58.0017 -25.4042,-90.06768 -80,-65 38.526,16.69119 38.6175,74.15849 80,65v0M1005,670c37.8073,-6.25375 56.1399,40.79694 80,65M1100,732.33169c35,-15 50.6726,-47.07119 67.2824,-5 -32.2824,-2.08351 -62.2824,45 -67.2824,5v0M1100.0662,732.84533c26.3257,8.26747 52.4616,-23.9051 67.2162,-5.51364M1155.0001,585.00001C1080.0001,630 1080,484.99999 1155,530c-45,-75 100,-75 55,0 75,-45 75,100 10e-5,55 45,75.00001 -100.0001,74.99999 -55,10e-6v0M1242.5,557.5c-60,0 -60,0 -60,-60 0,60 0,60 -60,60 60,0 60,0 60,60 0,-60 0,-60 60,-60v0M1122.9743,521.34338c-1.248,-10.59434 -3.0726,-20.43952 -5.4737,-28.84337 8.5766,2.45046 18.6544,4.30045 29.4977,5.54996M1146.7554,616.97813c-10.7509,1.24908 -20.7424,3.08971 -29.255,5.52188 2.4225,-8.47859 4.2581,-18.42426 5.5069,-29.12621M1241.9485,592.9857c1.2496,10.84959 3.1002,20.93331 5.5519,29.5143 -8.4143,-2.40409 -18.2735,-4.23021 -28.8829,-5.47837M1218.5761,497.98319c10.625,-1.24828 20.4988,-3.07601 28.9239,-5.48319 -2.4151,8.45286 -4.2469,18.3639 -5.4955,29.0288M357.95908,386.26136c-4.7848,-2.30618 -9.52375,-4.6875 -14.28345,-7.12611M748.06895,383.93902C622.45119,413.08814 538.88863,420.5377 479.79194,417.07826M355.99023,456.12891c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891v0M85,135c10.787262,31.12992 5,90 35,90 65,0 20,-95 -35,-145 -55.000004,50 -100.000004,145 -35,145 30,0 24.21273,-58.87008 35,-90v0M40,285c0,0 0,-10 10,-10 12.88094,0 15,45 -10,45 -34.999996,0 -29.999996,-70 5,-70 30,0 40,50 40,50 0,0 10,-50 40,-50 35,0 40,70 5,70 -25,0 -22.88094,-45 -10,-45 10,0 10,10 10,10M120,275c-55,2.66831 15,250 14.49097,296.289C134.16784,600.67311 125,630 85,630 45,630 35.832163,600.67311 35.509031,571.289 35,525 105,277.66831 50,275M70,264.98358V208.33333M100,265.18883V208.74384M103.20611,627.39263C121.81764,632.48836 135,645.16656 135,660c0,19.32997 -22.38576,35 -50,35 -27.614237,0 -50,-15.67003 -50,-35 0,-14.8303 13.176786,-27.50627 31.782083,-32.60414M65.931232,692.4756C41.674852,699.57662 35,720.74035 35,740c0,36.24391 13.136211,96.133 20.364326,126.34321M128.36935,800.67704C132.14739,778.91407 135,756.88968 135,740c0,-19.39937 -6.77205,-40.73054 -31.46191,-47.67672M256.89224,885h6.38602M1.1417102e-4,884.99999 28.737098,885M245.57157,870h11.90122M2.5229169e-5,870.00002 51.088175,870M233.67034,855h18.57752M4.1609595e-5,854.99999 52.539543,855M222.93022,840h24.09272M7.6084636e-5,840.00001 49.346532,840M212.77064,825h29.89819M4.2336546e-5,825.00002 46.443795,825M203.1916,810h34.54258M4.0905762e-6,810.00002 43.541058,810M194.48339,795h38.89668M129.46208,795h5.22493M-3.8457096e-5,795.00001 40.638321,795M186.06545,780h42.96051M131.78427,780h14.51368M-3.1733115e-5,780.00001 38.316131,780M178.22806,765h46.73407M133.81618,765h24.67327M10,765H36.284215M134.68701,750h86.50156M10,750H34.542573M134.97728,735h83.01828M15,735H35.12312M132.65509,720H205M15,720H37.844594M155,705h45M325,510c-11.82334,-17.57111 -24.45521,-31.94743 -45.42097,-47.16261 -21.67788,-15.73198 -32.01525,9.6364 -23.86278,22.70472M325,540c-13.68399,-15.7169 -40.72661,-39.31758 -62.25684,-51.80699 -20.39713,-11.83211 -26.52283,15.09906 -9.53546,27.99468M326.64903,572.53873c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -33.04187,-18.08643 -43.83934,14.15892 -2.74316,31.80699M329.68204,632.14459c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -30.81157,-16.86561 -37.65608,16.8659 -5.11631,35.80661M328.06764,597.68777c-13.86078,-13.59047 -33.31597,-27.70524 -50.77313,-39.51278 -22.07438,-14.9305 -34.10496,4.47364 -22.83565,17.22609M332.19576,659.38835c-13.77031,-13.23256 -32.62008,-26.88451 -49.58329,-38.35795 -24.04479,-16.26322 -36.17268,12.27173 -19.25152,25.31598M335.48063,686.60634C319.24375,673.64242 295.51352,659.7442 277.4252,650.3376c-31.2697,-16.26141 -36.88691,20.47944 -3.29829,37.12122M339.44241,709.94356C293.812,671.34406 241.20364,684.64228 285,715M345.57813,743.85785c-49.78299,-42.23381 -140.14002,-42.27022 -51.45386,5.50004M359.15379,797.42734C296.30783,757.35598 217.41506,767.9862 315.25691,808.08817M356.15219,815.71589c-43.41581,-18.1629 -92.79129,0.20988 -43.97099,13.65755M335.79649,833.55074c-36.46249,-11.38361 -55.92576,9.42664 -11.42381,20.21059M323.63736,467.38673c-7.1925,-7.58612 -15.51039,-14.89158 -25.85855,-22.4014 -17.52111,-12.71535 -26.71907,0.32727 -25.12324,12.4885M322.15877,428.22708c-1.31784,-1.00168 -2.67007,-2.00587 -4.05887,-3.01374 -19.41173,-14.0874 -28.60717,3.4419 -24.22651,16.36102M351.5017,769.34668c-41.8286,-32.62324 -87.13007,-22.98664 -57.82646,2.59886M396.50984,805.03398c97.55186,1.04019 65.93584,25.61549 21.19412,25.63392M410.20409,785.71584c31.87867,-11.92022 60.58013,-9.17207 74.95842,-1.62887 16.81695,8.82258 14.04006,24.2047 -26.16419,30.34906M430.54986,757.7319c58.57662,-11.0001 103.69453,13.94896 55.48459,26.1888M451.62343,729.60393c67.42086,-18.09697 125.45489,10.74224 49.42624,33.66324M469.15226,707.61747c69.25339,-23.47062 135.42699,4.47512 67.15155,28.14525M497.03474,675.73394c50.50234,-8.00778 88.6752,9.66559 55.551,28.0217M514.06286,656.56715c77.25396,-19.94453 157.95502,17.262 48.7626,27.75334M550.91529,618.31036c57.1762,-5.00205 100.00874,18.02731 40.2256,35.03407M568.89077,600.93936c75.24789,-19.79781 151.84194,14.60918 51.22446,34.33609M596.84001,574.15634c55.64482,-7.64299 102.46778,11.7471 64.24628,28.76475M620.73761,552.10789c71.56974,-16.51587 140.66537,14.62009 53.45997,34.06378M660.73433,515.56983c57.1151,-4.52529 99.00079,18.87447 36.45506,35.78648M684.38719,494.58861c73.88041,-16.89549 144.8643,16.89901 43.68109,36.08147M722.79564,460.82624c57.76542,-5.50387 101.75016,17.65976 42.02455,34.7974M748.43052,437.7647c68.01755,-11.92015 127.59071,17.4385 43.80212,36.02686M645.55164,273.86211C640.4516,285.47932 635.59316,297.26013 610,295c-14.37233,81.30224 -73.77303,98.38804 -130,120 0,0 -19.41945,15.64589 -29.41945,15.64589C435.58055,430.64589 425,425 420,425c-5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -30,-40 -55,-96.04455 -55,-125 0,-20 5.003,-149.9992 5,-155 -0.002,-3.089335 -5.72781,-42.445846 -10.1037,-72.07356M622.93321,240.32144C616.61632,250.552 609.19352,264.74236 615,265c2.73428,0.12132 6.96971,-10.37759 10.24354,-19.90618M904.16018,494.81448l50.56379,54.17549M889.99031,508.2039l48.73454,52.21558M875.34795,521.08709l48.01937,51.44933M861.63691,534.96812l46.15447,49.45122M847.01655,547.87487l45.96336,49.24646M832.83302,561.24966l35.28817,37.80876M818.66315,574.63908l24.02599,25.74214M803.86532,587.3557l17.84203,19.11646M790.06402,601.14003l8.92784,9.56554M482.75862,925h55.41872M495.89491,910h55.00821M508.21018,895h55.82923M521.34647,880h55.41872M534.48276,865h55.41872M552.95566,845H585M790,820v32.5M765,820v32.5M740,820v32.5M703.26765,833.26765l22.578,22.578M684.08867,854.08867l23.39901,23.39901M665.93596,875.93596l22.78325,22.78325M648.19376,898.19376l22.578,22.578M629.22003,919.22003l20.73071,20.73071M791.29599,310.75526c15.62961,-6.29692 31.83381,-11.83473 48.11454,-16.69002M776.15664,290.35133c15.84539,-6.35519 32.2728,-11.93292 48.76488,-16.81275M760.82223,270.4856c16.18061,-6.50419 32.97255,-12.19625 49.8241,-17.16102M746.54814,252.22866c16.42632,-6.7965 33.54246,-12.73644 50.75899,-17.91046M739.12096,229.17409c11.71799,-4.608 23.73402,-8.79725 35.84163,-12.5995M726.54679,208.22774c8.46394,-3.2756 17.07495,-6.33535 25.75602,-9.1911M711.68624,188.33917c5.39484,-2.00758 10.85695,-3.94932 16.37032,-5.82515M900.40882,94.431781C848.5463,114.25376 796.72828,69.769511 761.4322,93.621964 715,125.00001 755,185 789.33498,165.18883 821.13528,146.84017 790,105 775,115c-9.30261,6.20174 -14.88842,18.30946 -10,25 6.18042,8.45885 10.48873,9.62814 20,5M901.46652,97.13303C861.76115,135.4564 879.34663,201.01228 842.74068,222.52055 794.42332,250.91 757.5027,188.96753 790.17065,166.51363c30.25635,-20.79631 54.6061,25.32412 39.1205,34.55428 -9.60379,5.72429 -22.93675,5.55043 -26.86936,-1.74304 -4.972,-9.22111 -4.17161,-13.61293 4.10189,-20.20332M765,180l90,-60M845,160c-10,-10 -45.467,-11.35662 -55,5 22.00764,-11.03808 34.76336,-24.75676 25,-45M795,230c25,30 50,20 75,10 24.05541,32.7653 64.66095,38.66637 105,45M725,130C715,110 740,85 755,75 749.14905,51.948962 757.70702,26.00987 766.59362,0.00490542M700,90c10,-25 25,-25 25,-25 -8.48271,-38.172217 3.28893,-47.867055 8.18679,-64.93099617M427.96416,0.01822477C445.06535,51.748024 483.31343,78.400493 539.31946,83.994433M446.67053,0.04362022C462.63103,38.843647 492.03631,61.699978 533.14043,70.683071M461.24526,0.01603427C475.22521,27.447203 496.92922,45.718691 525.58366,55.74792M476.99588,0.10806452C487.38028,16.453559 500.99836,28.964352 517.63646,37.893813M371.26432,0.04443925C356.34418,40.196712 340.91798,80.075485 304.69652,100.28589M355.60874,0.04353776C343.34293,31.804187 329.13875,61.845937 302.67098,80.298673M339.57059,0.02060224C329.73362,23.196287 317.89132,44.53011 299.71459,59.883794M325.15652,0.08430598C317.46458,14.722402 308.27692,27.964826 296.26758,38.544057M305,120c41.1016,-25.066138 61.56092,-14.28714 80,0 20,55 -15,110 -14.41945,151.6763 0.21559,15.47674 11.72696,13.44856 19.41945,13.3237 4.99934,-0.0811 15,10 15,10M305,125c29.58587,-20.97635 55.47603,-17.50669 80,-5M430,245c20,0 20,30 5,30 -40,5 -40,-10 -5,0M365,315v10l5,-5 -5,-5v0M455,320l5,-5v10l-5,-5v0M370,320c0,0 5,5 10,5 5,0 5.24415,-4.00984 12.32219,-4.4848C400,320 400,325 405,325c5,0 15,-10 20,-10 5,0 15,5 20,5h10M390,340c3.06957,28.45212 45.6136,8.68856 45,5 -5,5 -44.77199,31.85105 -45,-5v0M430,135c51.53607,-36.718861 85.86501,-16.18211 120,5 -35.40475,-25.98218 -85,-45 -120,-5v0M540,160C525,160 503.52953,134.61544 483.61398,136.45137 453.79885,139.1999 445,175 430,180 447.93464,158.59181 463.7944,151.78059 478.07024,151.93493 507.27438,152.25068 515,185 550,175M430,180c15,-10 32.80939,10.04302 45.17423,9.94542C504.08195,189.71723 519.49385,175 530,175M380,175c-20,0 -30.87367,-19.1648 -47.03192,-20.29027 -12.3413,-0.85961 -29.19452,12.61246 -29.19452,17.61246 0,7.07107 11.23734,20.70784 22.74316,23.25836C342.90794,199.21402 362.81244,175.3491 380,175v0M305,165c22.64276,-42.75014 64.95345,-9.49214 65,-5M820,265c15,15 35,10 45,5 20.5191,14.6565 42.75671,20.72048 62.68286,23.22939M851.86653 312.33707C895.10619 299.11787 938.83136 290.34833 975 285C924.90149 188.22308 899.90057 94.152754 874.11725 -0.0019513659 M851.86653,312.33707C895.10619,299.11787 938.83136,290.34833 975,285 924.90149,188.22308 899.90057,94.152754 874.11725,-0.00195137M851.01315,311.99775 635.36748,-2.4089679e-4M927.65339,293.26472C907.75671,290.72048 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5"
        ></path>
      </symbol>
      <symbol id="SQ6" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="3"
          fill="none"
          d="M986.60333,811.20184l17.52527,26.83701m3.5763,5.47663 14.2883,21.88014M993.49031,800.86775c12.59499,20.81314 26.36539,39.79428 40.67199,57.93996m3.6811,4.63683c6.0574,7.57938 12.2001,15.02588 18.3803,22.41378m3.5795,4.26824c4.9357,5.87225 9.8895,11.71638 14.8372,17.56998M1002.2895,791.27746c25.6547,42.89167 56.3312,77.95704 86.5273,113.77117M1011.3206,782.24417c26.5981,44.89853 58.7236,81.18275 90.1523,118.55299M1018.2105,775.40469C1045.4382,820.51985 1078.1971,857.01507 1110,895M91.990234,409.08984c5.346491,34.39969 12.364566,69.89746 17.978516,99.54297 5.61395,29.64551 9.60751,54.84672 9.52344,62.49219 -0.14502,13.18721 -2.60383,25.09508 -7.35157,32.2207C107.39289,610.47133 101.33414,615 85,615 68.665861,615 62.607113,610.47133 57.859375,603.3457M95.230469,511.42383c2.783382,14.69817 5.162021,28.28252 6.812501,38.99023 1.65048,10.70771 2.46055,19.51658 2.44922,20.54688 -0.12561,11.42229 -3.03694,21.37127 -4.833987,24.06836 -1.554361,2.33286 -1.96098,2.67133 -3.316406,3.33203C94.986371,599.02203 91.780811,600 85,600M99.244141,641.85938C113.48363,645.75807 120,654.05348 120,660c0,3.87456 -2.13436,8.18273 -8.24609,12.46094C105.64218,676.73915 95.96981,680 85,680 74.030191,680 64.357824,676.73915 58.246094,672.46094M99.476562,706.76367c8.835718,2.48582 12.847888,6.43575 15.929688,11.99805C118.48805,724.32402 120,732.04575 120,740c0,15.20071 -2.70618,36.77501 -6.41016,58.11133M102.94922,660.2832C99.903483,662.33803 92.860098,665 85,665c-7.997241,0 -15.198086,-2.76015 -18.152344,-4.82812M102.28516,726.03125C103.52282,728.2651 105,733.94656 105,740c0,13.42041 -2.56634,34.6744 -6.189453,55.54492M726.75998,368.27894C639.85431,387.67178 574.6926,396.00751 524.83867,397.57475M715.61309,356.58894C649.94086,370.7787 597.12268,378.4618 554.16847,381.63062M703.03893,344.25945c-49.76763,10.38288 -91.8849,16.91189 -127.75629,20.52287M690.7875,331.76901c-38.30305,7.6982 -71.90839,13.04175 -101.50758,16.49148M680.13806,318.87243c-30.03631,5.82677 -57.08899,10.16495 -81.51547,13.25269M670.20516,305.76564c-23.347,4.36958 -44.8345,7.81564 -64.64196,10.45774M659.57286,292.71511c-18.04772,3.23925 -34.94556,5.91034 -50.78275,8.07274M390,380c11.94547,-13.95601 27.22073,-12.69836 45,0M440,195c10,15 30,15 45,15M310,205c50,25 60,-30 70,-30M350.01995,162.05531c1.14299,3.17833 1.7863,6.76631 1.7863,10.56373 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-5.79795 1.49965,-11.10766 3.98776,-15.21654M488.55832,153.60687c1.90775,3.81995 3.02626,8.46304 3.02626,13.4703 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-4.03258 0.72545,-7.82898 2.00436,-11.14943"
        ></path>
        <use xlink:href="#SSQ" height="90" transform="translate(1188,935)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1194,1043)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1096,1033)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1022,947)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(918,851)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(897,726)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
      </symbol>
      <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
      <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
      <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      <g transform="rotate(180)">
        <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
        <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
        <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      </g>
      <use xlink:href="#XSQ" stroke="#44F" fill="none"></use>
    </svg>
  `;
  html = replaceAllFast(html, 'black', 'green');
  mDiv(dTable, {}, null, html);
  return;
}
function test100() {
  let keys = {};
  for (const k in CODE.di) { for (const k1 in CODE.di[k]) keys[k1] = CODE.di[k][k1]; }
  CODE.all = keys;
  CODE.keylist = Object.keys(keys)
  let inter = intersection(Object.keys(keys), Object.keys(window));
  let done = {};
  let tbd = ['_start'];
  let MAX = 1007, i = 0;
  let alltext = '';
  while (!isEmpty(tbd)) {
    if (++i > MAX) break;
    let sym = tbd[0];
    let o = CODE.all[sym];
    if (nundef(o)) o = getObjectFromWindow(sym);
    if (o.type != 'func') { tbd.shift(); lookupSet(done, [o.type, sym], o); continue; }
    let olive = window[sym];
    if (nundef(olive)) { tbd.shift(); lookupSet(done, [o.type, sym], o); continue; }
    let text = olive.toString();
    if (!isEmpty(text)) alltext += text + '\r\n';
    let words = toWords(text, true);
    for (const w of words) {
      if (nundef(done[w]) && w != sym && isdef(CODE.all[w])) addIf(tbd, w);
    }
    tbd.shift();
    lookupSet(done, [o.type, sym], o);
  }
  let tres = '';
  for (const k of ['const', 'var', 'cla', 'func']) {
    console.log('done', k, done[k])
    let o = done[k]; if (nundef(o)) continue;
    let klist = get_keys(o);
    if (k == 'func') klist = sortCaseInsensitive(klist);
    for (const k1 of klist) {
      if (isLetter(k1) && k1 == k1.toLowerCase()) continue;
      let code = CODE.justcode[k1];
      if (!isEmptyOrWhiteSpace(code)) tres += code;
    }
  }
}
function test100_partial_sequences() {
  let hand = ['AHn', '2Hn', '3Hn', '4Hn', '5Hn', '6Hn', '7Hn', '8Hn'];
  hand = ['AHn', '2Hn', '3Hn', '4Hn', '5Hn', '7Hn', '8Hn'];
  hand = ['4Hn', '7Hn', 'AHn', '2Hn', '5Hn', '6Hn', '3Hn', '8Hn'];
  hand = ['4Hn', '7Hn', 'AHn', '2Hn', '3Hn', '8Hn'];
  hand = ['4Hn', '7Hn', 'AHn', '2Hn', '9Hn', 'THn', 'QHn', '3Hn', '8Hn'];
  hand = ['4Hn', '7Hn', 'AHn', '2Hn', 'THn', 'QHn', '3Hn', '8Hn'];
  let items = hand.map(x => ferro_get_card(x));
  console.log('items', items);
  sortCardItemsToSequence(items);
}
function test11() {
  document.body.style.height = '100vh';
  let mobj = addDeckTo(makeDeck({ kind: 'deck52', N: 30, nJokers: 5 }), document.body, 'discardPile', true, true);
  mobj.setPos(0, -300);
}
function test11_besseresColoring() {
  var dMain = document.getElementById('dMain');
  mStyle(dMain, { bg: 'indigo' });
  let [dHeaderLeft, dTitle, dHeaderRight] = std3title(dMain, 'Aristocracy', { family: 'AlgerianRegular' });
  let [dLeft, dMiddle, dRight] = std3fold(dMain);
  let dFooter = mDiv(dMain, { bg: '#00000050' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton(dHeaderLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
  let bMenuRight = stdMenuButton(dHeaderRight);
  stdSidebarController(bMenuRight, 'dRight');
}
function test11_cardcoloring() {
  let dTable = mBy('dTable'); clearElement(dTable);
  let card = ari_get_card('KHn');
  mAppend(dTable, iDiv(card));
  let d = mDiv(dTable, {}, null, queen_html());
}
function test11_function() {
  C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
  C.add({ astep: .1, a: 0, bstep: .1, b: 0, color: 'skyblue', thickness: 1, basefunc: x => -x * (-Math.sign(x)), func: x => Math.sin(x), update: oscillator });
}
function test11_gengraph() {
  let items = create_nodes({ x: 0, y: 0, w: 500, h: 500 }, 20, 120);
  console.log('items', items, items[120]);
  dTable = toElem('map');
  plot_on_div(dTable, items);
  adjacency_init(items);
}
function test11_oest() {
  let map = M.map = create_map({ zoom: 7, center: Geo.cities.salzburg });
  let list = get_values(Geo.cities).filter(x => x.country == 'Austria');
  console.log('list', list);
  for (const c of list) {
    create_agent(map, c);
  }
}
async function test11_say() {
  say(germanize('wie fuehlst du dich gerade?'), 'pl', test12_iconviewer, 1, .8, .8);
}
function test12() {
  document.body.style.height = '100vh';
  let deck = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  clearElement(document.body);
  addDeckTo(deck, document.body, 'deck1', true, true);
}
function test12_backToPresent() {
  dMenu = mMenuLine(dMain);
  dMenu.style.display = 'block';
  let bToggle = mMenuButton(dMenu);
  let d = mDiv(dMain);
  mCenterFlex(d);
  let d1 = present_structured1(d, state);
  let sb = iSidebar(mDiv(d), d1, bToggle, 40, true);
}
function test12_cyto() { }
function test12_europe() {
  let map = M.map = create_map({ zoom: 5, center: Geo.cities.stuttgart });
  let list = get_values(Geo.cities).filter(x => x.continent == 'Europe' && x.pop >= 1000000 && x.country == 'Austria');
  console.log('list', list);
  for (const c of list) {
    let m = create_fa(map, 'helicopter', c.center);
    break;
  }
}
function test12_fop() {
  let f = fprime('x*x'); let y = f(5); console.log('math.js y', y);
}
async function test12_iconviewer() {
  let items = findKeys('face').map(x => Syms[x]);
  items = KeySets['smileys-emotion'].map(x => Syms[x]);
  items = items.map(x => ({ key: x.key, text: x.text, E: x.E, D: x.D, family: x.family }));
  let items2 = Info.emotion.map(x => ({ key: x, E: x, D: '', family: 'opensans', text: '' }));
  sortBy(items2, 'key');
  items2 = arrRemoveDuplicates(items2, 'E');
  items = items.concat(items2);
  dTable = mBy('dTable');
  for (const item of items) ui_type_item(dTable, item, {}, null, item.key);
}
function test12_try_svg() { }
function test13() {
  let d = document.body;
  dTable = mDiv(d, { box: true, padding: 4, w: '100vw', h: '100vh', bg: GREEN }, 'dTable');
  dFiddle = mDiv(dTable, { w: 200, h: 200, bg: RED, padding: 4 }, 'dFiddle');
  dTitle = mDiv(dFiddle, {}, null, 'Fiddle');
  AU.ta = mDom(dFiddle, { w: '100%', h: 'rest', bg: '#ffffff80' }, { id: 'ta', className: 'plain', tag: 'textarea' });
  console.log('AU.ta class', AU.ta)
}
function test13_doubleDD() {
  let dParent = addDivToBody();
  dParent.id = 'dParent';
  let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
  let dTarget1 = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
  dTarget1.id = 'dTarget1';
  let dTarget2 = addDivPosTo(dTarget1, 50, 50, 200, 120, unit = 'px', bg = 'green');
  dTarget2.id = 'dTarget2';
  let pic = addPicto(d, 'whistle');
  pic.id = 'dPic';
  posXY(pic, dParent, 10, 20);
  pic.draggable = true;
  pic.ondragstart = drag;
  pic.isPic = true;
  dTarget1.ondragover = allowDrop;
  dTarget1.ondrop = drop;
  dTarget2.draggable = true;
  dTarget2.ondragstart = drag;
  dTarget2.isPic = false;
  dParent.ondragover = allowDrop;
  dParent.ondrop = drop;
}
function test13_get_the_div() {
  let map = M.map = create_map({ zoom: 5, center: Geo.cities.stuttgart });
  let dmap = document.getElementById('map');
  let dtiles = dmap.firstChild.firstChild;
  console.log('dtiles', dtiles);
}
function test13_load_yt_in_iframe() {
  var div = document.createElement('iframe');
  div.id = 'iframe1';
  mStyle(div, { w: 500, h: 300 })
  document.getElementById("map").appendChild(div);
  div.src = "https://www.youtube.com/embed/3pNpHZ1yv3I"; //YES!
}
function test13_makeDraggableTo() {
  let dParent = addDivToBody();
  dParent.id = 'dParent';
  let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
  let dTarget1 = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
  dTarget1.id = 'dTarget1';
  let dTarget2 = addDivPosTo(dTarget1, 50, 50, 200, 120, unit = 'px', bg = 'green');
  dTarget2.id = 'dTarget2';
  let pic = addPicto(d, 'whistle');
  pic.id = 'dPic';
  posXY(pic, dParent, 10, 20);
  makeElemDraggableTo(pic, dTarget1);
  makeElemDraggableTo(dTarget2, dParent);
}
function test13_nerdamer() {
  nerdamer.setVar('M', 'matrix([1, 5], [4, 4])');
  var x = nerdamer('invert(M)');
  console.log(x.toString(), typeof x, x);
  var r = nerdamer('polarform(b*x+x*c*i)');
  console.log(r.toString());
  var t = nerdamer('polarform(5+i)')
  console.log(t.toString());
  nerdamer.setVar('M', 'matrix([x,y],[a,b])');
  console.log(nerdamer('transpose(M)').toString());
  nerdamer.setVar('M', 'matrix([4,5],[1,7])');
  x = nerdamer('determinant(M)');
  console.log(x.toString(), Number(x), typeof x, typeof Number(x), Number(x) + 1);
  console.log('==>', parseFloat(x));
  var x = nerdamer('limit(x^x-1,x,0)');
  console.log(x.toString());
  var y = nerdamer('limit((x^2+2*x-3)/(x^6+4),x,0)');
  console.log(y.toString());
  var x = nerdamer('solve(x^3+1, x)');
  console.log(x.toString());
  x = nerdamer.solve('x^2+2*x+1', 'x');
  console.log(x.toString());
  x = nerdamer.solve('3*(x+a)*(x-b)', 'x');
  console.log(x.toString());
  x = nerdamer.solve('3*(x+a)*(x-b)', 'x');
  console.log(x.toString());
  x = nerdamer('solve(x^4=1,x)');
  console.log(x.toString());
  x = nerdamer('solve(y=m*x+c, x)');
  console.log(x.toString());
  x = nerdamer.solve('x^2-1', 'x');
  console.log(x.toString());
  x = nerdamer.max(1, 4, 3, 5);
  console.log(x.toString());
  var x = nerdamer('sqcomp(9*x^2-18*x+17)');
  console.log(x.toString());
  var y = nerdamer('sqcomp(a*x^2+b*x-11*c, x)');
  console.log(y.toString());
  var x = nerdamer('roots(x^2-3*x-10)');
  console.log(x.toString())
  var y = nerdamer('roots(x^2+1)');
  console.log(y.toString());
  var x = nerdamer('divide(x^2+2*x+1, x+1)');
  console.log(x.toString())
  var y = nerdamer('divide(-b*z-a*z+b^3+a*b^2+a*b+a^2, b+a)');
  console.log(y.toString());
  var x = nerdamer('gcd(x^2+2*x+1, x^2+6*x+5)');
  console.log(x.toString())
  var y = nerdamer('gcd(b*z+a*z+b^2+a*b, a+b)');
  console.log(y.toString());
  var z = nerdamer('gcd(24,12,552)');
  console.log(z.toString());
  var x = nerdamer('product(x+1, x, 1, 20)');
  console.log(x.toString())
  var y = nerdamer('product(x+y, x, 1, 5)');
  console.log(y.toString());
  var z = nerdamer('product(x, x, 1, 5)');
  console.log(z.toString());
  var x = nerdamer('sum(x+1, x, 1, 5)');
  console.log(x.toString())
  var y = nerdamer('sum(x+y, x, 1, 20)');
  console.log(y.toString());
  console.log('_______simplify')
  var x = nerdamer('simplify((x^2+4*x-45)/(x^2+x-30))');
  console.log(x.toString());
  var y = nerdamer('simplify((17/2)*(-10+8*i)^(-1)-5*(-10+8*i)^(-1)*i)');
  console.log(y.toString());
  var z = nerdamer('simplify(1+1+3+5+13)');
  console.log(z, typeof z, Number(z) + 1);
  console.log('_______ defint')
  var x = nerdamer('defint(e^(cos(x)), 1, 2)');
  console.log(x.text());
  var y = nerdamer('defint(x^2+2*x+1,0, 10)');
  console.log(y.text());
  var y = nerdamer('defint(log(2cos(x/2)),-π,π,x)');
  console.log(y.text());
  console.log('_______ derivative diff')
  var x = nerdamer('diff(cos(x)*sin(x), x)');
  console.log(x.toString());
  var y = nerdamer('diff([x^2, cos(x), 1], x, 2)');
  console.log(y.toString());
  var y = nerdamer('diff(x^3+a*x^3+x^2, x, 2)');
  console.log(y.toString());
  x = nerdamer.diff(nerdamer('x^2').add(1).multiply('tan(x)'), 'x')
  console.log(x.toString());
  x = nerdamer('diff(a+b*x+c*x^2, x)');
  console.log(x.toString());
  x = nerdamer('diff(x^2, x)');
  console.log(x.toString());
  var x = nerdamer('sin(9+5)');
  console.log(x.toString());
  console.log(x.evaluate().toString());
  var x = nerdamer('integrate(x*2,x)');
  console.log(x.toString());
  y = x.evaluate();
  console.log('eval:', y);
  var x = nerdamer('integrate(10*q/(4*x^2+24*x+20), x)');
  console.log(x.toString());
  var y = nerdamer('integrate(sec(x)^2, x)');
  console.log(y.toString());
  var y = nerdamer('integrate([sec(x)^2, x^2, 2], x)');
  console.log(y.toString());
  var x = nerdamer('integrate(cos(x)*x^6, x)');
  console.log(x.toString());
  console.log(x.hasIntegral());
  x = nerdamer.integrate('sinh(x)*e^x');
  console.log(x.toString());
  var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 }).evaluate();
  var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 });
  var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 }).evaluate();
  console.log(e.text());
  console.log(e);
  var e = nerdamer('x^2+2*(cos(x)+x*x)');
  console.log(e.text());
  console.log(e);
  var result = nerdamer('cos(x)', { x: 6 });
  console.log(result.text());
  var result = nerdamer('cos(x)', { x: 6 }, 'numer');
  console.log(result.text());
  var result = nerdamer('cos(x)', { x: 6 }).evaluate();
  console.log(result.text());
  var f = nerdamer('integrate(x,x)').buildFunction();
  console.log(f(3));
  f = nerdamer('diff(x^3,x)').buildFunction();
  console.log(f(20));
}
function test13_simpleDD() {
  document.body.style.height = '100vh';
  let dParent = addDivToBody();
  dParent.id = 'dParent';
  let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
  let purpleTarget = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
  let greenTarget = addDivPosTo(purpleTarget, 50, 50, 200, 120, unit = 'px', bg = 'green');
  let pic = createPicto({ key: 'whistle', parent: d, bg: 'yellow', border: '1px solid green', rounding: 12 });
  pic.type = 'pic';
  makeDraggable(pic);
  makeDroppable(purpleTarget);
  dropPosition = (ev, elem, target) => { posOverlap(elem, target, 10, 5, 'type'); };
}
function test13_simpleDDMultiple() {
  let dParent = addDivToBody();
  dParent.id = 'dParent';
  let purpleTarget = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
  let greenTarget = addDivPosTo(purpleTarget, 50, 50, 200, 120, unit = 'px', bg = 'green');
  let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
  for (let i = 0; i < 7; i++) {
    let k = getRandomKey(iconChars);
    let pic = createPicto({ key: k, parent: d, bg: 'yellow', border: '1px solid green', rounding: 12 });
    pic.type = 'pic';
    posOverlap(pic, d, 120, 0, 'type');
    makeDraggable(pic);
  }
  makeDroppable(purpleTarget);
  dropPosition = (ev, elem, target) => { posOverlap(elem, target, 10, 5, 'type'); };
}
function test14() {
  show_emos();
  say('what do you feel right now???', 'uk', null, .5, .8);
}
function test14_divPosTest() {
  let dParent = addDivToBody();
  dParent.style.setProperty('float', 'right');
  dParent.style.setProperty('margin', '10px');
  setDivBg(dParent, 'green');
  setDivSize(dParent, 300, 200);
  let d = addDivPosTo(dParent, 20, 50, 100, 100, unit = 'px', bg = 'red');
}
function test14_factory() {
  let d = mSym('frog', 'map');
}
function test14_function() {
  C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
  C.add({ astep: .1, a: 0, bstep: .1, b: 0, color: 'skyblue', thickness: 1, basefunc: x => -x * (-Math.sign(x)), func: x => Math.sin(x), update: oscillator });
  C.play();
}
function test15() {
  let d = document.body; mClass(d, 'fullpage');
  let areas = [
    'dTestButtons dTestButtons',
    'dSearch dSidebar',
    'dFiddle dSidebar',
    'dTable dSidebar',
  ];
  let cols = '1fr 200px';
  let rows = 'auto auto auto 1fr';
  dGrid = mGridFrom(d, areas, cols, rows);
  for (const ch of arrChildren(dGrid)) {
    console.log('rect', ch.id, getRect(ch))
  }
  mStyle(dGrid, { fg: 'white', bg: 'silver' })
  test15_weiter();
}
function test15_addDivU() {
  let dParent = addDivU({ dParent: document.body, bg: 'yellow', margin: 10, w: 300, h: 200, unit: 'px', float: 'right' });
  let d = addDivU({ dParent: dParent, x: 20, y: 50, w: 100, h: 100, unit: 'px', position: 'absolute', bg: 'red' });
}
function test15_fa_list() {
  dTable = mBy('map');
  let animations = ['beat', 'bounce', 'fade', 'flip', 'pulse', 'shake', 'spin'];
  let iani = 0;
  let list = Info.fa;
  for (const w of arrTake(list, 25)) {
    let an = 'pulse';
    let d = mDiv(dTable, { align: 'center', bg: 'blue', margin: 8, fg: 'white', display: 'inline-block', padding: 10 }, null, `<i class="fa fa-${w} fa-${an} fa-3x"></i><br>${w}`);
  }
}
function test15_function() {
  C = new Plotter(dTable);
  C.add({ color: 'skyblue', thickness: 1, func: x => Math.sin(x) });
  C.draw();
}
function test15_qa() {
  G = {
    i: 0,
    q: null,
    alist: null,
    selist: null,
    hist: [],
    stcont: { box: true, wmin: 600 },
    sta: { cursor: 'pointer', aitems: 'center', vpadding: 6, hpadding: 12, gap: 4, margin: 6, rounding: 12, fg: 'contrast' },
    stq: { padding: 12, weight: 'bold', family: 'opensans', fz: 28 },
  };
  q0();
}
function test15_weiter() {
  mStyle(dFiddle, { padding: 4, h: 400 });
  mClear(dFiddle)
  dTestButtons.innerHTML = 'Test Buttons'
  mDom(dFiddle, {}, { html: 'Fiddle' })
  AU.ta = mDom(dFiddle, { w100: true, hrest: true, bg: '#ffffff80' }, { tag: 'textarea', id: 'ta', className: 'plain hop1' });
  console.log('AU.ta', AU.ta)
}
function test16() {
  let d = document.body; mClass(d, 'fullpage');
  let areas = [
    'dTestButtons dTestButtons',
    'dSearch dSidebar',
    'dFiddle dSidebar',
    'dTable dSidebar',
  ];
  let cols = '1fr 200px';
  let rows = 'auto auto auto 1fr';
  dPage = mGridFrom(d, areas, cols, rows);
  mStyle(dPage, { fg: 'white', bg: 'silver' })
  mStyle(dFiddle, { h: 400, padding: 14, box: true });
  mDom(dFiddle, {}, { html: 'Fiddle' });
  AU.ta = mDom(dFiddle, { w100: true, box: true, h: 'rest', bg: '#ffffff80' }, { tag: 'textarea', id: 'ta', className: 'plain hop1' });
  maButton('test', onclickTest, dTestButtons, { className: 'a' });
}
function test16_fa_animation() {
  dTable = mBy('map');
  let fa = rChoose(Info.fa);
  mCenterCenterFlex(dTable); mStyle(dTable, { bg: 'white', position: 'relative' });
  let d0 = mDiv(dTable); mStyle(d0, { rounding: '50%', align: 'center', bg: 'blue', fg: 'white', display: 'inline-block' })
  let dfa = mDiv(d0, { padding: 40, }, null, `<i class="fa fa-${fa} fa-2x"></i>`);
}
function test16_function() {
  C = new Plotter(dTable);
  C.add({ color: 'skyblue', thickness: 1, func: nerdamer('integrate(x,x)').buildFunction() });
  C.draw();
}
function test16_g() {
  let dParent = addDivToBody();
  let g1 = addGFill('g1', dParent);
  let g2 = d3.select(g1).append('g').attr('fill', 'yellow').attr('stroke', 'black').attr('stroke-width', 5);
  g2.append('rect').attr('width', '50px').attr('height', '50px');
  let g3 = d3.select(g1).append('g').attr('fill', 'red').attr('stroke', 'white').attr('stroke-width', 5);
  let r3 = g3.append('rect').attr('width', '50%').attr('height', '50px');
  g3.node().style.transform = 'translate(-10px, -200px)';
  let g = g3.node();
  g.classList.add('green');
  g.classList.add('yellowStroke');
  let cl = g.classList;
  console.log(cl, typeof cl, cl.value, typeof cl.value);
  let cl2 = g.getAttribute('class')
  console.log(cl2, typeof cl2);
  console.log(g.getAttribute('class'))
  g.classList.remove('yellowStroke');
  let boundsG1 = getBounds(g1);
  let boundsG2 = getBounds(g2.node());
  let boundsG2_rel = getBounds(g2.node(), true);
  let boundsG3 = getBounds(g3.node());
  let boundsG3_rel = getBounds(g3.node(), true);
  let boundsDiv = getBounds(dParent);
  console.log('boundsG1', boundsG1)
  console.log('boundsG2', boundsG2)
  console.log('boundsG2_rel', boundsG2_rel)
  console.log('boundsG3', boundsG3)
  console.log('boundsG3_rel', boundsG3_rel)
  console.log('boundsDiv', boundsDiv)
  return;
  d3.select(g2).style('transform', 'translate(50%, 50%)')
  let r = d3.select(g1).attr('fill', 'red').append('rect').attr('width', '100px').attr('height', '100px');
  console.log('g1', d3.select(g1).node());
  console.log('r', r.node());
  let rect = d3.select(g1.children[0]);
  console.log(rect, r);
  r.attr('stroke', 'green').attr('stroke-width', 5).attr('rx', 20).attr('ry', 20);
}
function test16_yt() {
  playt();
}
function test16a() {
  let d = document.body; mClass(d, 'fullpage');
  let areas = [
    'dTestButtons dTestButtons',
    'dSearch dSidebar',
    'dFiddle dSidebar',
    'dTable dSidebar',
  ];
  let cols = '1fr 200px';
  let rows = 'auto auto auto 1fr';
  dPage = mGridFrom(d, areas, cols, rows, { padding: 4, box: true });
  mStyle(dPage, { fg: 'white', bg: 'silver' });
  let elem = mSearch('keywords:', mySearch, dSearch);
  mStyle(dFiddle, { h: 400 });
  mDom(dFiddle, {}, { html: 'Edit Code:' });
  AU.ta = mDom(dFiddle, { w100: true, box: true, h: 'rest', bg: '#ffffff80' }, { tag: 'textarea', id: 'ta', className: 'plain hop1' });
  mFlex(dTestButtons);
  mButton('TEST', onclickTest, dTestButtons);
}
function test17_load_save_texte() {
  mStyle(dTable, { h: '100%', family: 'opensans', fz: 20, bg: ORANGE, fg: 'white', position: 'relative' }); mCenterFlex(dTable);
  let buttons = ['clear', 'magic'];
  dToolbar = mToolbar(buttons, onclick_toobar, 'dToolbar', { padding: 10, display: 'flex', gap: 10, bg: 'orange' });
  document.addEventListener('mouseleave', e => { console.log('page mouse left!!!'); save_all(); })
  document.addEventListener('visibilitychange', e => { if (document.visibilityState === 'visible') { console.log('page activated!'); } else { console.log('page deactivated!!!'); save_all(); } });
  load_all();
  onclick = open_invisible_input;
}
function test17_randomwalk() {
  C = new CCanvasNoClear(dTable, {}, {}, gameloop_start, gameloop_stop);
  C.add({ update: move_random, w: 2, h: 2 });
  C.add(new CItemWalker({ label: 'tom' }))
  C.play();
}
function test1ttt() {
  let board = new Board(dTable, 4, 4, ev => {
    let field = Items[ev.target.id];
    console.log('field', field);
    if (isdef(field.content)) return;
    let item = { field: field, container: ev.target, styles: { bg: 'red', w: 30, h: 30, rounding: '50%' } };
    game_add_item(item);
  });
}
function test2() { }
function test2_2rows() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, {}, 'dHeader', 'header', ['div1']);
  let dOuter = mDiv(dMain, {}, 'dOuter', 'outer', ['div2']);
}
function test2_ari_deck_and_hand(otree) {
  let deck = ui_make_random_deck(10);
  let hand = ui_make_random_hand(1);
  let d = iDiv(deck.topmost);
  deck.items.map(x => { mStyle(iDiv(x), { cursor: 'pointer' }); iDiv(x).onclick = () => anim_from_deck_to_hand(x, deck, hand); });
}
function test2_boa_verify() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  onclick_location('boa');
  boaverify_start();
}
function test2_nerd() {
  var core = nerdamer.getCore();
  var _ = core.PARSER;
  core.Math2.custom = function (x) { return (100 * formula1(x)).toFixed(4); };
  _.functions.custom = [, 1];
  var x = nerdamer('custom(140)').evaluate();
  console.log(x.toString());
  let fi = nerdamer(`integrate(custom(x),x)`).buildFunction();
  let y = fi(100);
  console.log('fi(100)', y)
}
function test2_onclick_user() {
  let ms = 300;
  show_users(300);
  setTimeout(() => onclick_user('felix'), 400);
}
function test2_p5_perlin() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
  iAdd(o, {}, { draw: draw_perlin_x });
  o.play();
}
function test2_pic_dicts() {
  create_pic_dicts(['d']);
}
function test2_point_nomath() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop);
  C.add();
  C.add({ x: -200, y: 100, color: 'pink', draw: draw_point });
  C.draw();
  C.play();
}
function test2_show_contacts() {
  get_login();
}
function test2_sit_around_table() {
  dTable = mBy('dTable');
  let r = getRect(dTable);
  let sz = 250;
  let pts = cCircle({ x: r.w / 2, y: r.h / 2 }, r.w - sz, 6, -90);
  for (const pt of pts) {
    console.log('pt', pt)
    mDiv(dTable, { round: true, x: pt.x - sz / 2, y: pt.y - sz / 2, position: 'absolute', w: sz, h: sz, bg: 'randdark' });
  }
}
async function test2_two_maps() {
  let [cities, capitals] = await get_cities_and_capitals();
  let o = { center: cities.Paris.center, zoom: 7, id: 'map' };
  let m1 = create_map(jsCopy(o));
  copyKeys({ id: 'map2', preferCanvas: true }, o);
  let m2 = create_map(o);
  let a1 = create_agent(m1);
  let a2 = create_agent(m2);
  let f1 = x => x + rFloat(-.01, .05);
  let f2 = x => x + rGaussian(-.01, .05);
  run_for_seconds(2, () => { map_moveby(a2, f2, f2); map_moveby(a1, f1, f1); })
}
function test2_waypointfallback() {
  var map = L.map('map');
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  console.log('geo', Geo)
  let [p1, p2] = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse];
  map.setView(p1, 16)
  M = L.Routing.control({
    waypoints: [
      L.latLng(p1[0], p1[1]),
      L.latLng(p2[0], p2[1])
    ],
    waypointNameFallback: function (latLng) {
      function zeroPad(n) {
        n = Math.round(n);
        return n < 10 ? '0' + n : n;
      }
      function sexagesimal(p, pos, neg) {
        var n = Math.abs(p),
          degs = Math.floor(n),
          mins = (n - degs) * 60,
          secs = (mins - Math.floor(mins)) * 60,
          frac = Math.round((secs - Math.floor(secs)) * 100);
        return (n >= 0 ? pos : neg) + degs + '°' +
          zeroPad(mins) + '\'' +
          zeroPad(secs) + '.' + zeroPad(frac) + '"';
      }
      return sexagesimal(latLng.lat, 'N', 'S') + ' ' + sexagesimal(latLng.lng, 'E', 'W');
    },
    routeWhileDragging: true
  }).addTo(map);
}
function test20_aspect_ratio_image_card() {
  let d = mDiv(dTable, { display: 'grid', place: 'center', h: '100%' });
  let dcard = mDiv(d, { w: '50%', display: 'flex', dir: 'column', padding: '1rem' }, null, null, 'blue');
  let dtitle = mTag('h1', 'Video Title', dcard);
  let dimg = mDiv(dcard, { aspectRatio: '16 / 9' }, null, null, 'green');
  let ddesc = mTag('p', 'Descriptive Text goes here', dcard);
  return d;
}
function test20_imagePalette(dTable) {
  let pal = colorPaletteFromUrl('../base/assets/images/happy/ocean1.jpg');
  let hslist = pal.map(x => colorHSL(x, true));
  let i = 0; hslist = hslist.map(x => ({ h: x.h, s: x.s, l: x.l, color: pal[i], ipal: i++ }))
  i = 0; let byhue = sortBy(hslist, 'h').map(x => ({ color: x.color, ipal: x.ipal, ihue: i++, h: x.h, s: x.s, l: x.l }));
  i = 0; let bylum = sortBy(byhue, 'l').map(x => ({ color: x.color, ilum: i++, ihue: x.ihue, h: x.h, s: x.s, l: x.l }));
  let dmax = 0, c1max, c2max;
  let dlist = [];
  for (let i = 0; i < bylum.length - 1; i++) {
    for (let j = i + 1; j < bylum.length; j++) {
      let [c1, c2] = [bylum[i], bylum[j]];
      let d = colorDistance1(c1, c2);
      dlist.push({ c1: c1, c2: c2, d: d });
      if (d > dmax) { dmax = d; c1max = c1; c2max = c2; }
    }
  }
  sortByDescending(dlist, 'd');
  let lums = [2, 9];
  let hues = [6, 7];
  dlist = dlist.filter(x => x.d >= 30 && (lums.includes(x.c1.ilum) || hues.includes(x.c2.ihue)));
  console.log('===>result', dlist)
  let bestof = arrTake(dlist, 5);
  let crand = rChoose(bestof);
  mStyle(mBy('dAdmin'), { bg: crand.c2.color, fg: crand.c1.color });
  console.log('chosen:', crand.c1.color, crand.c2.color, crand.d);
}
function test21_centering_container() {
  let d = mDiv(dTable, { bg: 'yellow', w: '100%', h: '100%' }); mCenterCenter(d);
  let d1 = mDiv(d, { bg: 'red', 'place-content': 'center', w: '80%', display: 'grid', 'grid-template-columns': 'repeat(auto-fill, 100px)', 'grid-gap': '1rem' });
  for (let i = 0; i < 14; i++) {
    mDiv(d1, { w: rNumber(50, 150), h: 100, bg: 'random', margin: 10 });
  }
}
function test21_resizable() { }
function test22_centering_container() {
  let d = mDiv(dTable, { bg: 'yellow', w: '100%', h: '100%', aitems: 'center' }); mCenterCenter(d);
  for (let i = 0; i < 14; i++) {
    mDiv(d, { display: 'inline-block', w: rNumber(50, 150), h: rNumber(50, 150), bg: 'random', margin: 10 });
  }
}
function test3() { test1(); }
function test3_3rows() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto' }, 'dOuter', 'outer');
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  mSize(dHeader, '100%', 50);
}
function test3_add_cities_layer(color) {
  let cities = rChoose(M.capitals, 20);
  for (const c of cities) map_add_city(M.cities[c]);
}
function test3_ari_deck_2_hands(otree) {
  let deck = ui_make_random_deck(10);
  let hand1 = ui_make_random_hand(1);
  let hand2 = ui_make_random_hand(1);
  let d = iDiv(deck.topmost);
  top_card_to_hands_abwechselnd(deck, hand1, hand2);
}
async function test3_better_agent() {
  M = create_map();
  console.log('M', M);
  let agent = new Agent(M, .0001, false);
  let c1 = create_button(M.map, 'hallo')
  let c2 = create_button(M.map, 'h2')
  let c3 = create_button(M.map, 'h3')
  console.log('buttons', c1, c2, c3)
}
function test3_boa_havecode() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  onclick_location('boa');
  S.boa_authorization_code = '123456';
  boahavecode_start();
}
function test3_cdf() {
  y = cumulative_distribution(85, 115, 100, 15);
  y = cumulative_distribution(105, 115, 100, 15);
  return;
  console.log('y', y); return;
  for (let x = 0; x <= 150; x += 25) {
    let y = cdf0(x);
    console.log('x', x, 'y', y)
  }
}
function test3_game_options() {
  present_game_options();
  close_sidebar();
}
async function test3_letters(l, n) {
  let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
  let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
  let splitter = l == 'e' ? '\r\n' : '\n';
  let words = text.split(splitter);
  let result = words.filter(x => x.length == n);
  let result2 = result.filter(x => x in picdi);
  return { all: result, pic: result2 };
}
function test3_mapbounds() {
  var map = L.map('map');
  map.setView(Geo.places.vegagasse, 16)
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  let b = map.getBounds();
  console.log('b', b._southWest, b._northEast);
  let [p1, p2] = [[b._southWest.lat, b._southWest.lng], [b._northEast.lat, b._northEast.lng]];
  M = get_route_control(map, p1, p2);
}
function test3_p5_perlin_2d() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
  iAdd(o, {}, { draw: draw_perlin_xy });
  o.play();
}
function test3_point_math() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', null, true);
  C.add();
  C.add({ x: 50, y: 80, color: 'pink', draw: draw_point, update: update_move });
  C.add({ x: 50, y: -80, color: 'red', draw: draw_car, update: update_car, v: { a: 0, mag: 5 } });
  C.draw();
  C.play();
}
function test3_show_tables() {
  phpPost({ app: 'easy' }, 'tables');
}
function test3_sit_around_table(n = 4) {
  dTable = mBy('dTable');
  let r = getRect(dTable);
  let [w, h] = [r.w * .9, r.h * .9];
  let [offx, offy] = [r.w * .05, r.h * .05];
  let mindim = Math.min(w, h);
  let [szTable, szPlayer] = [mindim / 2, mindim / 4];
  let pTable = { x: offx + w / 2 - szTable / 2, y: offy + h / 2 - szTable / 2 };
  let styles = { round: true, x: pTable.x, y: pTable.y, position: 'absolute', w: szTable, h: szTable, classname: 'wood' };
  let d = mDiv(dTable, styles);
  let table = iAdd({ numplayers: n, styles: styles }, { div: d })
  let numPlayers = n;
  let sz = szPlayer;
  let pts = cCircle({ x: offx + w / 2, y: offy + h / 2 }, w - sz, numPlayers);
  console.log('pts', pts);
  let players = [];
  for (const pt of pts) {
    let [x, y] = [pt.x - sz / 2, pt.y - sz / 2];
    styles = { round: true, x: x, y: y, position: 'absolute', w: sz, h: sz, bg: colorFrom('randdark') };
    d = mDiv(dTable, styles);
    let player = iAdd({ styles: styles }, { div: d });
    players.push(player);
  }
  return [table, players];
}
function test4() { test2(); }
function test4_3rows() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto', display: 'flex', 'flex-flow': 'row wrap' });
  let dLeft = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
  let dRight = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dRight', 'right');
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  mSize(dHeader, '100%', 50);
}
function test4_ari_deck_2_fixed_size_hands(otree) {
  let deck = ui_make_random_deck(10);
  mLinebreak(dTable);
  let hand1 = ui_make_random_hand(1); mStyle(hand1.container, { w: '50%' });
  let hand2 = ui_make_random_hand(1); mStyle(hand2.container, { w: '50%' });
  let d = iDiv(deck.topmost);
  top_card_to_hands_abwechselnd(deck, hand1, hand2);
}
function test4_boa_main() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  onclick_location('boa');
  S.boa_authorization_code = '123456';
  boamain_start();
}
function test4_direct_login_onclick_user() {
  show_users();
  let uplayer = localStorage.getItem('uname');
  if (isdef(uplayer)) onclick_user(uplayer);
}
function test4_get_waypoints(mymap, p1, p2) {
  var routeData = L.Routing.control({
    waypoints: points_to_waypoints(p1, p2),
    lineOptions: { styles: [{ color: '#006a4e', opacity: 1, weight: 5 }], },
    draggableWaypoints: false,
    createMarker: function () { return false; },
    show: false,
  }).addTo(mymap);
  var routeArray = new Array();
  routeArray = routeData.getWaypoints();
  console.log(routeArray);
  return routeData;
  L.motion.polyline([[52.501737, -2.119792], [52.501267, -2.114707], [52.500313, -2.110361], [52.499243, -2.108751], [52.498596, -2.105886], [52.498812, -2.104953], [52.498798, -2.102591]], {
    color: "transparent"
  }, {
    auto: true,
    duration: 30000,
    easing: L.Motion.Ease.easeInOutQuart
  }, {
    removeOnEnd: false,
    showMarker: true,
    icon: L.icon({ iconUrl: 'marker.png', iconSize: [32, 37] })
  }).addTo(mymap);
}
function test4_intelli() {
  dTable = dTable = mSection({ position: 'relative' }, 'dTable'); mCenterFlex(dTable);
  let ta = mTextarea(10, 90, dTable, { padding: 20, position: 'relative' });
  setTimeout(() => ta.autofocus = true, 10);
  let buttons = mDiv(dTable, { w: '100%', align: 'right', maright: 4 });
  let st = { fz: 14 };
  maButton('RUN (ctl+Enter)', au_run, buttons, st);
  maButton('LINE (ctl+shft+Enter)', au_run_line, buttons, st);
  let tacon = mTextarea(3, 90, dTable, { matop: 4, padding: 20, position: 'relative' });
  ta.focus();
  AU.popup = mDiv(dTable, { position: 'absolute', wmin: 100, hmin: 100, hmax: 600, overy: 'auto', bg: 'blue', fg: 'white' });
  hide(AU.popup)
  AU.fnames = get_keys(CODE.funcs); AU.fnames.sort();
  AU.list = [];
  AU.prefix = '';
  AU.selected = null;
  AU.n = -1;
  AU.ta = ta;
  AU.tacon = tacon;
  ta.onkeydown = ev => {
    let k = ev.key;
    if (k == 'Enter' && AU.selected) ev.preventDefault();
  }
  ta.onkeyup = ev => {
    let k = ev.key;
    let fnames = AU.fnames;
    let popup = AU.popup;
    if (k == 'Enter' && ev.ctrlKey) {
      au_reset();
      let code = ev.shiftKey ? getTextAreaCurrentLine(AU.ta) : AU.ta.value;
      runcode(code);
    } else if (k == ' ' || k == ')') {
      AU.previous = AU.prefix;
      if (isdef(AU.fnames[AU.previous])) {
        let w = AU.selected = AU.previous;
        AU.uebernommen = CODE.funcs[w];
        popup.innerHTML = AU.previous + '(' + AU.uebernommen.params + ')';
      } else {
        au_reset();
      }
    } else if (k == 'Enter' && AU.selected) {
      let w = AU.selected.innerHTML;
      let s = stringAfter(w, AU.prefix);
      AU.ta.value = AU.ta.value + s;
      AU.uebernommen = CODE.funcs[w];
      popup.innerHTML = w + '(' + AU.uebernommen.params + ')';
    } else if (k == 'Backspace' && AU.prefix.length > 1) {
      AU.prefix = AU.prefix.slice(0, -1);
      au_show_list();
    } else if (k == 'ArrowDown' && !isEmpty(AU.list)) {
      if (AU.n < AU.list.length - 1) AU.n++;
      let ch = popup.children;
      if (AU.selected) mStyle(AU.selected, { bg: 'blue' });
      AU.selected = ch[AU.n];
      mStyle(AU.selected, { bg: 'green' });
    } else if (k == 'ArrowUp' && !isEmpty(AU.list)) {
      if (AU.n > 0) AU.n--;
      let ch = popup.children;
      if (AU.selected) mStyle(AU.selected, { bg: 'blue' });
      AU.selected = ch[AU.n];
      mStyle(AU.selected, { bg: 'green' });
    } else if (isLetter(k) || k == '_') {
      if (isEmpty(AU.prefix)) AU.selectionEnd = AU.ta.selectionEnd;
      AU.prefix += k;
      au_show_list();
    } else if (k != 'Shift') {
      au_reset();
    }
  }
}
function test4_load_games() { }
async function test4_multiple_wordlists() {
  for (const l of ['e', 'd', 's', 'f']) {
    for (let i = 6; i < 15; i++) {
      let res = await test3_letters(l, i);
      let s = `${l} ${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
      console.log('', s);
    }
    console.log('________');
  }
}
function test4_range_math_GEHT_NICHT() {
  C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
  let x = colorMix('yellow', 'red'); console.log('color', x)
  let p1 = C.point(5, 3, 'yellow');
  let p2 = C.point(25, 12, 'red');
  for (let i = 0.1; i < .9; i += .1) {
    let p3 = lerpoint(p1, p2, i);
    C.add(p3);
  }
  C.draw();
}
function test4_save() {
  let [table, players] = test3_sit_around_table(3);
  serialize_all();
}
function test4_tools() {
  let map = create_map();
  console.log('map', map);
  let d = map._controlContainer;
  console.log('control container', d);
  dMap = mDiv(d, { position: 'absolute', top: 0, left: 50, w: '100%', h: '100%' });
  dMap.style.zIndex = 12000;
  dTop = mDiv(dMap, { hmargin: 10, padding: 10, cursor: 'pointer' }, null, null, 'top'); mFlexWrap(dTop);
  let b = mButton('hallo', dummy_reaction, dTop);
  b = mButton('download', () => downloadJson({ hallo: 4343 }, '__test'), dTop);
  let a = mLink("http://duckduckgo.com", dTop, { color: 'dimgray' }, null, 'ein link');
  a = mLink("javascript:void(0)", dTop, { color: 'dimgray' }, null, 'ein link');
  a.onclick = dummy_reaction;
  b = mButton('Paris', () => map.setView(Geo.cities.Paris.center), dTop);
  b = mButton('London', () => map.flyTo(Geo.cities.London.center), dTop);
  let agent = new Agent(map, .0001, false);
  return;
  let x = create_toolbar(map); console.log('toolbar', x)
  let tb = x._container; console.log('toolbar', tb);
  mButton('click', () => console.log('clicked!'), tb, { cursor: 'pointer' })
}
function test5(map, p1, p2) {
  let control = M.control = test4_get_waypoints(map, p1, p2);
  M.coords = [];
  control.on('routeselected', function (e) {
    arrExtend(M.coords, e.route.coordinates);
    console.log('M', M)
  });
}
function test5_33mitMenuButtons() {
  let page = pageLayout33();
  let bMenuRight = stdMenuButton();
  mRight(page.dHeader, bMenuRight);
  let bMenuLeft = stdMenuButton();
  mLeft(page.dHeader, bMenuLeft);
}
function test5_ari_anim_deal_market(otree) {
  let deck = ui_make_random_deck(50);
  let market = ui_make_random_market(1);
  mLinebreak(dTable);
  let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
  let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
  top_card_to_market(deck, market);
}
function test5_bw_skin() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  bw_widget_popup('skype');
}
async function test5_letters_upto(l, n) {
  let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
  let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
  let splitter = l == 'e' ? '\r\n' : '\n';
  let words = text.split(splitter);
  let result = words.filter(x => x.length >= 3 && x.length <= n);
  let result2 = result.filter(x => x in picdi);
  return { all: result, pic: result2 };
}
function test5_line_GEHT_NICHT() {
  C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
  let p1 = C.point(5, 3, 'yellow');
  let p2 = C.point(25, 12, 'red');
  for (let i = 0; i < 1; i += .01) {
    let p3 = lerpoint(p1, p2, i);
    C.add(p3);
  }
  C.draw();
}
function test5_load() {
  dTable = mDiv('dTable');
  load_all();
}
function test5_prelim() { }
function test5_showroute() {
  let map = M.map = create_map();
  let agent = M.agent = new Agent(map, .0001, false);
  let tb = M.toolbar = create_toolbar(map);
  let pts = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse]
  let color = 'green';
  let callback = e => fit_points(map, pts);
  let control = M.router = show_route(map, pts, color, callback);
}
function test52CardsOther() {
  keys = ['spades', 'hearts', 'clubs', 'diamonds'];
  for (let i = 0; i < 4; i++) {
    let k = keys[i % keys.length];
    console.log('k', k);
    let card = Karte.random(k, 110);
    mAppend(dTable, iDiv(card));
  }
}
function test6(map, p1, p2) {
  let control = M.control = L.Routing.control({
    waypoints: points_to_waypoints(p1, p2),
    lineOptions: { styles: [{ color: '#006a4e', opacity: 1, weight: 5 }], },
    draggableWaypoints: false,
    createMarker: function () { return false; },
    show: false,
  }).addTo(map);
  M.coords = [];
  control.on('routesfound', function (e) {
    M.routes = e.routes;
    M.num_requests = e.target._requestCount;
    M.coords = arrExtend(M.coords, e.routes[0].coordinates);
    console.log('M', M)
  });
}
function test6_33mitMenuButtons() {
  let page = pageLayout33();
  let bMenuRight = stdMenuButton();
  mRight(page.dHeader, bMenuRight);
  let bMenuLeft = stdMenuButton();
  mLeft(page.dHeader, bMenuLeft);
  dLeft.style.flex = 'unset';//'1 1 200px';
  bMenuLeft.onclick = () => {
    mStyle(mBy('dLeft'), { wmin: 0, w: 0 });
  }
}
function test6_ari_anim_auto_deal(otree) {
  let deck = ui_make_random_deck(50);
  let market = ui_make_random_market(0);
  mLinebreak(dTable);
  let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
  let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
  top_card_to_market(deck, market);
}
function test6_click() {
  let map = M.map = create_map({ zoom: 16 });
  add_click_set_agent();
  let tb = M.toolbar = create_toolbar(map);
  mButton('route', () => {
    map.off('click');
    let pts = M.agents.map(x => x.pos);
    let color = 'red';
    let callback = e => fit_points(map, pts);
    M.router = show_route(map, pts, color, callback);
  }, tb);
  mButton('clear', () => { clear_router(); clear_agents(); add_click_set_agent(); }, tb);
}
function test6_func_GEHT_NICHT() {
  C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
  let f = x => Math.sqrt(x), d = .01;
  for (let x = C.minx; x < C.maxx; x += d) {
    let pt = C.point(x, f(x), 'yellow');
    C.add(pt);
  }
  C.draw();
}
function test6_generate_statement() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  generate_statement();
}
function test6_init() {
  let item = { styles: { bg: 'orange', w: 30, h: 30, round: true } };
  iInit(c1, item);
  iInit(c2, item);
  iInit(dTable, item);
  start_loop();
  setTimeout(() => item.styles.bg = BLUE, 2000);
}
async function test6_multiple_wordlists() {
  for (const l of ['e', 'd', 's', 'f']) {
    for (let i = 3; i < 15; i++) {
      let res = await test5_letters_upto(l, i);
      let s = `${l} ${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
      console.log('', s);
    }
    console.log('________');
  }
}
function test7() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let [dLeft, dMiddle, dRight] = std3fold(dMain);
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton();
  mLeft(dHeader, bMenuLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
  let bMenuRight = stdMenuButton();
  mRight(dHeader, bMenuRight);
  stdSidebarController(bMenuRight, 'dRight');
}
function test7_add_hand_card() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let card = prompt('enter card (eg. 8H');
  fen.players[uplayer].hand.push(card + 'n');
  take_turn_fen();
}
function test7_ari_anim_auto_deal(otree) {
  let deck = ui_make_random_deck(50);
  let market = ui_make_random_market(0);
  mLinebreak(dTable);
  let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
  let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
  DA.qanim = [
    [anim_from_deck_to_marketX, [deck, market]],
    [anim_from_deck_to_marketX, [deck, market]],
  ];
  anim_from_deck_to_marketX(deck, market);
}
function test7_card() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  let x = ui_type_hand(['3Hn', '4Hn', '4Hl'], dTable); console.log('hand', x);
  iReg(x);
  let c = ari_get_card('QDn', 500); mAppend(dTable, iDiv(c));
  animatedTitle();
}
function test7_display_dims_on_moveend() {
  let map = M.map = create_map({ zoom: 16 });
  map.on('moveend', function (e) { calc_map_dims(); console.log("dims", M.dims); });
  let city = rChoose(M.capitals);
  console.log('city has been chosen:', city);
  map.flyTo(Geo.cities[city].center);
}
function test7_function() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
  let ctx = C.cx;
  let canvas = C.cv;
  let h = canvas.height;
  let w = canvas.width;
  let cw = w / 2;
  let ch = h / 2;
  let subStepCount = 10;
  let scale = 10;
  function plot(func, col, lineWidth) {
    let invScale = 1 / scale;
    let top = ch * invScale;
    let bottom = -ch * invScale;
    let subStep = invScale / subStepCount;
    let x, y, yy, xx, subX;
    let start = (-cw - 1) * invScale;
    let end = (cw + 1) * invScale;
    ctx.strokeStyle = col;
    ctx.lineWidth = lineWidth * invScale;
    ctx.beginPath();
    for (x = start; x < end; x += invScale) {
      for (subX = 0; subX < invScale; subX += subStep) {
        y = func(x + subX);
        if (yy !== undefined) {
          if (y > top || y < bottom) {
            if (yy < top && yy > bottom) {
              ctx.lineTo(x + subX, y);
            }
          } else {
            if (yy > top || yy < bottom) {
              ctx.moveTo(xx, yy);
            }
            if (subX === 0) {
              if (y > bottom && y < top) {
                if (Math.abs(yy - y) > (top - bottom) * (1 / 3)) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              }
            }
          }
        } else {
          if (subX === 0) {
            ctx.moveTo(x, y);
          }
        }
        yy = y;
        xx = x + subX;
      }
    }
    ctx.stroke();
  }
  ctx.setTransform(scale, 0, 0, -scale, cw, ch);
  plot(x => 0, 'white', 2);
  plot(x => 5 * Math.sin(x), 'white', 2);
  plot(x => 5 * Math.sin(x), 'white', 2);
}
async function test7_letters_200from(l, n) {
  let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
  let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
  let splitter = l == 'e' ? '\r\n' : '\n';
  let words = text.split(splitter);
  let result = words.filter(x => x.length >= n);
  let result2 = result.filter(x => x in picdi);
  result2.sort((a, b) => a.length - b.length);
  result3 = arrTake(result2, 200);
  return { all: result, pic: result2, sel: result3 };
}
function test7_uploadfile() {
  let o = { filename: 'ex', data: { text: 'jajajaaber geh jaaaa', id: 78912 } };
  route_post_json('http://localhost:3000/post/json', o, response => {
    console.log(JSON.stringify(response))
  });
}
function test8() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let [dLeft, dMiddle] = std2fold(dMain);
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton();
  mLeft(dHeader, bMenuLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
}
function test8_function() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'tl');
  let canvas = C.cv;
  if (null == canvas || !canvas.getContext) return;
  var axes = {}, ctx = canvas.getContext("2d");
  axes.x0 = .5 + .5 * canvas.width;
  axes.y0 = .5 + .5 * canvas.height;
  axes.scale = 40;
  axes.doNegativeX = true;
  console.log('axes', axes)
  showAxes(ctx, axes);
  funGraph(ctx, axes, fun1, "rgb(11,153,11)", 1);
  funGraph(ctx, axes, fun2, "rgb(66,44,255)", 2);
}
function test8_load_googlemap_in_iframe() {
  var iDiv = document.createElement('iframe');
  iDiv.id = 'iframe1';
  mStyle(iDiv, { w: '100%', h: '100%' })
  document.getElementById("map").appendChild(iDiv);
  iDiv.src = 'https://maps.google.com/maps?q=48.2,16.3&output=embed';
}
function test8_mimi_hand_card_0_hover() {
  let hand = G.mimi.hand.items;
  let card = hand[0];
  mClass(iDiv(card), 'hoverScale');
}
async function test8_multiple_wordlists() {
  for (const l of ['e', 'd', 's', 'f']) {
    for (let i = 3; i < 15; i++) {
      let res = await test7_letters_200from(l, i);
      let s = `${l} >=${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
      console.log('', s);
      console.log('result', res.sel)
    }
    console.log('________');
  }
}
function test8_simple_intellisense() {
  dTable = mBy('dTable');
  fiddleInit();
}
function test9() {
  var dMain = document.getElementById('dMain');
  let [dHeaderLeft, dTitle, dHeaderRight] = std3title(dMain, 'Aristocracy');
  let [dLeft, dMiddle] = std2fold(dMain);
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton(dHeaderLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
}
function test9_dbSave() { DB.appdata.simple = [1, 2, 3, 4, 5]; }
function test9_function() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'tl');
  let canvas = C.cv;
  let axes = {}, ctx = canvas.getContext("2d");
  axes.x0 = .5 + .5 * canvas.width;
  axes.y0 = .5 + .5 * canvas.height;
  axes.scale = 40;
  axes.doNegativeX = true;
  C.add({ astep: .1, a: 0, bstep: .1, b: 0, func: x => Math.sin(x), axes: axes, update: geniales_sin_ease });
}
function test9_google() {
  mBy('dTable').innerHTML = `
  <iframe class='flat' id="gmap" src="http://maps.google.com/maps?z=15&t=m&q=loc:48.25+16.3&output=embed" width="100%" height="${window.innerWidth}"></iframe>  
  `;
  let x = document.getElementById('gmap');
  console.log('x', x);
  mStyle(x, { bg: 'blue' });
}
function test9_just_1_card() {
  let dTable = mBy('dTable')
  clearElement(dTable);
  let card = ari_get_card('QSn', 200);
  mAppend(dTable, iDiv(card));
  return card;
}
async function test9_only_syms(l) {
  let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
  let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
  let syms = await route_path_yaml_dict(`../base/assets/allSyms.yaml`);
  let keys = Object.keys(syms);
  let lang = l.toUpperCase();
  let res = keys.filter(x => isdef(syms[x][lang]) && nundef(picdi[syms[x][lang].toLowerCase()]));
  console.log('only syms: lang', l, res.map(x => syms[x][lang]));
}
function test98() {
  let area = mBy(table);
}
function test99() {
  console.log('ah');
  let area = mBy('board'); mPosRel(area);
  let olist = getOlist();
  let size = 50, gap = 10;
  let uis = getUis(olist, colorLabelDiv(size));
  let container = mDivPosAbs(100, 100, area);
  let [w, h] = layoutRow(uis, container, size, size, gap);
  mStyle(container, { width: w, height: h, 'background-color': 'white', 'border-radius': gap });
  colorLabelRow(o)
}
async function testAblauf00(defs, spec, sdata0) {
  await testEngine.init(defs, sdata0, TEST_SERIES);
  let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
  T = R = new RSG(sp, defaults);
  R.initialChannels = [];
  ensureRtree(R);
  R.baseArea = 'table';
  createStaticUi(R.baseArea, R);
  for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
  for (const oid in sdata) {
    let o = sdata[oid];
    if (isdef(o.loc)) { continue; }
    let topUids;
    for (const key of R.getR(oid)) {
      let specNode = R.getSpec(key);
      if (o.loc && nundef(R.Locations[key]) && nundef(specNode._ref)) {
        topUids = addOidByLocProperty(oid, key, R);
      } else if (isdef(R.Locations[key])) {
        topUids = addOidByParentKeyLocation(oid, key, R);
      }
      if (isEmpty(topUids)) { continue; }
      for (const top of topUids) {
        let uiParent = R.uiNodes[top.uidParent];
        let rParent = R.rNodes[top.uidParent];
        if (isdef(uiParent)) {
          uiParent.adirty = true;
          uiParent.children = rParent.children.map(x => x);
        }
        recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
      }
    }
  }
  sieveLocOids(R);
  recAdjustDirtyContainers(R.tree.uid, R, true);
  updateOutput(R);
  testEngine.verify(R);
}
async function testAblauf01(defs, spec, sdata0) {
  await testEngine.init(defs, sdata0, TEST_SERIES);
  let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
  T = R = new RSG(sp, defaults);
  R.initialChannels = [];
  ensureRtree(R);
  R.baseArea = 'table';
  createStaticUi(R.baseArea, R);
  for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
  for (const oid in sdata) {
    let o = sdata[oid];
    if (isdef(o.loc)) { continue; }
    let topUids;
    for (const key of R.getR(oid)) {
      let parents = R.Locations[key];
      if (nundef(parents)) continue;
      topUids = [];
      for (const uidParent of parents) {
        if (parentHasThisChildAlready(uidParent, oid)) continue;
        let n1 = instantOidKey(oid, key, uidParent, R);
        topUids.push({ uid: n1.uid, uidParent: uidParent });
      }
      if (isEmpty(topUids)) { continue; }
      for (const top of topUids) {
        let uiParent = R.uiNodes[top.uidParent];
        let rParent = R.rNodes[top.uidParent];
        if (isdef(uiParent)) {
          uiParent.adirty = true;
          uiParent.children = rParent.children.map(x => x);
        }
        recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
      }
    }
  }
  recAdjustDirtyContainers(R.tree.uid, R, true);
  updateOutput(R);
  testEngine.verify(R);
}
async function testAblauf02(defs, spec, sdata0) {
  await testEngine.init(defs, sdata0, TEST_SERIES);
  let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
  T = R = new RSG(sp, defaults);
  R.initialChannels = [];
  ensureRtree(R);
  R.baseArea = 'table';
  createStaticUi(R.baseArea, R);
  for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
  for (const oid in sdata) {
    let o = sdata[oid];
    if (isdef(o.loc)) { continue; }
    let topUids;
    for (const key of R.getR(oid)) {
      let parents = R.Locations[key];
      if (nundef(parents)) continue;
      topUids = [];
      for (const uidParent of parents) {
        if (parentHasThisChildAlready(uidParent, oid)) continue;
        let rtreeParent = R.rNodes[uidParent];
        if (nundef(rtreeParent.children)) { rtreeParent.children = []; }
        let n1 = recTree(R.lastSpec[key], rtreeParent, R, oid, key);
        R.rNodes[n1.uid] = n1;
        rtreeParent.children.push(n1.uid);
        if (rtreeParent.children.length == 2 && rtreeParent.type == 'invisible' && lookup(rtreeParent, ['params', 'bg'])) {
          let uiParent = R.uiNodes[rtreeParent.uid];
          if (isdef(uiParent)) {
            rtreeParent.type = uiParent.type = 'panel';
            decodeParams(uiParent, R, {});
            uiParent.adirty = true;
            applyCssStyles(uiParent.ui, uiParent.cssParams);
          }
        }
        topUids.push({ uid: n1.uid, uidParent: uidParent });
      }
      if (isEmpty(topUids)) { continue; }
      for (const top of topUids) {
        let uiParent = R.uiNodes[top.uidParent];
        let rParent = R.rNodes[top.uidParent];
        if (isdef(uiParent)) {
          uiParent.adirty = true;
          uiParent.children = rParent.children.map(x => x);
        }
        recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
      }
    }
  }
  recAdjustDirtyContainers(R.tree.uid, R, true);
  updateOutput(R);
  testEngine.verify(R);
}
function testActivate(R) {
  console.log('testActivate', R)
  activateUis(R);
}
function testAdd10Cards() {
  let uilist = [], ch;
  for (let i = 0; i < 10; i++) {
    if (coin()) {
      let card = Card52.getItem();
      ch = iDiv(card);
      mAppend(dTable, ch);
    } else {
      ch = mDiv(dTable, { w: 76, h: 110, bg: 'random' });
      mClass(ch, 'card');
    }
    uilist.push(ch);
  }
}
function testAddBoard(R) {
  R.initRound();
  reAddServerObject('board');
}
function testAddInfluence(mapController, gObjects) {
  let data = {};
  addIf_dep("map", execOptions.activatedTests);
  data.created = {
    "507565": {
      value: 1,
      nation: "Canada",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 507565
    },
    "531772": {
      value: 2,
      nation: "Ireland",
      faction: "West",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531772
    },
    "531773": {
      value: 3,
      nation: "Portugal",
      faction: "USSR",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531773
    },
    "531774": {
      value: 2,
      nation: "Norway",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531774
    },
    "531775": {
      value: 4,
      nation: "Latin_America",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531775
    }
  };
  mapController.update(data, gObjects);
}
function testAddLocObject(R) {
  R.initRound();
  let oidLoc = getRandomExistingObjectWithRep(R);
  let oid = getUID('o');
  let o = { name: 'felix' + oid, loc: oidLoc };
  addServerObject(oid, o, R);
}
function testAddObject(R) {
  R.initRound();
  let oid = getUID('o');
  let o = { obj_type: 'card' };
  o.short_name = chooseRandom(['K', 'Q', 'J', 'A', 2, 3, 4, 5, 6, 7, 8]);
  addServerObject(oid, o, R);
}
function testAddOidKey(R) {
  console.log(R.instantiable)
  let n = lastCond(R.instantiable, x => !lookup(R.rNodesOidKey, [x.oid, x.key]));
  if (!n) {
    console.log('all nodes are instantiated!!!');
    return;
  }
  let [oid, key] = [n.oid, n.key];
  let o = R.getO(oid);
  if (!o) {
    console.log('no object with oid', oid, 'found!!!');
    return;
  }
  if (o.loc) addOidByLocProperty(oid, key, R); else addOidByParentKeyLocation(oid, key, R);
  updateOutput(R);
}
function testAndSave() {
  sendRoute('/loadYML/icons', d => {
    console.log(d);
    let dictFont = JSON.parse(d);
    console.log(dictFont);
    let newDictFont = {};
    for (const key in dictFont) {
      newDictFont[key] = dictFont[key].unicode;
    }
    let json_str = JSON.stringify(newDictFont);
    saveFile("yourfilename.json", "data:application/json", new Blob([json_str], { type: "" }));
    console.log('DONE!')
  })
}
function testAndSave2() {
  let newDictFont = {};
  for (const key in faIcons) {
    newDictFont[key] = faIcons[key][3];
  }
  let json_str = JSON.stringify(newDictFont);
  saveFile("yourfilename.json", "data:application/json", new Blob([json_str], { type: "" }));
  console.log('DONE!')
}
function testanim0() {
  let [fen, phase, stage, deck, market] = [Z.fen, Z.phase, Z.stage, Z.deck, Z.market];
  let ms = 400;
  let item = deck.topmost;
  mAnimate(iDiv(item), 'transform', [`scale(1,1)`, `scale(0,1)`],
    () => {
      if (item.faceUp) face_down(item); else face_up(item);
      mAnimate(iDiv(item), 'transform', [`scale(0,1)`, `scale(1,1)`], null,
        ms / 2, 'ease-in', 0, 'both');
    }, ms / 2, 'ease-out', 100, 'both');
}
function testanim1() {
  let [fen, phase, deck, market] = [Z.fen, Z.phase, Z.deck, Z.market];
  DA.qanim = [];
  let n_market = phase == 'jack' ? 3 : 2;
  fen.stage = Z.stage = phase == 'jack' ? 12 : phase == 'queen' ? 11 : 4;
  for (let i = 0; i < n_market; i++) {
    DA.qanim = DA.qanim.concat([
      [qanim_flip_topmost, [deck]],
      [qanim_move_topmost, [deck, market]],
      [q_move_topmost, [deck, market]],
    ]);
  }
  DA.qanim.push([q_mirror_fen, ['deck', 'market']]);
  DA.qanim.push([ari_pre_action, []]);
  qanim();
}
function testBirdCards() {
  let keys = SymKeys.filter(x => Syms[x].family != 'emoNoto');
  console.log('groups', ByGroupSubgroup);
  console.log('keySets', KeySets);
  keys = KeySets['animal-bird'];
  for (let i = 0; i < 40; i++) {
    let k = chooseRandom(keys);
    console.log('k', k);
    let card = Karte.get(k, 300);
    mAppend(dTable, iDiv(card));
  }
}
function testbuttons_off() {
  let buttons = arrChildren(mBy('dTestButtons'));
  for (const b of arrFromIndex(buttons, 1)) {
    mClass(b, 'disabled');
    mClassRemove(b, 'enabled');
  }
  mBy('b_delete_table').innerHTML = 'delete most recent table';
}
function testbuttons_on() {
  let buttons = arrChildren(mBy('dTestButtons'));
  for (const b of arrFromIndex(buttons, 1)) {
    mClassRemove(b, 'disabled');
    mClass(b, 'enabled');
  }
  mBy('b_delete_table').innerHTML = 'delete current table';
}
async function testCard() {
  let sdata = genServerDataCards();
  console.log('sdata', sdata)
  let spec = {
    ROOT: { cond: 'all', data: '.short_name' }
  };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testCard52Cards() {
  for (let i = 0; i < 20; i++) {
    let card = Card52.random();
    mAppend(dTable, iDiv(card));
  }
}
function testCardContent0(card) {
  let dCard = iDiv(card);
  mRows(dCard, spotItPattern(5, 2), { sz: Card.sz / 6, fg: 'random', hmargin: 8, vmargin: 4 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
  mRows(dCard, spotItPattern(5, 2), { sz: Card.sz / 8, fg: 'random', margin: 6 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
  mRows(dCard, cardPattern(13, 'spade suit'), { sz: Card.sz / 8, fg: 'random', margin: 6 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
  mRows(dCard, [['frog', 'frog', 'frog'], ['frog', 'frog'], ['frog', 'frog', 'frog']], { sz: Card.sz / 6, fg: 'random' }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
  mRows(dCard, [['frog', 'frog', 'frog'], ['frog', 'frog'], ['frog', 'frog', 'frog']], { sz: Card.sz / 5, fg: 'random' }, { 'justify-content': 'center' }, { 'justify-content': 'space-evenly' }); return;
  mSym('frog', dCard, {}, 'cc'); return;
  mRows(iDiv(card), [[['frog', 3], 'HALLO', 'bee'], ['frog', 'HALLO', 'bee'], ['frog', 'HALLO', 4, 'bee'], 'ja das ist es!']);
  return;
  let d = iDiv(dCard, { display: 'flex', dir: 'column', h: '100%', 'justify-content': 'center' }, 'dOuter');
  return;
  for (const arr of rows) {
    let dCol = mDiv(d, { display: 'flex', 'justify-content': 'space-between', 'align-items': 'center' });
    for (const c of arr) {
      let dc;
      if (isdef(Syms[c])) {
        dc = mDiv(dCol, { fg: 'black' });
        ds = mSym(dc, dCol, { sz: Card.sz / 5, fg: 'random' });
      } else {
        dc = mDiv(dCol, { fg: 'black' }, null, c);
      }
    }
  }
}
async function testCardDraw52() {
  let d = mBy('table');
  let ui = cardFace({ rank: 'K' }, 70, 110);
  mAppend(d, ui);
}
async function testCardHorizontal() {
  let sdata = genServerDataCards();
  let spec = {
    ROOT: { _NODE: 'cards', params: { orientation: 'h' } },
    cards: { cond: 'all', data: '.short_name' }
  };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
async function testCardHorizontal2() {
  let sdata = genServerDataCards();
  let spec = {
    ROOT: { type: 'panel', _NODE: 'cards' },
    cards: { cond: 'all', data: '.short_name' }
  };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testCards() {
  initRSGData(); hideLobby(); hideLogin(); showGame(); initDom();
  testPlayerHand1();
}
function testCardsGridOverlap() {
  dTable = stdGridContainer(dMiddle);
  testAdd10Cards();
}
function testCardsNoOverlap() {
  dTable = stdContainerRowWrap(dMiddle);
  testAdd10Cards();
}
async function testCardsUni(n, spec, cardGenerator = genServerDataCards) {
  let sdata = cardGenerator(n);
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
async function testCatan(r, c) {
  let sdata = genServerDataCatan(r, c);
  let spec = { ROOT: { cond: { obj_type: 'Board' }, type: 'grid', data: '.uid' } };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testCenteredNode() {
  let dTable = mBy('table');
  let d = mDiv(dTable);
  mSize(d, 100, 100);
  mColor(d, 'blue');
  let d1 = mNode({ a: 'HALLO', b: 'geh' }, d);
  mCenterH(d1);
}
function testColarrVersions() {
  let tests = [[2, 2], [3, 2], [4, 2], [5, 2], [6, 2], [6, 3]];
  for (let i = 0; i < 50; i++) {
    let [rows, cols] = [randomNumber(1, 10), randomNumber(1, 10)];
    let carr1 = _calc_hex_col_array(rows, cols);
    let carr2 = _calc_hex_col_arrayNew(rows, cols);
    let even = (rows % 2) == 0;
    console.log('rows', rows, (even ? 'even' : 'odd'), 'cols', cols, '\nold', carr1, '\nnew', carr2);
    console.assert(even || sameList(carr1, carr2), 'FEHLER!!!!!!!!!!!!!!!!!!');
  }
}
async function testCommonKeys() {
  initRSGData(); showGame(); initDom();
  let gaIcons = await route_rsg_asset('gameIconCodes');
  let faIcons = await route_rsg_asset('faIconCodes');
  let smallIcons = await route_rsg_asset('iconTest');
  faKeys = [];
  for (const k in gaIcons) {
    if (isdef(faIcons[k])) faKeys.push(k);
  }
  console.log('common keys:', faKeys);
  let board = makeDrawingArea('board', 'a_d_game', true);
  setAreaWidth('a_d_game', 1400);
  setAreaHeight('a_d_game', 1000);
  let keys = faKeys;
  let xStart = -600;
  let yStart = -400;
  let y = yStart;
  let x = xStart;
  for (const k of keys) {
    addPictoFromChar('board', gaIcons[k], 50, x, y);
    if (y > -yStart) { y = yStart; x += 60; } else y += 60;
  }
  y = yStart; x += 60;
  for (const k of keys) {
    addPictoFromChar('board', faIcons[k], 50, x, y);
    if (y > -yStart) { y = yStart; x += 60; } else y += 60;
  }
}
function testComposeShapesAndResize() {
  let g = gCanvas('table', 400, 300, 'skyblue');
  testResizeHex(g);
}
function testControlFlow(player = "USSR", filename = "", seed = 4) {
  execOptions.output = "none";
  addIf_dep("control", execOptions.activatedTests);
  if (empty(filename)) {
    sendInit(player, gameloop, seed);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testCreateDivWithDivFixedSize() {
  let d = mBy('table');
  clearElement(d);
  d.style.position = 'relative';
  let root = mDiv(d);
  root.style.position = 'relative';
  root.style.width = '200px';
  root.style.height = '100px';
  let ch = mDiv(root);
  ch.style.position = 'absolute';
  ch.style.left = '20px';
  ch.style.top = '10px';
  ch.style.width = '30px';
  ch.style.height = '60px';
  ch.style.backgroundColor = 'blue';
  root.style.backgroundColor = 'red';
}
function testCreateMultipleUnitsOnSameTile() {
  execOptions.output = "none";
  addIf_dep("units", execOptions.activatedTests);
  let data = generateUnitList();
  let player = "West";
  for (const id in data.created) {
    const o = data.created[id];
    o.tile = "London";
    o.nationality = "Britain";
    units.createUnit(id, o, player);
  }
  player = "USSR";
  for (const id in data.created) {
    let idNew = id + 200;
    const o = data.created[id];
    o.tile = "Berlin";
    o.nationality = "Germany";
    o._id = idNew;
    units.createUnit(idNew, o, player);
  }
}
function testCreateNCards() {
  let cman = new ACards(assets);
  let n = 20;
  for (let i = 0; i < n; i++) {
    let c = generateCard();
    cman.createCard(c.id, c.o);
  }
}
function testCreateOneCard() {
  let c = generateCard();
  let cman = new ACards(assets);
  cman.createCard(c.id, c.o);
}
function testCreateSingleUnit() {
  execOptions.output = "none";
  addIf_dep("units", execOptions.activatedTests);
  let data = generateUnitList();
  let player = "West";
  for (const id in data.created) {
    const o = data.created[id];
    units.createUnit(id, o, player);
    break;
  }
}
function testDeactivate(R) {
  deactivateUis(R);
}
function testDeal2() {
  deck.mount(d);
  bDeal.addEventListener('click', function () { deck.pokerN(1); });
  makeTestButton('deal2', () => deck.pokerN(2), topbar1);
}
function testDec() {
  let x = hexStringToDecimal('F');
  console.log('x', x);
  console.log('x', hexStringToDecimal('FFFF'));
  console.log('x', hexStringToDecimal('1A'));
  console.log('x', hexStringToDecimal('1F499'));
  console.log('x', hexStringToDecimal('1F981'));
}
async function testDirList() {
  let x = await (await fetch('/RSG/js')).text();
  while (!isEmpty(x)) {
    word = stringBefore(x, '"');
    console.log('______________word:', word);
    x = stringAfter(x, '<a href="/');
  }
  return;
  var regexp = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/i;
  var match, files = [];
  let max = 5;
  while ((match = regexp.exec(x)) != null) {
    files.push(match.index);
    max -= 1; if (max <= 0) break;
  }
  console.log('________________', files);
  return;
  var request = new XMLHttpRequest();
  request.open('GET', '/RSG/', true);
  let resp;
  request.onload = function () {
    if (request.status >= 200 && request.status < 400) {
      resp = request.responseText;
    }
  };
  request.send();
  let directory_listing = resp;
  var regexp = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/i;
  var match, files = [];
  while ((match = regexp.exec(resp)) != null) {
    files.push(match.index);
  }
  console.log(files);
}
async function testDocumentFile() {
  let akku = await documentFile('/RSG/js/done/docs/docfile.js');
  let keys = Object.keys(akku);
  keys.sort();
  keys.map(x => console.log('signature:', x, '\ncomment block:\n', akku[x]));
}
async function testDocumentVault() {
  let vault = [
    "/RSG/js/R/binding.js",
    "/RSG/js/R/rsgTypes.js",
    "/RSG/js/testing/engine.js",
    "/RSG/js/testing/onClick.js",
    "/RSG/js/testing/SimpleGrid.js",
    "/RSG/js/testing/testBoard.js",
    "/RSG/js/testing/testCards.js",
    "/RSG/js/testing/testFactory.js",
    "/RSG/js/testing/testData.js",
    "/RSG/js/testing/testing.js",
    "/RSG/js/done/activator.js",
    "/C/assets.js",
    "/RSG/js/done/index.js",
    "/RSG/js/done/utils.js",
  ];
  console.log(res);
}
function testEdit(origData, player = "USSR", filename = "test1", seed = 0) {
  execOptions.output = "none";
  sendInit(player, d1 => {
    freezeUI();
    let tuples = getTuples(d1);
    sendEditAction(player, ["France", "Vienna", "Fleet"], d2 => {
      gameloop(origData);
    });
  });
}
function testEditAddRandomUnit() {
  let tuple = randomUnitTuple();
}
function testEditModeCreateUnit() {
  player = "USSR";
  sendLoading("setup_complete", player, dInit => {
    sender.send("edit/" + player + "/USSR+Moscow+Infantry", dEdit => {
      let newUnit = Object.values(dEdit.created)[0];
      let newId = Object.keys(dEdit.created)[0];
      dInit.created[newId] = newUnit;
      gameloop(dInit);
    });
  });
}
function testEditModeCreateUnit_trial1() {
  sendInit(player, dInit => {
    gameloop(dInit);
  });
}
async function testFaKeysNotInGa() {
  initRSGData(); showGame(); initDom();
  let gaIcons = await route_rsg_asset('gameIconCodes');
  let faIcons = await route_rsg_asset('faIconCodes');
  let smallIcons = await route_rsg_asset('iconTest');
  faKeys = [];
  for (const k in faIcons) {
    if (nundef(gaIcons[k])) faKeys.push(k);
  }
  console.log('common keys:', faKeys);
  let board = makeDrawingArea('board', 'a_d_game', true);
  setAreaWidth('a_d_game', 2400);
  setAreaHeight('a_d_game', 1500);
  let keys = faKeys;
  let xStart = -1100;
  let yStart = -670;
  let y = yStart;
  let x = xStart;
  for (const k of keys) {
    addPictoFromChar('board', faIcons[k], 50, x, y);
    if (y > -yStart) { y = yStart; x += 60; } else y += 60;
  }
}
async function testFetchCsvAsTextAndSearch() {
  timit = new TimeIt('*timer', TIMIT_SHOW);
  await loadAssets();
  timit.show();
  mEmo('blue heart', 'table', 100);
  mFlexLinebreak('table');
  for (const k of ['cat', 'lion', 'tiger', 'leopard', 'horse', 'zebra', 'deer', 'ox', 'cow']) {
    let emo = mEmo(k, 'table', 50);
  }
}
function testFindKeys() { }
async function testGeneralBoard(r, c, shape, hasNodes, hasEdges, { mapVariant, fieldContent, nodeContent, edgeContent } = {}) {
  let sdata = genServerDataGeneralBoard(r, c, shape, hasNodes, hasEdges, { mapVariant, fieldContent, nodeContent, edgeContent });
  console.log('sdata', sdata)
  let spec = {
    ROOT: { cond: { obj_type: 'Board' }, type: 'grid' }
  };
  if (isdef(fieldContent)) {
    spec.fields = { cond: { obj_type: 'Field' }, data: '.content' };
  }
  if (isdef(nodeContent)) {
    spec.nodes = { cond: { obj_type: 'Corner' }, data: '.content' };
  }
  if (isdef(edgeContent)) {
    spec.edges = { cond: { obj_type: 'Edge' }, data: '.content' };
  }
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testGetElements() {
  let x = getElements([0, 1, 2]);
  console.log('x', x);
  x = getElements([[3, 2], [0, 1, 2]]);
  console.log('x', x);
}
function testGSM() {
  if (activatedTests.includes('GSM')) {
    console.log(...arguments);
  }
}
function testHelpers() {
  if (activatedTests.includes('helpers')) {
    console.log(...arguments);
  }
}
function testHexgrid() {
  if (activatedTests.includes('hexgrid')) {
    console.log(...arguments);
  }
}
function testIndenting() {
  let spc = '&nbsp;';
  let d = mDiv(mBy('table'));
  mSize(d, 200, 200);
  mColor(d, 'orange');
  let s = `
  hallo
    das ist
     ein
   string
    1
     2
      3`;
  s = s.replace('\t', '  ');
  let startLine = true;
  let lines = s.split('\n');
  let lineInfo = {};
  let html = '';
  for (let i = 0; i < lines.length; i += 1) {
    let line = lines[i];
    let n = countIndent(line, 4);
    console.log('_____________n=' + n, line);
    let x = spc.repeat(n) + line;
    html += x + '<br>';
    console.log(x)
  }
  let d1 = mText(html, d)
}
function TESTING_bar(fileName = getCurrentFileName(), myFunctionName = getFunctionsNameThatCalledThisFunction()) { }
function TESTING_foo() {
  TESTING_bar();
}
function testingMS() {
  if (isdef(IdOwner.t)) IdOwner.t.map(x => addTestInteraction1(x));
}
function testInitToEnd(player = "USSR", seed = 0) {
  hide(bStop);
  sendInit(player, d => testRunToEnd(d, player), seed);
}
function testInno() { }
function testInnoCardPhantasie() {
  dTable = mDiv(mBy('wrapper'), { position: 'absolute', padding: 10, w: '100vw', h: '100vh', bg: 'white' });
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { fg: 'black', bg: INNO.color.red, w: Card.sz, h: Card.sz * .65 });
  let [dCard, sz, szTitle, gap] = [iDiv(card), Card.sz / 4, 24, 8];
  let [dTitle, dMain] = cTitleArea(card, 32);
  let d = mAddContent(dTitle, 'MetalWorking', { bg: INNO.sym.tower.bg, fg: 'white', h: 32, fz: 23, align: 'center', position: 'relative' });
  mAddContent(d, '5', { float: 'right', hpadding: 10 });
  let s = mSym(INNO.sym.tower.key, d, { h: 22, fg: INNO.sym.tower.fg }, 'cl');
  let margin = 20;
  innoSym('leaf', dMain, sz, 'tl', margin);
  innoSym('crown', dMain, sz, 'bl', margin);
  innoSym('leaf', dMain, sz, 'bc', margin);
  innoSym('leaf', dMain, sz, 'br', margin);
  let box = mBoxFromMargins(dMain, 0, margin, sz + margin, sz + margin);
  let text = 'I demand if you get [tower] or [crown], immediately switch to age [2]. aber ich hab ja gott sei dank zeit! denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  let t2 = innoText(text);
  mFillText(t2, box);
  return;
  box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'tl');
  s = mSym('white-tower', box, { sz: sz * .75, fg: 'silver' }, 'cc');
  box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'bl');
  s = mSym('frog', box, { sz: sz * .75, fg: 'silver' }, 'cc');
  box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'bc');
  s = mSym('maple-leaf', box, { sz: sz * .75, fg: 'silver' }, 'cc');
  box = mDiv(dMain, { w: sz, h: sz, bg: 'grey', alpha: .5, rounding: 10 }); mPlace(box, 'br');
  text = 'denn wenn es nicht geht und ich bin muede dann halt nicht!';
  mFillText(text, box);
  box = mBoxFromMargins(dMain, 4, 4, sz + 8, sz + 10);
  text = 'das muss jetzt ein viel laenderer text sein. aber ich hab ja gott sei dank zeit! denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  mFillText(text, box);
  return;
  text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  box = mPlaceText(text, [szTitle, 10, sz + gap, sz + gap], d, { fg: 'dimgrey' }, { bg: 'beige', border: '1px solid grey', rounding: 10 });
  text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  box = mPlaceText(text, [sz, sz, 'bl'], d, { fg: 'dimgrey', bg: 'pink', rounding: 10, border: '5px solid pink' });
  let x1 = mSym('crow', d, { w: sz, h: sz, fg: 'green' }, 'br');
  x1 = mSym('abacus', d, { w: sz, h: sz }, 'bc');
  box = mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue', bg: 'orange', rounding: 10 });
}
function testInnoMain() {
  mStyle(dTable, { gap: 10, pabottom: 150 });
  for (const k in Cinno) {
    if (isdef(Cinno[k].expansion)) cardInno(dTable, k);
  }
}
function testIntegrationCards(filename = "prod_complete", player = "Axis") {
  execOptions.output = "none";
  addIf_dep("cards", execOptions.activatedTests);
  if (empty(filename)) {
    sendInit(player, gameloop, 0);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testIntegrationMap(filename = "prod_complete", player = "Axis") {
  execOptions.output = "none";
  addIf_dep("map", execOptions.activatedTests);
  if (empty(filename)) {
    sendInit(player, gameloop, 0);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testIntegrationUnits(filename = "", player = "USSR", seed = 4) {
  execOptions.output = "none";
  addIf_dep("units", execOptions.activatedTests);
  if (empty(filename)) {
    sendInit(player, gameloop, seed);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testjourney0() {
  let [fen, uname] = [Z.fen, Z.uname];
  let plist = find_players_with_potential_journey(fen);
  console.log('journey players', plist);
  if (!plist.includes(uname)) {
    set_nextplayer_after_journey();
    console.log('Z.turn', Z.turn)
    take_turn_fen();
  }
}
function testJustARect() {
  let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults({ bg: 'green' }).attach();
  let rect = new MMS({ parent: svg, type: 'rect' }).setDefaults({ w: 50, h: 50, bg: 'red' }).attach();
}
function testKarte0() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz;
  let suit = mSuit('Pik', d, { h: 300 });
  let p = suit.firstChild;
  console.log('p', p);
  console.log('child', p.firstChild);
}
function testKarte1() {
  let card = cLandscape(dTable);
  let sz = card.sz;
  console.log('sz', sz)
  let d = iDiv(card);
  let x = mShape('triangle', d, { bg: 'blue', w: sz / 4, h: sz / 4, position: 'absolute', top: 10, left: 10 });
  x = mShape('test1', d, { bg: 'red', w: sz / 4, h: sz / 4, position: 'absolute', bottom: 10, left: 10 });
  x = mSym('bee', d, { fz: sz / 5, position: 'absolute', bottom: 10, right: 10 });
  x = mDiv(d, { bg: YELLOW, w: sz / 4, h: sz / 4, position: 'absolute', top: 10, right: 10 }, null, null, 'triangle');
  let text = 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!';
  let [fz, w, h] = fitFont(text, 20, sz, sz / 2);
  let pos = { left: (card.w - w) / 2, top: (card.h - h) / 2 }
  x = mDiv(d, { align: 'left', fz: fz, fg: 'black', w: w, h: h, top: pos.top, left: pos.left, display: 'inline-block', position: 'absolute' }, null, text);
  console.log('x', x)
  let sh0 = [
    `<div class="triangle"></div>`,
    `<div class="triangle type2" style="--b:linear-gradient(red,blue);"></div>`,
    `<div class="triangle type3" style="--b:conic-gradient(green,pink,green);"></div>`,
    `<div class="triangle hex" style="--b:url(https://picsum.photos/id/1067/200/200) center/cover;"></div>`,
    `<div class="triangle hex" style="--b:url(../assets/images/felix.jpg) center/cover;"></div>`,
  ];
  let sh = [
    `<div class="weired"></div>`,
    `<div class="weired" style="--b:linear-gradient(red,blue);"></div>`,
    `<div class="weired" style=
    "--b:conic-gradient(green,pink,green);
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`,
  ];
  for (const sh1 of sh) {
    x = createElementFromHtml(sh1);
    mStyle(x, { w: 80 });
    mAppend(dTable, x);
  }
  return;
  let styles = { margin: 10, bg: 'random' };
  for (let i = 0; i < 3; i++) { let d = mShape('triangle', dTable); console.log('d', d); }
}
function testKarte2() {
  let card = cLandscape(dTable);
  let isLandscape = card.w > card.h;
  let sz = card.sz;
  console.log('sz', sz)
  let text = 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!';
  let d = iDiv(card);
  let sh = [
    { type: 'html', pos: 'TL', sz: 's', content: `<div class="weired"></div>` },
    { type: 'html', pos: 'TR', sz: 's', content: `<div class="weired" style="--b:linear-gradient(red,blue);"></div>` },
    {
      type: 'html', pos: 'BL', sz: 's', content: `<div class="weired" style=
    "--b:conic-gradient(green,pink,green);
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`},
    {
      type: 'html', pos: 'BR', sz: 's', content: `<div class="weired" style=
    "--b:url(../assets/images/felix.jpg) center/cover;
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`},
    { type: 'text', pos: 'CC', sz: 'l', content: 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!' },
  ];
  var SZ = sz;
  var GAP = SZ * .1;
  var SIZE = { xs: SZ / 8, s: SZ / 4, m: SZ / 2, l: SZ * 2 / 3, xl: SZ };
  var POS = { TL: { top: GAP, left: GAP }, TR: { top: GAP, right: GAP }, BL: { bottom: GAP, right: GAP }, BR: { bottom: GAP, right: GAP } };
  for (const sh1 of sh) {
    let t = sh1.content;
    x = isString(t) ? t[0] == '<' ? createElementFromHtml(t) : makeText(t, sz, sz / 2) : t;
    mAppend(d, x);
    let pos = sh1.pos;
    if (pos != 'CC') {
      mStyle(x, { w: 80 });
      window['mPos' + sh1.pos](x, 10);
    }
  }
}
function testKarte3_svg() {
  mStyle(dTable, { gap: 10 }); let card;
  card = cBlankSvg(dTable);
  console.log('card', card);
  let g = iG(card); console.log('g', g);
  let x = mgSuit('Pik'); console.log('x', x);
  mgSize(x, Card.sz / 2);
  mgPos(card, x);
}
function testKarte4() {
  mStyle(dTable, { gap: 10 }); let card;
  card = cBlank(dTable);
  let d = iDiv(card);
  let sz = Card.sz;
  let arr = [];
  let suit = mSuit('Pik');
  let triangle = mShape('triangle', null, { bg: 'red' });
  let sym = mSym('frog');
  let shape = mShape('test1');
  let x = mShapeX98(); console.log('\nx', x); mAppend(d, x);
  return;
  let h = sz / 4;
  suit.setAttribute('height', h);
  mStyle(sym, { fz: h * .75 });
  mSize(shape, h * .75);
  mSize(triangle, h * .75);
  arr = [triangle, suit, sym, shape, x];
  console.log('\nx', x);
  mAppend(d, x); return;
  for (const x of arr) { mAppend(d, x); }
  gSizeToContent(suit);
}
function testKarte5() {
  for (let i = 0; i < 10; i++) {
    let n = i * 15;
    let x = mShapeR(); console.log('\nx', x);
    mStyle(x, { w: n }); mClassReplace(x, 'weired' + (n > 120 ? 8 : n > 80 ? 5 : n > 50 ? 3 : 1));
    mAppend(dTable, x);
  }
}
function testKarte6() {
  for (let i = 0; i < 10; i++) {
    let n = i * 15;
    let x = mShapeR('triup', dTable, { sz: n, bg: 'random' }); console.log('\nx', x); mAppend(dTable, x);
  }
}
function testKarte8() {
  for (let i = 0; i < 1; i++) {
    testKarte7();
  }
}
function testKartePosition1() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 4;
  let s3 = mSuit('Pik', d); mSuitSize(s3, 30); mSuitTL(s3); console.log('s3', s3);
  let s4 = mSuit('Treff', d); mSuitSize(s4, 30); mSuitPos(s4, 'bottom', 'right'); console.log('s4', s4);
  let s5 = mSuit('Herz', d, { sz: 30 }); mSuitPos(s5, 'bottom', 'left'); console.log('s5', s5);
  let s6 = mSuit('Karo', d, { sz: 30 }); mSuitPos(s6, 'top', 'right'); console.log('s6', s6);
  return;
  console.log('suit', suit);
  mPos(suit, 0, 0);
  mPos(suit1, -10, Card.h - sz);
  mPos(suit1, -10 * sz / 100, Card.h - sz);
}
function testKartePosition2() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 4;
  let s1 = mSuit('Pik', d, { sz: 25 }, 'tl'); console.log('s1', s1);
  let s2 = mSuit('Karo', d, { sz: 50 }, 'tr'); console.log('s2', s2);
  let s3 = mSuit('Herz', d, { sz: 75 }, 'bl'); console.log('s3', s3);
  let s4 = mSuit('Treff', d, { sz: 100 }, 'br'); console.log('s4', s4);
}
function testKartePositionSuit() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 6;
  let s1 = mSuit('Herz', d, { sz: sz }, 'tc');
  let s2 = mSuit('Herz', d, { sz: sz }, 'cr');
  let s3 = mSuit('Herz', d, { sz: sz }, 'bc');
  let s4 = mSuit('Herz', d, { sz: sz }, 'cl');
  let s5 = mSuit('Pik', d, { sz: sz * 2 }, 'cc');
  s5 = mSuit('Treff', d, { sz: sz * 1.5 }, 'tl');
  s5 = mSuit('Treff', d, { sz: sz * 1.5 }, 'tr');
  s5 = mSuit('Treff', d, { sz: sz * 1.5 }, 'bl');
  s5 = mSuit('Treff', d, { sz: sz * 1.5 }, 'br');
}
function testKartePositionSuitOuterCenters() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 4;
  let s1 = mSuit('Pik', d, { sz: 60 }, 'tc'); console.log('s1', s1);
  let s2 = mSuit('Karo', d, { sz: 60 }, 'cr'); console.log('s2', s2);
  let s3 = mSuit('Herz', d, { sz: 60 }, 'bc'); console.log('s3', s3);
  let s4 = mSuit('Treff', d, { sz: 60 }, 'cl'); console.log('s4', s4);
}
function testKarteSizing() {
  mStyle(dTable, { gap: 10 }); let card;
  card = cBlank(dTable);
  let d = iDiv(card);
  let sz = Card.sz;
  let arr = [];
  let suit = mSuit('Pik');
  let triangle = mShape('triangle', null, { bg: 'red' });
  let sym = mSym('frog');
  let shape = mShape('test1');
  let x = mShapeR();
  let h = sz / 4;
  suit.setAttribute('height', h);
  mStyle(sym, { fz: h * .75 });
  mSize(shape, h * .75);
  mSize(triangle, h * .75);
  mStyle(x, { w: h * .75 }); mClassReplace(x, 'weired1');
  arr = [triangle, suit, sym, shape, x];
  for (const x of arr) { mAppend(d, x); }
  gSizeToContent(suit);
}
function testKnight() {
  let c = makeCard(0, 'hallo');
  c.mount(d);
  c.setSide('front');
  blank(c);
  setTitle(c, 'Knight')
  setText(c, 'You can play this card whenever you want to move the robber!')
  moveTo(c, -100, -100);
}
function testLines() {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let mobj = makeDrawingElement('el1', 'board');
  mobj.line({ thickness: 10, cap: 'round' }).setBg('red').attach();
  console.log(mobj)
  console.log(mobj.elem)
  let [x1, y1, x2, y2] = mobj.getEndPointsOfLineSegmentOfLength(40);
  let ms2 = makeDrawingElement('el2', 'board');
  ms2.line({ thickness: 15, x1: x1, y1: y1, x2: x2, y2: y2 }).setBg('blue').attach();
  [x1, y1, x2, y2] = mobj.getEndPointsOfLineSegmentOfLength(120);
  let ms3 = makeDrawingElement('el3', 'board');
  ms3.line({ thickness: 5, x1: x1, y1: y1, x2: x2, y2: y2 }).setBg('green').attach();
}
function testLoadSpring(filename = "spring_start", player = "Axis") {
  execOptions.output = "none";
  if (empty(filename)) {
    sendInit(player, gameloop, 5);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testLoadToEnd(player = "Axis", filename = "setup_complete") {
  hide(bStop);
  sendLoading(filename, player, d => testRunToEnd(d, player), "raw");
}
function testLookupRemoveFromList() {
  let d = { a: { b: [2] } };
  let res = lookupRemoveFromList(d, ['a', 'b'], 2);
  console.log('res', res, 'd', d);
  d = { a: { b: [2] } };
  res = lookupRemoveFromList(d, ['a', 'b'], 2, true);
  console.log('res', res, 'd', d);
  d = { a: { b: [2, 3] } };
  res = lookupRemoveFromList(d, ['a', 'b'], 3, true);
  console.log('res', res, 'd', d);
  d = { a: [0, [2], { b: [] }] };
  res = lookupRemoveFromList(d, ['a', 1], 2);
  console.log('res', res, 'd', d);
}
function testMakeACanvas() {
  let dParent = mBy('table');
  let div = stage3_prepContainer(dParent);
  div.style.width = 400 + 'px';
  div.style.height = 300 + 'px';
  mColor(div, 'orange');
  let svg = gSvg();
  let style = `margin:0;padding:0;position:absolute;top:0px;left:0px;width:100%;height:100%;`
  svg.setAttribute('style', style);
  mColor(svg, 'green');
  div.appendChild(svg);
  let g = gG();
  g.style.transform = "translate(50%, 50%)";
  gBg(g, 'blue');
  svg.appendChild(g);
  return g;
}
function testMakeAreas(dParent) {
  let dGrid = mDiv(dParent, { gap: 10, bg: 'white', w: '90%', padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
  let layout = ['T', 'H A'];
  let x = createGridLayout(dGrid, layout);
  let areaStyles = { bg: 'green', hmin: 200, rounding: 6 };
  let contentStyles = { lowerRounding: 6 };
  let messageStyles = { fg: 'yellow' };
  let titleStyles = { bg: 'dimgray', family: 'AlgerianRegular', upperRounding: 6 };
  let areas = {
    T: { title: 'table', id: 'dTrick', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: true },
    H: { title: 'YOU', id: 'dHuman', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
    A: { title: 'opponent', id: 'dAI', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
  };
  let items = [];
  for (const k in areas) {
    let item = areas[k];
    item.areaStyles['grid-area'] = k;
    let dCell = mTitledMessageDiv(item.title, dGrid, item.id, item.areaStyles, item.contentStyles, item.titleStyles, item.messageStyles, item.titleOnTop)
    iRegister(item, item.id);
    if (item.titleOnTop) iAdd(item, { div: dCell, dTitle: dCell.children[0], dMessage: dCell.children[1], dContent: dCell.children[2] });
    else iAdd(item, { div: dCell, dTitle: dCell.children[2], dMessage: dCell.children[0], dContent: dCell.children[1] });
    mCenterCenterFlex(diContent(item));
    mStyle(diContent(item), { gap: 10 });
    items.push(item);
  }
  return items;
}
function testManualCircleOnG() {
  let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults({ bg: 'green' }).attach();
  let g = new MMS({ parent: svg, type: 'g' }).setDefaults({ bg: 'blue' }).attach();
  let circle = new MMS({ parent: g, type: 'ellipse' }).attach();
  let r = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
  r.setAttribute('rx', 35);
  r.setAttribute('ry', 45);
  r.setAttribute('cx', 0);
  r.setAttribute('cy', 0);
  r.setAttribute('fill', 'yellow');
  g.elem.appendChild(r);
}
function testMovement(filename = "test_movement", player = "Axis") {
  execOptions.output = "none";
  if (empty(filename)) {
    sendInit(player, gameloop, 5);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testMS_fine() {
  if (activatedTests.includes('MS_fine')) {
    console.log(...arguments);
  }
}
function testMuell0() {
  dTable = makePage();
  mStyle(dTable, { display: 'flex', })
  let dGrid = mDiv(dTable, { wmin: 110, hmin: 70, bg: 'white', padding: 3, rounding: 6 });
  let d = mTitledMessageDiv('title', dGrid, 'id1',
    { bg: 'green', rounding: 6 },
    { lowerRounding: 6 },
    { bg: 'dimgray', align: 'center', 'line-height': 30, family: 'AlgerianRegular', upperRounding: 6 },
    { fg: 'yellow', padding: 10 },
    true);
}
function testMultiline() {
  let d = mDiv(mBy('table'));
  mSize(d, 200, 200);
  mColor(d, 'orange');
  let s = ' hallo\n\tdas\n   ist\n\t\tda';
  let dMulti = mMultiline(s, 2, d);
}
function testNewMSAPI() {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let mobj = makeDrawingElement('el1', 'board');
  _makeGroundShape(mobj, 0, 25, 100, 100, 'blue', 'quad', { scaleY: 2, rot: 45 });
  mobj.attach();
  console.log(mobj)
}
function testObjectWithUiAndClasses() {
  let n = { uid: '_1' };
  let d = mCenteredNode({ a: 'HALLO', b: 'geh' });
  console.log(d, d.classList);
  mSize(d, 100, 50);
  mAppend(mBy('table'), d);
  mCenterText(d.firstChild);
  mClass(d.firstChild, 'centered')
  n.class = ['centered'];
  console.log('line2', d, d.classList);
  n.ui = d;
  let dDesc = mNodeFilter(n, { dParent: mBy('table'), lstShow: ['uid', 'class'] });
}
function testOutput(o) {
  return;
  for (const key in o) {
    const arg = o[key];
    if (isNumber(key) && key <= execOptions.outputLevel) {
      console.log(H.moveCounter + ':', ...arg);
    }
  }
}
function testPageHeader() {
  pageHeaderClearAll();
  pageHeaderSetGame();
  pageHeaderAddPlayer('username', 'playerId', 'green', true);
}
async function testPicto(n) {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let keys = ['achievement', 'wheat', 'criminal', 'police', 'cop', 'trophy', 'victory', 'plenty', 'fruit', 'bounty', 'house', 'castle', 'building', 'settlement', 'city', 'robber', 'thief', 'street', 'road'];
  let y = -300;
  let x = -300;
  let i = 0;
  timit.showTime('************server');
  iconChars = await vidCache.load('iconChars', route_iconChars);
  timit.showTime('iconChars');
  console.log(iconChars);
  for (const k of keys) {
    addPicto('board', k, 50, x, y);
    if (y > 250) { y = -300; x += 60; } else y += 60;
    i += 1; if (i >= n) break;
  }
}
function testPicto_dep(n) {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let keys = ['achievement', 'wheat', 'criminal', 'police', 'cop', 'trophy', 'victory', 'plenty', 'fruit', 'bounty', 'house', 'castle', 'building', 'settlement', 'city', 'robber', 'thief', 'street', 'road'];
  let y = -300;
  let x = -300;
  let i = 0;
  loadIconChars([() => {
    console.log(iconChars);
    for (const k of keys) {
      addPicto('board', k, 50, x, y);
      if (y > 250) { y = -300; x += 60; } else y += 60;
      i += 1; if (i >= n) break;
    }
  }]);
}
function testPlayerHand1() {
  G.table = cards1;
  G.playersAugmented = {
    White: {
      devcards: { _set: [{ _obj: 'c1' }, { _obj: 'c3' }] }
    }
  };
  _showHand(['c1', 'c2', 'c3'], 'a_d_game');
}
function testPos00() {
  let board = [
    ['bk', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'bn', 'em', 'wr', 'em', 'wp', 'em', 'em'],
    ['br', 'em', 'bp', 'em', 'em', 'bn', 'wn', 'em'],
    ['em', 'em', 'bp', 'bp', 'bp', 'em', 'wp', 'bp'],
    ['bp', 'bp', 'em', 'bp', 'wn', 'em', 'wp', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'wk', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
  ];
  console.log(board_to_fen(board));
}
function testPosition3() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 5;
  let x1 = mShapeR('hex', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
  for (const p of ['tl', 'tc', 'tr', 'cl', 'cc', 'cr', 'bl', 'bc', 'br']) {
    let x2 = x1.cloneNode(); mAppend(d, x2); mPlace(x2, p, 20);
  }
}
function testPositionCardSym() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 5;
  let x1 = mSym('crow', d, { w: sz, h: sz, bg: 'random' }, 'cc'); console.log('\nx1', x1);
}
function testPositionPatterns() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 5;
  let x1 = mShapeR('hex', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
  for (const p of ['tl', 'tc', 'tr', 'cl', 'cc', 'cr', 'bl', 'bc', 'br']) {
    let x2 = x1.cloneNode(); mAppend(d, x2);
    mPlace(x2, p, p.includes('c') ? 0 : 20);
  }
}
function testPositionPatterns1() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 5;
  let x1 = mShapeR('circle', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
  for (const p of ['tl', 'tr', 'bl', 'br']) {
    let x2 = x1.cloneNode(); mAppend(d, x2);
    mPlace(x2, p, 20);
  }
  for (const p of ['tc', 'cl', 'cc', 'cr', 'bc']) {
    let x2 = x1.cloneNode(); mAppend(d, x2);
    mPlace(x2, p);
  }
}
function testPositionShapeR0() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 4;
  let x1 = mShapeR('triup', d, { sz: sz, bg: 'random' }); console.log('\nx1', x1);
  mPlace(x1, 'tl');
  let x2 = mShapeR('hex', d, { sz: sz, bg: 'random' }); console.log('\nx1', x2);
  mPlace(x2, 'tr');
  let x3 = mShapeR('triangle', d, { sz: sz, bg: 'random' }); console.log('\nx1', x3);
  mPlace(x3, 'br');
  let x4 = mShapeR('hexFlat', d, { sz: sz, bg: 'random' }); console.log('\nx1', x4);
  mPlace(x4, 'bl');
}
function testRandomSeries(G, n, callback) {
  sender.send("init/hotseat/Axis/1", dInit => {
    testRandomSeriesRec([], dInit, G, n, callback);
  });
}
function testRandomSeries_sendInit(lst, G, n, callback) {
  sendInit(
    G.player,
    dInit => {
      lst.push();
      testRandomSeriesRec(dInit, G, n - 1, callback);
    },
    G.seed
  );
}
function testRandomSeriesRec(lst, dInit, G, n, callback) {
  sender.send("randint/" + 100, di => {
    let x = di.int;
    lst.push(x);
    if (n > 0) {
      testRandomSeriesRec(lst, dInit, G, n - 1, callback);
    } else {
      callback(dInit);
    }
  });
}
function testRectanglesTextInBoxesW0() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { w: Card.sz, h: Card.sz * .8 });
  let [d, sz, szTitle, gap] = [iDiv(card), Card.sz / 4, 24, 8];
  let box = mBoxFromMargins(d, szTitle, 10, sz + gap, sz + gap);
  let r = mMeasure(box);
  text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  let [fz, w, h] = fitFont(text, 20, r.w, r.h);
  console.log('res', fz, w, h);
  let dText = mDiv(box, {
    w: w, h: h, fz: fz, fg: 'black',
    position: 'absolute', transform: 'translate(-50%,-50%)', top: '50%', left: '50%'
  }, null, text);
  box = mDiv(d, { w: sz, h: sz });
  mPlace(box, 'bl');
  r = mMeasure(box);
  text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  [fz, w, h] = fitFont(text, 20, r.w, r.h);
  console.log('res', fz, w, h);
  dText = mDiv(box, {
    w: w, h: h, fz: fz, fg: 'black',
    position: 'absolute', transform: 'translate(-50%,-50%)', top: '50%', left: '50%'
  }, null, text);
  mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue' }, { bg: 'orange', border: '1px dashed red', rounding: 10 });
}
function testRectanglesW1() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { w: Card.sz, h: Card.sz * .8 });
  let [d, sz, szTitle, gap] = [iDiv(card), Card.sz / 4, 24, 8];
  let text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  box = mPlaceText(text, [szTitle, 10, sz + gap, sz + gap], d, { fg: 'dimgrey' }, { bg: 'beige', border: '1px solid grey', rounding: 10 });
  text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  box = mPlaceText(text, [sz, sz, 'bl'], d, { fg: 'dimgrey', bg: 'pink', rounding: 10, border: '5px solid pink' });
  let x1 = mSym('crow', d, { w: sz, h: sz, fg: 'green' }, 'br');
  x1 = mSym('abacus', d, { w: sz, h: sz }, 'bc');
  box = mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue', bg: 'orange', rounding: 10 });
}
function testRegexSplit() {
  let res = '\nfunction \nfunction hallo(){return "hallo";}\nasync function hallo1(){return "hallo1";}'
  let regex = new RegExp('\nasync function|\nfunction|\nvar|\nconst|\nclass', 'g');
  let fcode = res.split(regex);
  console.log(fcode);
}
function testRemoveBoard(R) {
  let oid = detectFirstBoardObject(R);
  console.log('testRemoveBoard: first board object detected has oid', oid);
  removeServerObject(oid, 'board');
}
function testRemoveInfluence(mapController, gObjects) {
  let data = {};
  addIf_dep("map", execOptions.activatedTests);
  data.removed = {
    "507565": {
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 507565
    },
    "531772": {
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531772
    },
    "531773": {
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531773
    },
    "531774": {
      value: 2,
      nation: "Norway",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531774
    },
    "531775": {
      value: 4,
      nation: "Latin_America",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531775
    }
  };
  mapController.update(data, gObjects);
}
function testRemoveObject(R) {
  let data = dict2list(sData);
  data = data.filter(x => (nundef(x.fields)) && nundef(x.neighbors));
  data = data.filter(x => firstCondDict(R.rNodes, y => y.oid == x.id));
  console.log('data gefiltered:', data)
  if (isEmpty(data)) {
    console.log('no objects left in sData!!!');
    return;
  }
  let oid = chooseRandom(data).id;
  removeServerObject(oid, 'random');
}
function testRemoveOidKey(R) {
  let n = getRandomUidNodeWithAct(R);
  if (!n) {
    console.log('there is no oid to remove!!!');
    return;
  }
  let [oid, key] = [n.oid, n.key];
  let nodeInstances = lookup(R.rNodesOidKey, [oid, key]);
  console.log('_________ testRemoveOidKey', 'remove all', oid, key, nodeInstances);
  removeOidKey(oid, key, R);
  updateOutput(R);
}
function testResizeEllipse(g) {
  let el = agEllipse(g, 100, 100);
  gBg(el, 'violet');
  gPos(el, 100, 110);
  gSize(el, 50, 20);
}
function testResizeHex(g) {
  let el = agHex(g, 50, 50);
  gBg(el, 'blue');
  gPos(el, 100, 110);
  gSize(el, 20, 20, 'hex');
}
function testResizeRect(g) {
  let el = agRect(g, 100, 50);
  gBg(el, 'violet');
  gPos(el, 100, 110);
  gSize(el, 50, 20);
}
function testRunToEnd(data, player) {
  let tuples = getTuples(data);
  if (empty(tuples)) {
    let waitingSet = getSet(data, "waiting_for");
    if (empty(waitingSet)) {
      error("NO ACTIONS AND EMPTY WAITING SET... sending empty action!!!");
      sendAction(player, ["none"], d => testRunToEnd(d, player));
    } else {
      let nextPlayer = waitingSet[0];
      sendChangeToPlayer(nextPlayer, d1 => {
        testRunToEnd(d1, nextPlayer);
      });
    }
  } else {
    decider.pickTuple(tuples, t => {
      sendAction(player, t, d => testRunToEnd(d, player));
    });
  }
}
function tests0_table_drawloop() {
  dTable = mBy('dTable'); mStyle(dTable, { vpadding: 20, bg: BLUE, align: 'center' });
  G = { items: [] };
  TO.running = setInterval(drawloop, 100);
  test1ttt();
}
function tests1_canvas_vs_dom() {
  let dPage = mBy('dTable'); mCenterCenterFlex(dPage); mStyle(dPage, { gap: 4 });
  G = { items: [] };
  dHeader = mDivLine(dPage);
  mLinebreak(dPage);
  let st = { w: 300, h: 250, bg: 'randlight' };
  let c1 = new ccanvas(dPage, st);
  mLinebreak(dPage);
  dTable = mDiv(dPage, st);
  mLinebreak(dPage);
  let c2 = new ccanvas(dPage, st);
  mLinebreak(dPage);
  dFooter = mDivLine(dPage);
  mLinebreak(dPage);
}
function testSaveLoadUiTree() {
  let uiTree = jsCopyMinus(T.uiTree, 'act', 'ui', 'defParams', 'params');
  console.log(uiTree);
}
async function testsendupdate() {
  let data = {
    user: isdef(U) ? U.name : 'felix',
    game: 'paris',
    fen: dixit_setup(['mimi', 'felix']),
    turn: ['felix'],
    step: 1,
  }
  let o = { type: 'updategame', data: data };
  let ostring = JSON.stringify(o);
  mBy('inpost').value = ostring;
  let res = await route_post_form_callback_js('/singlepost', 'fRoute', data => console.log('got from serverr', data))
}
function testSetBgOnSvgInsteadOfG() {
  let g = new MMS({ parent: UIS.a_d_game, type: 'g' }).setDefaults({ bg: 'yellow' }).attach();
}
function testShapes() {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let mobj = makeDrawingElement('el1', 'board');
  let sz = 200;
  let c = 'blue';
  let c1 = colorFrom('green', .1);
  console.log(c1);
  makeVisual(mobj, 0, 0, sz, sz, c1, 'quad');
  mobj.text({ txt: 'hallo', fill: colorDarker(c), fz: 30, y: -sz / 3 });
  mobj.ellipse({ w: sz / 2, h: sz / 2, fill: 'green', alpha: .5 })
  mobj.attach();
  mobj.addClickHandler('', () => {
    mobj.setShape('star');
  });
  let ms1 = makeDrawingElement('el2', 'board');
  makeVisual(ms1, -sz, 0, sz, sz, c1, 'triangle');
  ms1.attach();
}
async function testSolutionConverter() {
  let series = TEST_SERIES;
  let sols = await loadSolutions(series);
  console.log('solutions', sols);
  await saveSolutions(series, sols);
}
function testSorting() {
  let o = { z: [3, 2, 5, 1], d: { w: 2, r: 3 } };
  let d = mBy('spec');
  mNodeFilter(o, { dParent: d, title: 'orig' });
  mNodeFilter(o, { sort: 'all', dParent: d, title: 'sorted' });
  mNodeFilter(o, { sort: 'keys', dParent: d, title: 'justkeys' });
}
async function testSpeech() {
  await loadAssets();
  hide('floatingMenu');
  let table = mBy('table');
  let e = mEmo('red heart', table, 200);
  e.style.color = 'red';
  mFlexLinebreak(table);
  lang = 'E';
  matchingWords = ['heart'];
  if (isEnglish(lang)) {
    mInstruction('Say the word in English', table);
  } else {
    mInstruction('Sag das Wort auf Deutsch', table);
  }
  mFlexLinebreak(table);
  hintMessage = mHeading('HALLO', table, 1, 'hint');
  mFlexLinebreak(table);
  resultMessage = mText('jajaja', table);
  resultMessage.id = 'result';
  resultMessage.style.marginTop = '200px';
  resultMessage.style.fontSize = '20pt';
}
function testSplitIntoNumbersAndWords() {
  let ss = ['1k 2queen', '1 k 12 q', '12king2queen', '31 ace 2queen', '1 3 3 4', '1 10 3 8', '1J3As', '12 koenig 2 Ass'];
  for (const s of ss) {
    let x = splitIntoNumbersAndWords(s);
  }
}
function testSpotit() {
  let [rows, cols, numCards, setName] = [3, 2, 3, 'animals'];
  let infos = spotitDeal(rows, cols, numCards, setName);
  let items = [];
  for (const info of infos) {
    let item = spotitCard(info, dTable, { margin: 10 }, spotitOnClickSymbol);
    items.push(item);
  }
  return;
  for (const item of items) {
    for (const k in item.shares) {
      let other = Items[item.shares[k]];
    }
  }
}
function testStep(data, player) {
  let tuples = getTuples(data);
  if (empty(tuples)) {
    let waitingSet = getSet(data, "waiting_for");
    if (empty(waitingSet)) {
      error("NO ACTIONS AND EMPTY WAITING SET... sending empty action!!!");
      nextAction = () => sendAction(player, ["none"], d => testStep(d, player));
    } else {
      let nextPlayer = waitingSet[0];
      nextAction = () =>
        sendChangeToPlayer(nextPlayer, d1 => {
          testStep(d1, nextPlayer);
        });
    }
  } else {
    decider.pickTuple(tuples, t => {
      sendAction(player, t, d => testStep(d, player));
    });
  }
  show(bStep);
}
function testStepByStep(player = "Axis", filename = "gov_complete") {
  sendLoading(filename, player, d => testStep(d, player), "raw");
}
function testSuperGenialDivAndGBehavingTheSame() {
  let msD = new MMS({ parent: UIS.a_d_game, type: 'div' }).rect({ x: 20, y: 100, w: 50, h: 50, bg: 'blue' }).attach();
  let msG = new MMS({ parent: UIS.a_d_game, type: 'g' }).rect({ x: 20, y: 100, w: 25, h: 25, bg: 'red' }).attach();
  console.log(msD.elem, msG.elem)
}
function testSvgGRectTakesBg() {
  let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults().attach();
  let g = new MMS({ parent: svg, type: 'g' }).setDefaults({ bg: 'red' }).attach();
  let rect = new MMS({ parent: g, type: 'rect' }).setDefaults({ w: 50, h: 50, bg: 'yellow' }).attach();
  g.centerOrigin();
}
async function testTtt(r, c) {
  let sdata = genServerDataTtt(r, c);
  let spec = { ROOT: { cond: { obj_type: 'Board' }, type: 'grid', data: '.uid' } };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testVCentered() {
  let dTable = mBy('table');
  let d = mDiv(dTable);
  mSize(d, 100, 100);
  mColor(d, 'blue');
  let d1 = mText('HALLO', d);
  mCenterV(d1);
}
function textCorrectionFactor(text, styles, w, h, fz) {
  styles.fz = fz;
  let size = getSizeWithStyles(text, styles);
  if (Math.abs(size.h - h) > fz) { return size.h / h; } else return 0;
}
function ThreeFoldRep() {
  var i = 0, r = 0;
  for (i = 0; i < brd_hisPly; ++i) {
    if (brd_history[i].posKey == brd_posKey) {
      r++;
    }
  }
  return r;
}
function Tile(mapX, mapY, x, y, type) {
  this.x = x;
  this.y = y;
  this.mapX = mapX;
  this.mapY = mapY;
  this.isCollidable = false;
  this.collisionCallback = false;
  this.type = type;
  this.isAnimated = false;
  this.isCollidable = false;
  this.isClickable = false;
  this.clickCallback = false;
  this.animationPlaying = false;
  this.setCollision = function (callBack) {
    this.collisionCallback = callBack;
    this.isCollidable = true;
  }
  this.setAnimation = function () {
    this.isAnimated = true;
  }
  this.setClick = function (callBack) {
    this.isClickable = true;
    this.clickCallback = callBack;
  }
  this.checkCollision = function (sprite, w, h) {
    shw = sprite.width / 2;
    shh = sprite.height / 2;
    scx = sprite.x + shw;
    scy = sprite.y + shh;
    thw = w / 2;
    thh = h / 2;
    tcx = this.x + thw;
    tcy = this.y + thh;
    if (Math.abs(scx - tcx) < (thw + shw)) {
      if (Math.abs(scy - tcy) < (thh + shh)) {
        this.collisionCallback(this);
      }
    }
  }
}
function tileCondBelongsTo(t, pl, prop) { return t[prop] == pl.id; }
function TileMap(scene) {
  this.tileSheet = new Image();
  this.tiles = new Array();
  this.symbolImageMap = new Array();
  this.tileAnimations = new Array();
  this.specificTileAnimations = new Array();
  this.mapData = false;
  this.tileWidth = 0;
  this.tileHeight = 0;
  this.sheetWidth = 0;
  this.sheetHeight = 0;
  this.camera = new Camera(scene);
  this.loadTileSheet = function (tileWidth, tileHeight, sheetWidth, sheetHeight, tileSheet, tileSymbols) {
    this.tileSheet.src = tileSheet;
    this.tileWidth = tileWidth;
    this.tileHeight = tileHeight;
    this.SheetWidth = sheetWidth;
    this.SheetHeight = sheetHeight;
    numRows = Math.floor(this.SheetWidth / this.tileWidth);
    numCols = Math.floor(this.SheetHeight / this.tileHeight);
    for (i = 0; i < numRows; i++) {
      for (j = 0; j < numCols; j++) {
        if ((i * numCols) + j < tileSymbols.length) {
          this.symbolImageMap[(i * numCols) + j] = new Array(j * this.tileWidth, i * this.tileHeight, tileSymbols[(i * numCols) + j]);
        }
      }
    }
  }
  this.loadMapData = function (mapArray) {
    this.mapData = new Array();
    for (i = 0; i < mapArray.length; i++) {
      this.mapData.push(new Array());
      temp = new Array();
      for (j = 0; j < mapArray[i].length; j++) {
        k = 0;
        notConverted = true;
        while (notConverted && k < this.symbolImageMap.length) {
          if (mapArray[i][j] == this.symbolImageMap[k][2]) { this.mapData[i][j] = k; notConverted = false; }
          k++;
        }
        temp[j] = new Tile(j, i, j * this.tileWidth, i * this.tileHeight, k);
      }
      this.tiles.push(temp)
    }
  }
  this.drawMap = function () {
    this.camera.update();
    ctx = this.camera.context;
    for (i = 0; i < this.mapData.length; i++) {
      for (j = 0; j < this.mapData[i].length; j++) {
        drawX = this.tiles[i][j].x - this.camera.cameraOffsetX;
        drawY = this.tiles[i][j].y - this.camera.cameraOffsetY;
        if (0 < drawX < this.camera.cWidth && 0 < drawY < this.camera.cHeight) {
          ctx.save();
          sheetX = this.symbolImageMap[this.mapData[i][j]][0];
          sheetY = this.symbolImageMap[this.mapData[i][j]][1];
          ctx.translate(drawX, drawY);
          if (this.tiles[i][j].animationPlaying) { this.drawTileAnimation(this.tiles[i][j], ctx); }
          else {
            ctx.drawImage(this.tileSheet, sheetX, sheetY, this.tileWidth, this.tileHeight, 0, 0, this.tileWidth, this.tileHeight);
            ctx.restore();
          }
        }
      }
    }
  }
  this.addTileCollision = function (collisionCallback, typeOrX, y) {
    if (typeof y == "undefined") {
      for (i = 0; i < this.tiles.length; i++) {
        for (j = 0; j < this.tiles[i].length; j++) {
          if (this.tiles[i][j].type == typeOrX) {
            this.tiles[i][j].setCollision(collisionCallback);
          }
        }
      }
    }
    else {
      this.tiles[typeOrX][y].setCollision(collisionCallback);
    }
  }
  this.loadCollisionMap = function (collisionMap) {
    for (l = 0; l < collisionMap.length; l++) {
      c = 0;
      notConverted = true;
      while (c < this.symbolImageMap.length && notConverted) {
        if (this.symbolImageMap[c][2] == collisionMap[l][0]) {
          collisionMap[l][0] = c + 1;
          notConverted = false;
        }
        c++;
      }
    }
    for (i = 0; i < this.tiles.length; i++) {
      for (j = 0; j < this.tiles[i].length; j++) {
        k = 0;
        notAssigned = true;
        while (k < collisionMap.length && notAssigned) {
          if (this.tiles[i][j].type == collisionMap[k][0]) {
            this.tiles[i][j].setCollision(collisionMap[k][1]);
            notAssigned = false;
          }
          k++;
        }
      }
    }
  }
  this.mapScroll = function (dx, dy) { this.camera.moveCamera(dx, dy); }
  this.cameraFollowSprite = function (sprite, waitX, waitY) { this.camera.followSprite(sprite, waitX, waitY); }
  this.loadZOrderMap = function (zMap) { }
  this.addTileAnimation = function (imgWidth, imgHeight, cellWidth, cellHeight, tileName, animSheet) {
    animation = new Animation(animSheet, imgWidth, imgHeight, cellWidth, cellHeight);
    animation.setup();
    for (i = 0; i < this.symbolImageMap.length; i++) {
      if (this.symbolImageMap[i][2] = tileName) {
        this.tileAnimations[i] = animation;
      }
    }
  }
  this.addSpecificTileAnimation = function (imgWidth, imgHeight, cellWidth, cellHeight, tileX, tileY, animSheet) {
    animation = new Animation(animSheet, imgWidth, imgHeight, cellWidth, cellHeight);
    animation.setup();
    this.specificTileAnimations[tileX][tileY] = animation;
  }
  this.drawTileAnimation = function (tile, ctx) {
    notSpecific = true;
    if (typeof this.specificTileAnimations[tile.mapX][tile.mapY] !== 'undefined' && this.specificTileAnimations[tile.mapX][tile.mapY] !== null) {
      notSpecific = false;
      this.specificTileAnimations[tile.mapX][tile.mapY].reset();
      this.specificTileAnimations[tile.mapX][tile.mapY].drawFrame(ctx);
    }
    if (typeof this.tileAnimations[tile.type] !== 'undefined' && this.tileAnimations[tile.type] !== null && notSpecific) {
      this.tileAnimations[tile.type].reset();
      this.tileAnimations[tile.type].drawFrame(ctx);
    }
  }
  this.playTileAnimation = function (tile) { tile.animationPlaying = true; }
  this.stopTileAnimation = function (tile) { tile.animationPlaying = false; }
  this.checkCollisions = function (sprite) {
    tileCoordX = Math.floor(sprite.x / this.tileWidth);
    tileCoordY = Math.floor(sprite.y / this.tileHeight);
    checkRowsBegin = tileCoordX - 1;
    checkRowsEnd = tileCoordX + 2;
    checkColsBegin = tileCoordY - 1;
    checkColsEnd = tileCoordY + 2;
    if (tileCoordX > -1 && tileCoordY > -1 && tileCoordY < this.mapData.length && tileCoordX < this.mapData[tileCoordY].length) {
      if (tileCoordX == 0) { checkRowsBegin = 0; }
      if (tileCoordX == (this.mapData[tileCoordY].length - 1)) { checkRowsEnd = this.mapData.length; }
      if (tileCoordY == 0) { checkColsBegin = 0; }
      if (tileCoordY == (this.mapData.length - 1)) { checkColsBegin = this.mapData[tileCoordY].length; }
      for (i = checkColsBegin; i < checkColsEnd; i++) {
        for (j = checkRowsBegin; j < checkRowsEnd; j++) {
          if (this.tiles[i][j].isCollidable) {
            this.tiles[i][j].checkCollision(sprite, this.tileWidth, this.tileHeight);
          }
        }
      }
    }
  }
  this.makeSpriteMapRelative = function (sprite) { sprite.setCameraRelative(this.camera); }
  this.setPosition = function () { }
}
function timeConversion(duration, format = 'Hmsh') {
  const portions = [];
  const msInHour = 1000 * 60 * 60;
  const hours = Math.trunc(duration / msInHour);
  if (format.includes('H')) portions.push((hours < 10 ? '0' : '') + hours);
  duration = duration - (hours * msInHour);
  const msInMinute = 1000 * 60;
  const minutes = Math.trunc(duration / msInMinute);
  if (format.includes('m')) portions.push((minutes < 10 ? '0' : '') + minutes);
  duration = duration - (minutes * msInMinute);
  const msInSecond = 1000;
  const seconds = Math.trunc(duration / 1000);
  if (format.includes('s')) portions.push((seconds < 10 ? '0' : '') + seconds);
  duration = duration - (seconds * msInSecond);
  const hundreds = duration / 10;
  if (format.includes('h')) portions.push((hundreds < 10 ? '0' : '') + hundreds);
  return portions.join(':');
}
function Timer() {
  this.reset = function () {
    this.date = new Date();
    this.startTime = this.date.getTime();
    this.elapsedTime = 0;
  }
  this.getCurrentTime = function () {
    this.date = new Date();
    return this.date.getTime();
  }
  this.getElapsedTime = function () {
    current = this.getCurrentTime();
    return (current - this.startTime) / 1000;
  }
  this.start = this.reset;
  this.getTimeElapsed = this.getElapsedTime;
  this.reset();
}
function timeToMs(h, m, s) { return ((((h * 60) + m) * 60) + s) * 1000; }
function title_tableDiv_bounds(dParent, title, o) {
  let [d, t, w, h] = o_tableDiv_bounds(dParent, o);
  let ti = document.createElement('p');
  ti.innerHTML = title;
  t.prepend(ti);
  return [d, d.offsetWidth, d.offsetHeight];
}
function to_admin() {
  show('dAdminButtons');
  U = DB.users.mimi; show_user(DB.users[U.name]);
  to_games();
}
function to_aristocard(ckey, sz = 100, color = RED, w) {
  let info = jsCopy(C52Cards[ckey.substring(0, 2)]);
  info.key = ckey;
  info.cardtype = ckey[2];
  let [r, s] = [info.rank, info.suit];
  info.val = r == 'A' ? 1 : 'TJQK'.includes(r) ? 10 : Number(r);
  info.color = color;
  info.sz = info.h = sz;
  info.w = valf(w, sz * .7);
  info.irank = 'A23456789TJQK'.indexOf(r);
  info.isuit = 'SHCD'.indexOf(s);
  info.isort = info.isuit * 13 + info.irank;
  return info;
}
function to_commissioncard(ckey, sz = 40, color = GREEN, w) { return to_aristocard(ckey, sz, color); }
function to_create_table() {
  let t = create_table();
  server_send(t, 'create_table_and_start', to_table);
}
function to_games() {
  console.log('games fuer user', U.name, 'suchen');
  get_games(U.name, show_games_menu);
}
function to_lat_lng(pts = []) { return points_to_waypoints(pts); }
function to_luxurycard(ckey, sz = 100, color = 'gold', w) { return to_aristocard(ckey, sz, color); }
function to_rumorcard(ckey, sz = 40, color = GREEN, w) { return to_aristocard(ckey, sz, color); }
function to_server(req, type, to_php = true) {
  where(type);
  if (!to_php) {
    server_offline(req, type);
  } else if (is_online()) {
    server_online(req, type);
  } else {
    if (type == 'chat') { alert('no internet!'); mClassReplace(mBy("label_chat"), 'enabled', 'disabled'); }
    server_offline(req, type);
  }
}
function to_table() {
  console.log('table should be presented!')
}
function to_words(x) {
  let list = x.split('\n');
  let di = {};
  list.map(x => di[x.toLowerCase()] = x);
  return di;
}
function toBase10(s, base = 16) {
  let s1 = reverseString(s.toLowerCase());
  let res = 0;
  let mult = 1;
  for (let i = 0; i < s1.length; i++) {
    let l = s1[i];
    let hexarr = ['a', 'b', 'c', 'd', 'e', 'f'];
    let n = isNumber(l) ? Number(l) : 10 + hexarr.indexOf(l);
    res += mult * n;
    mult *= base;
  }
  return res;
}
function toBoardString(arr, rows, cols) {
  let s = '\n';
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let item = arr[r * cols + c];
      s += '' + (nundef(item) ? '_' : item) + ' ';
    }
    s += '\n';
  }
  return s;
}
function toDegree(rad) { return Math.floor(180 * rad / Math.PI); }
function toElem(d) { return isString(d) ? mBy(d) : d; }
function toggle_apps() { if (isEmpty(mBy('dApps').innerHTML)) show_apps(); else iClear('dApps'); }
function toggle_bw_symbol(d) {
  if (nundef(d)) d = document.getElementById('tbbw');
  d = d.getElementsByTagName('i')[0];
  if (isdef(d)) {
    if (d.classList.contains('fa-car')) {
      d.classList.remove('fa-car');
      d.classList.add('fa-star');
      mStyle(d, { fg: 'silver' });
    } else {
      d.classList.remove('fa-star');
      d.classList.add('fa-car');
      mStyle(d, { fg: 'transparent' });
    }
  }
}
function toggle_face(item) { if (item.faceUp) face_down(item); else face_up(item); }
function toggle_fiddle() { if (nundef(dFiddle)) show_fiddle(); else { fiddleSave(); for (const d of [dConsole, dFiddle, dSearch, dSidebar]) { iClear(d); } dFiddle = null; } }
function toggle_games() { if (isEmpty(mBy('dGames').innerHTML)) show_games(); else iClear('dGames'); }
function toggle_games_off() { let a = mBy('aGames'); hide('dGames'); mStyle(a, { bg: 'silver' }); }
function toggle_games_on() { let a = mBy('aGames'); mStyle(a, { bg: 'skyblue' }); }
function toggle_layers_control() {
  if (DA.layers_control) { M.map.removeControl(DA.layers_control); DA.layers_control = null; }
  else {
    let baseLayers = get_layer_options();
    let overlayLayers = get_layer_options();
    DA.layers_control = L.control.layers(baseLayers, overlayLayers, { collapsed: false })
    DA.layers_control.addTo(M.map);
  }
}
function toggle_list_member(arr, el) { arrToggleMember(arr, el); }
function toggle_mini_user_info() {
  if (nundef(DA.left_panel) || DA.left_panel == 'open') close_mini_user_info(); else open_mini_user_info();
}
function toggle_polling_status() {
  if (is_polling_on()) {
    stop_polling();
    let b = mBy('b_polling');
    b.className = 'buttonClass donebutton enabled off';
    b.innerHTML = 'polling off';
  } else {
    allow_polling();
    let b = mBy('b_polling');
    b.className = 'buttonClass donebutton enabled on';
    b.innerHTML = 'polling on';
  }
  console.log('Polling Status:', is_polling_on() ? 'ON' : 'OFF');
}
function toggle_select(item, selected, selstyle = 'selected') {
  let ui = iDiv(item);
  item.isSelected = !item.isSelected;
  if (item.isSelected) {
    mStyleOrClass(ui, selstyle);
  } else if (isString(selstyle)) {
    mClassRemove(ui, selstyle);
  } else if (isdef(item.style)) {
    mStyle(ui, item.style);
  } else {
    mStyleUndo(ui, selstyle);
  }
  if (isdef(selected)) {
    if (isList(selected)) {
      if (item.isSelected) {
        console.assert(!selected.includes(item), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
        selected.push(item);
      } else {
        console.assert(selected.includes(item), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
        removeInPlace(selected, item);
      }
    } else {
      mStyle(iDiv(selected), selected.style);
      selected.isSelected = false;
    }
  }
  return item.isSelected ? item : null;
}
function toggle_sidebar() {
  if (nundef(DA.left_panel) || DA.left_panel == 'open') close_sidebar(); else open_sidebar();
}
function toggle_sound() {
  U.settings.silent = !U.settings.silent;
  if (isdef(G)) G.silent = U.settings.silent;
  set_sound(U.settings.silent);
}
function toggle_tables_off() { let a = mBy('aTables'); hide('dTables'); mStyle(a, { bg: 'silver' }); }
function toggle_tables_on() { let a = mBy('aTables'); mStyle(a, { bg: '#afe78f' }); } //'lightgreen' }); }
function toggle_users_off() { let a = mBy('aUsers'); hide('dUsers'); mStyle(a, { bg: 'silver' }); }
function toggle_users_on() { let a = mBy('aUsers'); mStyle(a, { bg: 'coral' }); }
function toggleCollapsible(ev) {
  let b = ev.target;
  b.classList.toggle("active");
  var content = getLinkContainerId(b.id);
  if (isVisible(content)) hide(content); else show(content);
}
function toggleFace(pic) { if (pic.isFaceUp) turnFaceDown(pic); else turnFaceUp(pic); }
function toggleFaceSimple(pic) { if (pic.isFaceUp) turnFaceDownSimple(pic); else turnFaceUpSimple(pic); }
function toggleItemSelection(item, selectedItems) {
  let ui = iDiv(item);
  item.isSelected = nundef(item.isSelected) ? true : !item.isSelected;
  if (item.isSelected) mClass(ui, 'framedPicture'); else mRemoveClass(ui, 'framedPicture');
  if (isdef(selectedItems)) {
    if (item.isSelected) {
      console.assert(!selectedItems.includes(item), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
      selectedItems.push(item);
    } else {
      console.assert(selectedItems.includes(item), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
      removeInPlace(selectedItems, item);
    }
  }
}
function togglePic(ev) {
  let id = evToClosestId(ev);
  console.log(id)
  let item = UIS[id];
  console.log(item)
  if (isdef(item.pic)) removePic(item); else addPic(item, item.key);
}
function toggleSelection(pic, selected, clSelected = 'framedPicture', clUnselected = null) {
  let ui = iDiv(pic);
  pic.isSelected = !pic.isSelected;
  if (pic.isSelected) {
    if (isdef(clUnselected)) mClassRemove(ui, clUnselected);
    mClass(ui, clSelected);
  } else {
    mClassRemove(ui, clSelected);
    if (isdef(clUnselected)) mClass(ui, clUnselected);
  }
  if (isdef(selected)) {
    if (isList(selected)) {
      if (pic.isSelected) {
        console.assert(!selected.includes(pic), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
        selected.push(pic);
      } else {
        console.assert(selected.includes(pic), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
        removeInPlace(selected, pic);
      }
    } else {
      mClassRemove(iDiv(selected), clSelected);
      if (isdef(clUnselected)) mClass(iDiv(selected), clUnselected);
      selected.isSelected = false;
    }
  }
  return pic.isSelected ? pic : null;
}
function toggleSelectionOfPicture(pic, selectedPics, className = 'framedPicture') {
  let ui = iDiv(pic);
  pic.isSelected = !pic.isSelected;
  if (pic.isSelected) mClass(ui, className); else mClassRemove(ui, className);
  if (isdef(selectedPics)) {
    if (pic.isSelected) {
      console.assert(!selectedPics.includes(pic), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
      selectedPics.push(pic);
    } else {
      console.assert(selectedPics.includes(pic), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
      removeInPlace(selectedPics, pic);
    }
  }
}
function toggleSettings() { if (isVisible2('dSettings')) closeSettings(); else openSettings(); }
function toggleSidebar(ev, k, key) {
  if (nundef(DA.countKey)) { DA.countKey = {}; }
  if (nundef(DA.countKey[k])) { DA.countKey[k] = 0; }
  DA.countKey[k]++;
  let isOdd = DA.countKey[k] % 2 == 1;
  if (key == 'Escape' || ev.ctrlKey && k == 122) {
    if (isOdd) {
      mBy('left_panel').style.flex = 0;
      setTimeout(() => {
        show('mini_profile_img');
        show('mini_username');
      }, 500)
      mBy('mini_menu_right').style.display = 'flex';
    } else {
      mBy('left_panel').style.flex = 1;
      hide('mini_profile_img');
      hide('mini_username');
      mBy('mini_menu_right').style.display = 'none';
    }
  }
}
function toggleSound(key) {
  if (DA.isSound == true) { pauseSound(); DA.isSound = false; return; }
  playSound(key);
  DA.isSound = true;
}
function toggleTheme() {
  let bg = colorHex(dMain.style.backgroundColor);
  let lum = getBrightness(bg);
  console.log('current:\nbg', bg, '\nbaseColor', DA.pageBaseColor, '\nlum', lum);
  if (bg != DA.pageBaseColor) setPageBackground(DA.pageBaseColor, 'white', false);
  else if (lum <= .5) setPageBackground(colorLighter(bg), 'black', false);
  else setPageBackground(colorDarker(bg, 1), 'white', false);
}
function toggleTooltips(b) {
  if (S.settings.tooltips) {
    b.textContent = 'tooltips: OFF';
    S.settings.tooltips = false;
  } else {
    b.textContent = 'tooltips: ON';
    S.settings.tooltips = true;
  }
}
function toHTMLString(msg) {
  msg = JSON.stringify(msg);
  msg = msg.replace(/(?:\r\n|\r|\n)/g, '<br>');
  msg = msg.replace('\\n', '<br>');
  msg = msg.replace(/\\n/g, '<br>');
  msg = msg.replace(/"/g, '');
  return msg.trim();
}
function toLetterArray(s) { return toLetterList(s); }
function toLetterList(s) {
  return [...s];
}
function toLetters(s) { return [...s]; }
function toList(x) { return isList(x) ? x : [x]; }
function toLocalStorage(o, name = '_all') { localStorage.setItem(name, JSON.stringify(o)); }
function toModulo(n, modul) { rem = n % modul; n = n - rem; if (n < 0) n = 0; return n; }
function toNoun(s) { return capitalize(s.toLowerCase()); }
function too_many_string_items(A) { return A.items.filter(x => nundef(x.o)).length >= 8; }
function toogle_internet_status() {
  if (is_online()) {
    go_offline();
    let b = mBy('b_internet');
    b.className = 'statusbutton enabled off';
    b.innerHTML = 'offline';
  } else {
    go_online();
    db_save();
    let b = mBy('b_internet');
    b.className = 'statusbutton enabled on';
    b.innerHTML = 'online';
  }
  console.log('InternetStatus:', is_online() ? 'online' : 'OFFLINE');
}
function toolbar_check() {
  if (isEmpty(G.selist)) { mDisable('bclear'); mDisable('bnext') } else { mEnable('bclear'); mEnable('bnext') }
  if (isEmpty(G.hist)) { mDisable('bback'); } else { mEnable('bback'); }
}
function top_card_to_hands_abwechselnd(deck, hand1, hand2) {
  DA.hand = hand1;
  deck.items.map(x => {
    mStyle(iDiv(x), { cursor: 'pointer' });
    iDiv(x).onclick = () => {
      anim_from_deck_to_handX(x, deck, DA.hand);
      DA.hand = DA.hand == hand1 ? hand2 : hand1;
    }
  });
}
function top_card_to_market(deck, market) {
  deck.items.map(x => {
    mStyle(iDiv(x), { cursor: 'pointer' });
    iDiv(x).onclick = () => {
      anim_from_deck_to_marketX(x, deck, market);
    }
  });
}
function top_elem_from_to(arr1, arr2) { arr2.push(arr1.shift()); }
function top_elem_from_to_top(arr1, arr2) { arr2.unshift(arr1.shift()); }
function topCard(deck) { return deck.cards[0]; }
function topCardShouldGoTo(deck0, deck1, faceUp) {
  let c = Deck.transferTopFromToBottom(deck0, deck1)
  if (faceUp == true) Card52.turnFaceUp(c);
  mRemoveStyle(c.div, ['cursor', 'position']);
}
function toRadian(deg) { return deg * (Math.PI / 180); }
function TOSQ(m) { return (((m) >> 7) & 0x7F); }
function tossCoin(percent) {
  let r = Math.random();
  r *= 100;
  return r < percent;
}
function totalFreeze() {
  hide('passToNextPlayerUI')
  show('freezer');
}
function toUmlaut(w) {
  if (isList(w)) {
    let res = [];
    for (const w1 of w) res.push(toUmlaut(w1));
    return res;
  } else {
    w = replaceAll(w, 'ue', 'ü');
    w = replaceAll(w, 'ae', 'ä');
    w = replaceAll(w, 'oe', 'ö');
    w = replaceAll(w, 'UE', 'Ü');
    w = replaceAll(w, 'AE', 'Ä');
    w = replaceAll(w, 'OE', 'Ö');
    return w;
  }
}
function toWords(s, allow_ = false) {
  let arr = allow_ ? s.split(/[\W]+/) : s.split(/[\W|_]+/);
  return arr.filter(x => !isEmpty(x));
}
function toWordsSpeech(s) {
  var th = ['', 'thousand', 'million', 'billion', 'trillion'];
  var dg = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
  var tn = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];
  var tw = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
  s = s.toString();
  s = s.replace(/[\, ]/g, '');
  if (s != parseFloat(s)) return 'not a number';
  var x = s.indexOf('.');
  if (x == -1) x = s.length;
  if (x > 15) return 'too big';
  var n = s.split('');
  var str = '';
  var sk = 0;
  for (var i = 0; i < x; i++) {
    if ((x - i) % 3 == 2) {
      if (n[i] == '1') { str += tn[Number(n[i + 1])] + ' '; i++; sk = 1; }
      else if (n[i] != 0) { str += tw[n[i] - 2] + ' '; sk = 1; }
    } else if (n[i] != 0) {
      str += dg[n[i]] + ' '; if ((x - i) % 3 == 0) str += 'hundred '; sk = 1;
    } if ((x - i) % 3 == 1) {
      if (sk) str += th[(x - i - 1) / 3] + ' '; sk = 0;
    }
  }
  if (x != s.length) {
    var y = s.length;
    str += 'point ';
    str.replace(/\s+/g, ' ');
  }
  return str.trim();
}
function toWordsX(s, sAllow = '_') {
  let special = ['-', '.', '*', '?', '!'];
  let s1 = '';
  for (let i = 0; i < sAllow.length; i++) {
    let ch = sAllow[i];
    s1 += (special.includes(ch) ? '\\' : '') + ch + '|';
  }
  s1 = stringMinusLast(s1);
  let arr = s.split(new RegExp(`[^(\\w|${s1})]`)); ///[^(\w|+|\-|_)]/); // // toWordsX('+hallo -rey das ist ein regal');
  return arr.filter(x => !isEmpty(x));
}
function toYaml(o) { return jsonToYaml(o); }
function trace() { if (isTraceOn) console.log('___ ', getFunctionsNameThatCalledThisFunction(), '\n', ...arguments); }
function transColor(r, g, b, a) {
  return 'rgba(r,g,b,a)';
}
function transferElement() {
  let h = Daat.hand;
  let item = Daat.item;
  h.addTop(item.val);
  let zHand = Daat.zone;
  clearElement(zHand);
  let items = i52(h.cards());
  let handItem = Daat.iHand = iSplay(items, zHand);
}
function transformToString(k, val, refs) {
  if (val && isDict(val) && '_set' in val) { val = val._set; }
  if (k == 'visible' && !isEmpty(val) && !isDict(val[0])) { val = val.map(x => { return { _player: x } }); }
  let sval = null;
  if (isList(val) && isEmpty(val)) { sval = '{ }'; }
  else if (isList(val) && isString(val[0])) { sval = '{' + val.join(',') + '}' }
  else if (isListOf(val, '_obj')) { sval = makeRefLinkDiv4ListOf_obj(val, refs); }
  else if (isListOf(val, '_player')) { sval = makeRefLinkDiv4ListOf_player(val, refs); }
  else if (val && isDict(val) && '_obj' in val) { sval = makeRefLinkDiv4_obj(val, refs); }
  else if (val && isDict(val) && '_ndarray' in val) { sval = makeRefLinkDiv4MatrixOf_obj(val, refs) }
  else if (val && isDict(val) && '_player' in val) { sval = makeRefLinkDiv4_player(val, refs); }
  else if (isDictOrList(val)) {
    sval = tableHTMLX(val, refs);
  }
  else sval = simpleRep(val);
  return sval;
}
function transitionTo(id) {
  let delay = dCurrent ? .1 : 0;
  hideCurrent();
  setTimeout(() => setCurrent(id), delay);
}
function translateStylesToCy(styles, group) {
  let di = {};
  for (const k in styles) {
    let v = styles[k];
    let [prop, val] = translateToCssStyle(k, v, true);
    if (group == 'edge' && k == 'bg') di['line-color'] = val;
    else if (prop == 'shape' && val == 'hex') {
      di.shape = 'polygon';
      di['shape-polygon-points'] = [0, -1, 1, -0.5, 1, 0.5, 0, 1, -1, 0.5, -1, -0.5];
    }
    else di[prop] = val;
  }
  return di;
}
function translateToCssStyle(prop, val) { return mStyleTranslate(prop, val); }
function translateToGerman(w) {
  if (isNumber(w)) return w;
  else if (isdef(DD[w])) return DD[w];
  else return w;
}
function trash111() {
  let tgServer = G.serverData.tupleGroups;
  for (const tg of tgServer) {
    let desc = tg.desc.line.toString();
    let choices = tg.tuples._set;
    let tuples = choices.map(x => x._tuple);
    tupleGroups.push({ desc: desc, tuples: tuples });
  }
  return tupleGroups;
}
function tree_add() {
  let root = C.root;
  if (root.phase == 'spring') {
    C.changed = false;
    assertion(root, 'ROOT IS NULL BEI TREE_ADD!!!!!!!!!!!!!')
    if (!root.done) {
      let b = create_branch(root, root.angle, root.len * root.dlen, root.color);
      lookupAddToList(C.items, [b.t], b);
      C.changed = true;
    } else {
      for (const b of C.items.branch.filter(x => !x.done)) {
        if (b.age < root.depth) {
          let br = root.branching;
          for (const a of br) {
            let o = create_branch(b, b.angle + toRadian(a), b.len * root.dlen, colorMix(b.color, 'lime', 3)); lookupAddToList(C.items, [o.t], o);
          }
        } else {
          let o = create_leaf(b, root); lookupAddToList(C.items, [o.t], o);
        }
        C.changed = true;
        root.maxage = b.age + 1;
        b.done = true;
      }
    }
    if (!C.changed) { root.minage = 0; root.phase = 'summer'; }
  }
  else if (root.phase == 'summer') {
    let colors = ['darkgreen', 'olive', '#8B9216', '#A79F0F', '#EDA421', '#E98604', '#DF3908', '#C91E0A', '#8C584A'];
    let changed = mutate_colors('leaf', colors);
    if (!changed) root.phase = 'autumn';
    root.jitter = true;
    C.changed = true;
  }
  else if (root.phase == 'autumn') {
    root.jitter = false;
    C.changed = true;
    let falling = C.items.leaf.filter(l => l.p.y < CV.height);
    if (isEmpty(falling)) {
      C.changed = false; root.phase = 'winter';
    } else {
      for (const b of falling) { b.p = { x: b.p.x + Math.random() * .51, y: b.p.y + Math.random() * 3 }; }
    }
  }
  else if (root.phase == 'winter') {
    let colors = ['#8E2100', '#5C1306', '#371C0F', '#1C1B19'];
    let changed = mutate_colors('branch', colors);
    if (!changed) root.phase = 'over';
    C.changed = true;
  }
  else if (root.phase == 'over') { root.animated = false; }
  if (root.animated) TO.iv1 = setTimeout(tree_add, root.speed[root.phase]); else TO.iv1 = setTimeout(() => G_init('tree'), 3000);
}
function tree_clear() { G_clear(); onclick_menu_item('tree'); }
function tree_init(offx = 0, offy = 0, options = {}) {
  let root = {
    done: false,
    t: 'root',
    age: 0,
    p2: { x: offx + CV.width / 2, y: offy + CV.height },
    len: valf(options.len, 100),
    angle: toRadian(90),
    thickness: valf(options.thick, 20),
    color: valf(options.color, 'sienna'),
    depth: NATURE.depth,
    branching: NATURE.branching,
    dlen: .7,
    dthickness: .7,
    phase: 'spring',
    speed: { spring: 100, summer: 100, autumn: 25, winter: 100, over: 2000 },
    animated: false,
    jitter: false,
  };
  return root;
}
function treee(o) {
  let s = '<table class="tttable">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? treee(val) : simpleRep(val);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function tri0() {
  let sq3 = 1.73205080757;
  let sq3b = Math.sqrt(3);
  console.log('sq3', sq3, 'sq3b', sq3b)
}
function tri1() {
  let sq3 = Math.sqrt(3);
  let a = 48;
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let [rows, maxcols] = [3, 4];
  let ys = 2 + 3 * rows;
  let xs = maxcols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = info.isHexCenter ? drawBee(info.pt) : drawSym(sym, info.pt);
    items.push(item);
  }
}
function tri2() {
  let sq3 = Math.sqrt(3);
  let a = 48;
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let [rows, maxcols] = [3, 4];
  let ys = 2 + 3 * rows;
  let xs = maxcols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = info.isHexCenter ? drawCenteredBee(info.pt) : drawCenteredPlainCircle(info.pt);
    items.push(item);
    let d = iDiv(item);
    if (info.isHexCenter) mClass(d, 'hexagon');
    if (info.isHexCenter) mText(info.trow + ' ' + info.tcol, d, { fz: 10 });
  }
}
function tri3() {
  let sq3 = Math.sqrt(3);
  let a = 48;
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let [rows, maxcols] = [3, 4];
  let ys = 2 + 3 * rows;
  let xs = maxcols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = drawText(info.trow + ',' + info.tcol, info.pt);
    items.push(item);
  }
}
function tri4() {
  let sq3 = Math.sqrt(3);
  let a = 48;
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let [rows, maxcols] = [3, 4];
  let ys = 2 + 3 * rows;
  let xs = maxcols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = drawText(info.trow + ',' + info.tcol, info.pt);
    if (info.isHexCenter) mStyle(iDiv(item), { bg: 'pink' })
    items.push(item);
  }
}
function trialPromptML() {
  let selinp = Selected.inp;
  say('try again!');
  setTimeout(() => {
    let d = selinp.div;
    d.innerHTML = '_';
    mClass(d, 'blink');
  }, skipAnimations ? 300 : 2000);
  showFleetingMessage(composeFleetingMessage(), 3000);
  return 10;
}
function trialPromptSP() {
  say(currentLanguage == 'E' ? 'try again!' : 'nochmal', 1, 1, .3, true, 'zira');
  animate(dInstruction, 'pulse800' + getSignalColor(), 900);
  return 1500;
}
function trialPromptSPA() {
  return 10;
}
function trialPromptTC() {
  say('try again');
  shortHintPic();
  return 10;
}
function trialPromptTP() {
  say('try again');
  shortHintPic();
  return 10;
}
function trialPromptWP() {
  say(currentLanguage == 'E' ? 'try again!' : 'nochmal', 1, 1, .8, true, 'zira');
  mLinebreak(dTable);
  inputBox = addNthInputElement(dTable, trialNumber);
  defaultFocusElement = inputBox.id;
  return 10;
}
function trickleDown(n, R, trickle) {
  currentSizing = trickle.sizing;
  let res = {};
  res.sizing = isdef(n.params) && isdef(n.params.sizing) ? n.params.sizing
    : isdef(currentSizing) ? currentSizing : R.defs.defaultSizing;
  return res;
}
function trim(str) {
  return str.replace(/^\s+|\s+$/gm, '');
}
function try_find_username(ev) {
  evNoBubble(ev);
  let username = findAttributeInAncestors(ev.target, 'username');
  if (nundef(Session.users_by_name[username])) { alert('ERROR username!'); return null; }
  return username;
}
function tryBegin(callback) { let route = '/begin/1'; _sendRouteJS(route, callback); }
function tryConvertToJSON(s) {
  let res = null;
  try { res = JSON.parse(s); return res; }
  catch {
    return null;
  }
}
function tsAction(x) { if ('ID' in x) return x.ID; else return x.val; }
function tsRec(x) {
  if (isList(x)) { return '[' + x.map(tsRec).join('') + ']'; }
  if (isDict(x)) {
    if ('_set' in x) {
      return '{' + tsRec(x._set) + '}';
    } else if ('_tuple' in x) {
      return '(' + tsRec(x._tuple) + ')'
    } else if ('type' in x) {
      return tsAction(x)
    } else { return 'obj unknown'; }
  } else return 'type unknown';
}
function ttBody(oid, o) {
  let sProps = '';
  let sVals = '';
  for (const p in o) {
    if (p == 'obj_type' || p == 'name' || p == 'id') continue;
    let val = o[p];
    sProps += p + '<br>';
    sVals += simpleRep(val) + '<br>';
  }
  $('div#ttipLeft').html(sProps);
  $('div#ttipRight').html(sVals);
}
function ttBody2(oid, o) {
  let s = treee(o);
  clearElement('ttipRight');
  $('div#ttipLeft').html(s);
}
function ttTitle(oid, o) {
  $('div#ttipTitle').html(('obj_type' in o ? o.obj_type : '_') + ('name' in o ? ':' + o.name : 'id' in o ? ':' + o.id : ' ' + oid));
}
function turn_create_otree(obj) {
  console.assert(isdef(obj.table), 'turn_create_otree without obj.table!!!!!!!!!!!!!!');
  let g = Session;
  let [menu, table, fen, plist, players] = [g.cur_menu, g.table, g.fen, g.plist, g.players] = ['play', obj.table, obj.table.fen, obj.playerdata, obj.table.fen.players];
  let otree = jsCopy(fen);
  let order = isdef(fen.plorder) ? fen.plorder : plist.map(x => x.name);
  otree.player_names = order;
  for (const uname of order) {
    let pl = firstCond(plist, x => x.name == uname);
    copyKeys(DB.users[uname], pl);
    copyKeys(fen.players[uname], pl);
    otree[uname] = pl;
  }
  addKeys(fen, otree);
  delete otree.players;
  return otree;
}
function turn_create_R(otree) {
  Items = {};
  let g = Session;
  R = g.R = new RSG(); R.otree = otree;
  let r_keys = R.keys = Session.game_keys.r_nodes;
  let akku = G.akku = [];
  let root = R.root = rec_create_nodes_tree_akku(R, otree, '', r_keys, akku);
  return R;
}
function turn_new_schwein_up(schwein, fenbuilding, uibuilding) {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let is_first_schwein = isEmpty(fenbuilding.schweine);
  add_schwein(schwein, fenbuilding, uibuilding);
  ari_history_list([`${uplayer} reveals a schwein!`], 'inspect');
  if (is_first_schwein) {
    console.log('unique AND first new schwein');
    show_instruction('found schwein - both players get a rumor!');
    let owner = stringAfter(uibuilding.path, '.');
    owner = stringBefore(owner, '.');
    console.log('owner', owner, 'uplayer', uplayer);
    A.owner = owner;
    ari_open_rumors(32);
  } else {
    console.log('unique new schwein (gibt schon schweine)')
    show_instruction('found schwein - you gain a rumor!');
    let rumor = fen.deck_rumors[0]; fen.deck_rumors.shift();
    fen.players[uplayer].rumors.push(rumor);
    ari_history_list([`${uplayer} inspects a schweine building!`], 'inspect');
    ari_next_action();
  }
}
function turn_package_otree(otree) {
  let keys = Session.game_keys.players;
  let fen = otree;
  fen.players = {};
  for (const plname of otree.plorder) fen.players[plname] = stripToKeys(otree[plname], keys);
  otree.plorder.map(x => delete fen[x]);
  return fen;
}
function turn_present(obj) {
  if (ITER >= Math.min(DA.iter, MAXITER)) { console.log('iter', ITER == MAXITER ? 'MAX' : 'DA.iter'); TOMan.clear(); return; } ITER++;
  let otree = turn_unpackage_fen(obj);
  let rtree = turn_create_R(otree);
  ui_table_actions_stats();
  if (G.cur_game == 'gAristo') { ari_branch(obj, otree, rtree); }
  else if (G.cur_game == 'gPreinno') { inno_branch(obj, otree, rtree); }
}
function turn_schwein_up(b) {
  let key = b.keycard.key;
  let list = b.list;
  let schwein = firstCond(list, x => x[0] != key[0]);
  assertion(isdef(schwein), 'WAS DA IST GARKEIN SCHWEIN!!!!!!!!!!', b);
  let ui = firstCond(b.items, x => x.key == schwein);
  face_up(ui);
  let obuilding = lookup(Z.fen, b.path.split('.'));
  b.schwein = obuilding.schwein = schwein;
  ari_open_rumors(32);
}
function turn_send_gameover(otree, uname) {
  let fen = turn_package_otree(otree);
  let g = Session;
  let o = { uname: uname, tid: g.table.id, fen: fen, table_status: 'over' };
  to_server(o, 'turn_update');
}
function turn_send_move_update(otree, uname) {
  let fen = turn_package_otree(otree);
  let g = Session;
  let o = { uname: uname, tid: g.table.id, fen: fen, table_status: g.table.status };
  to_server(o, 'turn_update');
}
function turn_send_reload(uname) {
  let g = Session;
  let o = { uname: uname, tid: g.table.id, table_status: g.table.status };
  to_server(o, 'turn_update');
}
function turn_set_game_assets(g) {
  if (g.cur_game == 'gPreinno') g.cards = InnoById;
  else if (g.cur_game == 'gAristo') g.cards = Aristocards;
}
function turn_set_keys(g, obj) {
  let fen = obj.table.fen;
  let di = {
    table: get_keys(fen),
    players: get_keys(fen.players[fen.plorder[0]]),
    r_nodes: [],
    ui_nodes: []
  };
  let rks = arrMinus(di.table.concat(di.players), ['splays', 'herald', 'plorder', 'coins']);
  rks = arrPlus(rks, ['green', 'purple', 'blue', 'red', 'yellow']);
  rks = rks.concat(fen.plorder);
  di.r_nodes = rks;
  di.ui_nodes = arrMinus(di.r_nodes, []);
  g.game_keys = {};
  for (const k in di) {
    let di1 = g.game_keys[k] = {};
    for (const k1 of di[k]) di1[k1] = true;
  }
}
function turn_show_gameover(otree) {
  let game = Session.cur_game;
  let table = Session.cur_table;
  let players = otree2cur_players(otree);
  let winner = otree.winner;
  if (!Session.scoring_complete) {
    console.log('======>scoring!!!!!', table.friendly);
    scoring_update(otree.plorder, [otree.winner], game);
    out1();
    Session.scoring_complete = true;
  }
  let pl = otree[winner];
  let styles = { bg: pl.color, alpha: .75, fg: 'contrast', top: 220, };
  let msg = 'GAME OVER - The ' + `winner is ${otree.winner}!!!`;
  let d = status_message(msg, styles);
  let end_scores = table.status == 'past' ? table.end_scoring : get_scores_from_cur_players();
  show_score_table(end_scores, table.friendly, d);
  mLinebreak(d);
  mButton('click to close', onclick_gameover_new, d, { fz: 20 }, ['buttonClass', 'donebutton']);
}
function turn_unpackage_fen(obj) {
  let g = Session;
  turn_set_game_assets(g);
  turn_set_keys(g, obj);
  g.obj = ServerData = obj;
  let otree = Fen = g.otree = turn_create_otree(obj);
  return otree;
}
function turnCardsAfter(secs, removeBg = false) {
  let qc = QContextCounter;
  for (const p of Pictures) { slowlyTurnFaceDown(p, secs - 1, removeBg); }
  TOMain = setTimeout(() => {
    showInstruction(Goal.label, 'click', dTitle, true);
    showMouse();
    GC.activateUi.bind(GC)();
  }, secs * 1000);
}
function turnDeckFaceUp(deck) { if (deck.isFaceDown) { deck.flip(); deck.isFaceDown = false; } }
function turnFaceDown(pic) {
  let ui = iDiv(pic);
  for (const p1 of ui.children) p1.style.opacity = 0;
  ui.style.backgroundColor = 'dimgray';
  pic.isFaceUp = false;
}
function turnFaceDownSimple(pic) {
  let ui = iDiv(pic);
  ui.style.transition = null;
  mRemoveClass(ui, 'frameOnHover');
  for (const ch of ui.children) { ch.style.transition = null; ch.style.opacity = 0; }
  pic.isFaceUp = false;
}
function turnFaceUp(pic, secTransition = 1) {
  let div = iDiv(pic);
  for (const ch of div.children) {
    ch.style.transition = `opacity ${secTransition}s ease-in-out`;
    ch.style.opacity = 1;
  }
  div.style.transition = null;
  div.style.backgroundColor = pic.bg;
  pic.isFaceUp = true;
}
function turnFaceUpSimple(pic) {
  let ui = iDiv(pic);
  mRemoveClass(ui, 'frameOnHover');
  ui.style.transition = null;
  for (const ch of ui.children) { ch.style.transition = null; ch.style.opacity = 1; }
  pic.isFaceUp = true;
}
function turtle() {
  background(51);
  stroke(255);
  translate(width / 2, height);
  for (let i = 0; i < sentence.length; i++) {
    let x = sentence.charAt(i);
    if ('ABF'.includes(x)) { line(0, 0, 0, -len); translate(0, -len); }
    else if (x == '+') rotate(angle);
    else if (x == '-') rotate(-angle);
    else if (x == '[') push();
    else if (x == ']') pop();
  }
}
function ty01() { }
function type00flex(n, R) { return 'type00flex'; }
function typeEmpty(n, R) { return 'empty'; }
function typePanelInfo(n, R) { return isdef(n.children) ? 'panel' : 'info'; }
function ui_add_cards_to_card_container(cont, items, list) {
  if (nundef(list)) list = items.map(x => x.key);
  for (const item of items) {
    mAppend(cont, iDiv(item));
  }
}
function ui_add_cards_to_deck_container(cont, items, list) {
  if (nundef(list)) list = items.map(x => x.key);
  for (const item of items) {
    mAppend(cont, iDiv(item));
    mItemSplay(item, list, 4, Card.ovdeck);
    face_down(item);
  }
  return items[0];
}
function ui_add_cards_to_hand_container(cont, items, list) {
  if (nundef(list)) list = items.map(x => x.key);
  for (const item of items) {
    mAppend(cont, iDiv(item));
    mItemSplay(item, list, 2, Card.ovw);
  }
}
function ui_add_container_title(title, cont, items, show_if_empty) {
  if (isdef(title) && (!isEmpty(items) || show_if_empty)) {
    let st = get_containertitle_styles();
    let stmeasure = jsCopy(st); delete stmeasure.position;
    let elem = mText(title, cont, stmeasure);
    let sz = getSizeNeeded(elem);
    let offsetx = valf(st.left, 0);
    let cont_wmin = mGetStyle(cont, 'wmin');
    let my_min = sz.w + offsetx * 1.5;
    let wmin = !isNumber(cont_wmin) ? my_min : Math.max(valf(cont_wmin, 0), my_min);
    mStyle(cont, { wmin: wmin });
    mStyle(elem, st);
  }
}
function ui_from_deck_to_hand(el, deck, hand) {
  let topmost = deck.items.shift();
  console.assert(el == topmost, 'top deck elem is NOT correct!!!!')
  face_up(topmost);
  let dtop = iDiv(topmost);
  deck.list = deck.items.map(x => x.key);
  deck.topmost = deck.items[0];
  dtop.remove();
  dtop.style.position = 'static';
  hand.items.push(topmost);
  hand.list = hand.items.map(x => x.key);
  mAppend(hand.container, dtop);
  mContainerSplay(hand.container, 2, CWIDTH, CHEIGHT, hand.list.length, OVW);
  mItemSplay(topmost, hand.list, 2, OVW);
}
function ui_game_menu_item(g, g_tables = []) {
  function runderkreis(color, id) {
    return `<div id=${id} style='width:20px;height:20px;border-radius:50%;background-color:${color};color:white;position:absolute;left:0px;top:0px;'>` + '' + "</div>";
  }
  let [sym, bg, color, id] = [Syms[g.logo], g.color, null, getUID()];
  if (!isEmpty(g_tables)) {
    let t = g_tables[0];
    let have_another_move = t.player_status == 'joined';
    color = have_another_move ? 'green' : 'red';
    id = `rk_${t.id}`;
  }
  return `
  <div onclick="onclick_game_menu_item(event)" gamename=${g.id} style='cursor:pointer;border-radius:10px;margin:10px;padding:5px;padding-top:15px;width:120px;height:90px;display:inline-block;background:${bg};position:relative;'>
  ${nundef(color) ? '' : runderkreis(color, id)}
  <span style='font-size:50px;font-family:${sym.family}'>${sym.text}</span><br>${g.friendly.toString()}</div>
  `;
}
function ui_game_stats(players) {
  let d = dTitle;
  clearElement(d);
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname in players) {
    let pl = players[plname];
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='${pl.imgPath}' style="display:block" class='img_person' width=50 height=50>${pl.score}`);
  }
}
function ui_get_all_commission_items(uplayer) {
  let items = [], i = 0;
  let comm = UI.players[uplayer].commissions;
  for (const o of comm.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_all_hidden_building_items(uplayer) {
  let items = [];
  for (const gb of UI.players[uplayer].buildinglist) {
    items = items.concat(ui_get_hidden_building_items(gb));
  }
  reindex_items(items);
  return items;
}
function ui_get_blackmailed_items() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let commands = ['accept', 'reject'];
  let rumors = fen.players[uplayer].rumors;
  let b = path2fen(fen, fen.blackmail.building_path);
  if (nundef(b.lead)) b.lead = b.list[0];
  if (isList(rumors) && firstCond(rumors, x => x[0] == b.lead[0])) {
    commands.push('defend');
  }
  return ui_get_string_items(commands);
}
function ui_get_bluff_inputs(strings) {
  let uplayer = Z.uplayer;
  let items = ui_get_string_items(uplayer, strings);
  console.log('items', items)
  return items;
}
function ui_get_build_items(uplayer, except) {
  let items = ui_get_hand_and_stall_items(uplayer);
  if (is_card(except)) items = items.filter(x => x.key != except.key);
  reindex_items(items);
  return items;
}
function ui_get_building_items(uplayer) {
  let gblist = UI.players[uplayer].buildinglist;
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_building_items_of_type(uplayer, types = ['farm', 'estate', 'chateau']) {
  let gblist = UI.players[uplayer].buildinglist.filter(x => types.includes(x.type));
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_buildings(gblist) {
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_buy_or_pass_items() {
  let items = [], i = 0;
  if (!isEmpty(UI.deck_discard.items)) items.push(ui_get_deck_item(UI.deck_discard));
  items = items.concat(ui_get_string_items(['pass']));
  reindex_items(items);
  return items;
}
function ui_get_card_items(cards) {
  let items = [], i = 0;
  for (const o of cards) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: ``, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_church_items(uplayer) {
  let fen = Z.fen;
  let items = [], i = 0;
  let church = UI.church;
  for (const o of church.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: church.path, index: i };
    i++;
    items.push(item);
  }
  let candidates = fen.candidates = arrMinus(fen.toBeSelected, uplayer);
  if (candidates.length > 1) {
    let player_items = ui_get_string_items(candidates);
    items = items.concat(player_items);
    reindex_items(items);
  }
  return items;
}
function ui_get_coin_amounts(uplayer) {
  let items = [];
  for (let i = 0; i <= Z.fen.players[uplayer].coins; i++) {
    let cmd = '' + i;
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    items.push(item);
  }
  return items;
}
function ui_get_commands(uplayer) {
  let avail = ari_get_actions(uplayer);
  let items = [], i = 0;
  for (const cmd of avail) {
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_commission_items(uplayer) {
  let items = [], i = 0;
  let comm = UI.players[uplayer].commissions;
  let stall = ui_get_stall_items(uplayer);
  for (const o of comm.items) {
    let rank = o.key[0];
    let similar = firstCond(stall, x => x.key[0] == rank);
    if (!similar) continue;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i, similar: stall.filter(x => x.key[0] == rank) };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_commission_new_items(uplayer) {
  let items = [], i = 0;
  let comm = UI.open_commissions;
  for (const o of comm.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
    i++;
    items.push(item);
  }
  let topdeck = UI.deck_commission.get_topcard();
  items.push({ o: topdeck, a: topdeck.key, key: topdeck.key, friendly: topdeck.short, path: 'deck_commission', index: i });
  return items;
}
function ui_get_commission_stall_items() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  console.log('ui_get_commission_stall_items similar', A.commission.similar);
  let items = A.commission.similar;
  reindex_items(items);
  return items;
}
function ui_get_deck_item(uideck) {
  let topdeck = uideck.get_topcard();
  let item = { o: topdeck, a: topdeck.key, key: topdeck.key, friendly: topdeck.short, path: uideck.path, index: 0 };
  return item;
}
function ui_get_endgame(uplayer) { return ui_get_string_items(['end game', 'go on']); }
function ui_get_estates_chateaus_items(uplayer) { return ui_get_building_items_of_type(uplayer, ['estate', 'chateau']); }
function ui_get_exchange_items(uplayer) {
  let ihand = ui_get_hand_items(uplayer);
  let istall = ui_get_stall_items(uplayer);
  let irepair = ui_get_all_hidden_building_items(uplayer);
  irepair.map(x => face_up(x.o));
  let items = ihand.concat(istall).concat(irepair);
  reindex_items(items);
  return items;
}
function ui_get_farms_estates_items(uplayer) { return ui_get_building_items_of_type(uplayer, ['farm', 'estate']); }
function ui_get_ferro_items() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer);
  for (const plname of plorder) {
    let jlist = UI.players[plname].journeys;
    for (const jitem of jlist) {
      for (const o of jitem.items) {
        if (!is_joker(o)) { continue; }
        let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: jitem.path, index: 0 };
        items.push(item);
      }
    }
  }
  for (const plname of plorder) {
    let jlist = UI.players[plname].journeys;
    for (const jitem of jlist) {
      let o = jitem.items[0];
      let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: jitem.path, index: 0 };
      items.push(item);
    }
  }
  let cmds = ui_get_submit_items(['discard', 'auflegen', 'jolly', 'anlegen']);
  items = items.concat(cmds);
  reindex_items(items);
  return items;
}
function ui_get_hand_and_journey_items(uplayer) {
  let items = ui_get_hand_items(uplayer);
  let matching = [];
  for (const plname of Z.plorder) {
    let jitems = ui_get_journey_items(plname);
    for (const j of jitems) {
      for (const card of items) {
        if (matches_on_either_end(card, j)) { matching.push(j); break; }
      }
    }
  }
  items = items.concat(matching);
  reindex_items(items);
  return items;
}
function ui_get_hand_and_stall_items(uplayer) {
  let items = ui_get_hand_items(uplayer);
  items = items.concat(ui_get_stall_items(uplayer));
  reindex_items(items);
  return items;
}
function ui_get_hand_items(uplayer) {
  let items = [], i = 0;
  let hand = UI.players[uplayer].hand;
  for (const o of hand.items) {
    o.index = i;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: hand.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_hand_items_minus(uplayer, cardlist) {
  if (!isList(cardlist)) cardlist = [cardlist];
  let items = [], i = 0;
  let hand = UI.players[uplayer].hand;
  for (const o of hand.items) {
    if (cardlist.includes(o)) continue;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: hand.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_harvest_items(uplayer) {
  let items = []; let i = 0;
  for (const gb of UI.players[uplayer].buildinglist) {
    if (isdef(gb.harvest)) {
      let d = gb.harvest;
      mStyle(d, { cursor: 'pointer', opacity: 1 });
      gb.div = d;
      let name = 'H' + i + ':' + (gb.list[0][0] == 'T' ? '10' : gb.list[0][0]);
      let item = { o: gb, a: name, key: name, friendly: name, path: gb.path, index: i };
      i++;
      items.push(item);
    }
  }
  return items;
}
function ui_get_hidden_building_items(uibuilding) {
  let items = [];
  for (let i = 1; i < uibuilding.items.length; i++) {
    let o = uibuilding.items[i];
    o.index = i;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: uibuilding.path, index: i - 1 };
    items.push(item);
  }
  return items;
}
function ui_get_journey_items(plname) {
  let gblist = UI.players[plname].journeys;
  let items = [], i = 0;
  for (const o of gblist) {
    let name = `${plname}_j${i}`;
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_market_items() {
  let items = [], i = 0;
  for (const o of UI.market.items) {
    o.index = i;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `market`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_open_discard_items() {
  let items = [], i = 0;
  for (const o of UI.open_discard.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `open_discard`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_other_buildings(uplayer) {
  let items = [];
  for (const plname of Z.plorder) {
    if (plname == uplayer) continue;
    items = items.concat(ui_get_buildings(UI.players[plname].buildinglist));
  }
  reindex_items(items);
  return items;
}
function ui_get_other_buildings_and_rumors(uplayer) {
  let items = ui_get_other_buildings(uplayer);
  items = items.concat(ui_get_rumors_items(uplayer));
  reindex_items(items);
  return items;
}
function ui_get_other_buildings_with_rumors(uplayer) {
  let items = [];
  for (const plname of Z.plorder) {
    if (plname == uplayer) continue;
    items = items.concat(ui_get_buildings(UI.players[plname].buildinglist.filter(x => !isEmpty(x.rumors))));
  }
  reindex_items(items);
  return items;
}
function ui_get_payment_items(pay_letter) {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let items = ui_get_hand_and_stall_items(uplayer);
  let n = items.length;
  items = items.filter(x => x.key[0] == pay_letter);
  if (n == 4 && A.command == 'build') items = [];
  if (n == 1 && A.command == 'upgrade') items = [];
  if (fen.players[uplayer].coins > 0 && fen.phase[0].toUpperCase() == pay_letter) {
    items.push({ o: null, a: 'coin', key: 'coin', friendly: 'coin', path: null });
  }
  let i = 0; items.map(x => { x.index = i; i++; });
  return items;
}
function ui_get_rumors_and_players_items(uplayer) {
  let items = [], i = 0;
  let comm = UI.players[uplayer].rumors;
  let [data, pl] = [Z.uplayer_data, Z.pl];
  assertion(isdef(data), 'no data for player ' + uplayer);
  if (!isDict(data.state)) data.state = { remaining: jsCopy(pl.rumors), receivers: [], di: {} };
  let rem = data.state.remaining;
  for (const k of rem) {
    let o = firstCond(comm.items, x => x.key == k);
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
    i++;
    items.push(item);
  }
  let players = [];
  let receivers = data.state.receivers;
  for (const plname in UI.players) {
    if (plname == uplayer || receivers.includes(plname)) continue;
    players.push(plname);
  }
  items = items.concat(ui_get_string_items(players));
  reindex_items(items);
  return items;
}
function ui_get_rumors_items(uplayer) {
  let items = [], i = 0;
  let rum = UI.players[uplayer].rumors;
  for (const o of rum.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: rum.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_schweine_candidates(uibuilding) {
  let items = ui_get_hidden_building_items(uibuilding);
  items = items.filter(x => x.o.key[0] != uibuilding.keycard.key[0]);
  reindex_items(items);
  return items;
}
function ui_get_stall_items(uplayer) {
  let items = [], i = 0;
  let stall = UI.players[uplayer].stall;
  for (const o of stall.items) {
    o.index = i;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: stall.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_string_items(commands) {
  let items = [], i = 0;
  for (const cmd of commands) {
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_submit_items(commands) {
  let items = [], i = 0;
  for (const cmd of commands) {
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i, submit_on_click: true, itemtype: 'submit' };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_top_rumors() {
  let items = [], i = 0;
  for (const o of UI.rumor_top.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `rumor_top`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_trade_items(uplayer) {
  let items = ui_get_market_items(uplayer);
  items = items.concat(ui_get_stall_items(uplayer));
  for (const plname of Z.fen.plorder) {
    if (plname != uplayer) items = items.concat(ui_get_stall_items(plname));
  }
  reindex_items(items);
  return items;
}
function ui_ground_zero() {
  STOPAUS = true;
  uiActivated = aiActivated = false;
  clearTimeouts();
  if (isdef(G) && isdef(G.clear)) G.clear();
  if (isdef(GC) && isdef(GC.clear)) GC.clear();
  TOMan.clear();
  clearMarkers();
  resetUIDs();
  Items = {};
}
function ui_make_card_container(n, dParent, styles = { bg: 'random', padding: 10 }) {
  let id = getUID('u');
  let d = mDiv(dParent, styles, id);
  return d;
}
function ui_make_container(dParent, styles = { bg: 'random', padding: 10 }) {
  let id = getUID('u');
  let d = mDiv(dParent, styles, id);
  return d;
}
function ui_make_deck_container(list, dParent, styles = { bg: 'random', padding: 10 }, get_card_func) {
  let id = getUID('u');
  let d = mDiv(dParent, styles, id);
  if (isEmpty(list)) return d;
  let c = get_card_func(list[0]);
  mContainerSplay(d, 4, c.w, c.h, n, 0);
  return d;
}
function ui_make_hand_container(items, dParent, styles = { bg: 'random', padding: 10 }) {
  let id = getUID('u');
  let d = mDiv(dParent, styles, id);
  if (!isEmpty(items)) {
    let card = items[0];
    mContainerSplay(d, 2, card.w, card.h, items.length, card.ov * card.w);
  }
  return d;
}
function ui_make_player(otree, uname, dParent) {
  let id = getUID('u');
  let bg = otree[uname].color;
  let styles = { bg: bg, fg: 'contrast', w: '100%' };
  d = mDiv(dParent, styles, id, uname);
  return d;
}
function ui_make_random_deck(n = 10) {
  let list = choose(get_keys(Aristocards), n);
  let cont = ui_make_deck_container(n, dTable, { bg: 'random', padding: 4 });
  let items = list.map(x => ari_get_card(x));
  let topmost = ui_add_cards_to_deck_container(cont, items, list);
  return {
    list: list,
    container: cont,
    items: items,
    topmost: topmost,
  };
}
function ui_make_random_hand(n = 1) {
  let list = choose(get_keys(Aristocards), n);
  let cont = ui_make_hand_container(n, dTable, { bg: 'random', padding: 4 });
  let items = list.map(x => ari_get_card(x));
  ui_add_cards_to_hand_container(cont, items, list);
  return {
    list: list,
    container: cont,
    items: items,
  };
}
function ui_make_random_market(n = 1) {
  let cont = ui_make_card_container(n, dTable, { bg: 'random', padding: 4, display: 'flex' });
  let list = choose(get_keys(Aristocards), n);
  let items = list.map(x => ari_get_card(x));
  if (n > 0) ui_add_cards_to_card_container(cont, items, list);
  return {
    list: list,
    container: cont,
    items: items,
  };
}
function ui_make_table() {
  let d = mBy('inner_left_panel'); clearElement(d);
  let dou = mDiv100(d, { display: 'flex' });
  dTable = mDiv(dou, { flex: 5, display: 'flex' });
  return dTable;
}
function ui_player_info(dParent, outerStyles = { dir: 'column' }, innerStyles = {}) {
  let fen = Z.fen;
  if (nundef(outerStyles.display)) outerStyles.display = 'flex';
  mStyle(dParent, outerStyles);
  let items = {};
  let styles = jsCopy(innerStyles); addKeys({ rounding: 10, bg: '#00000050', margin: 4, padding: 4, patop: 12, box: true, 'border-style': 'solid', 'border-width': 6 }, styles);
  let order = get_present_order();
  for (const plname of order) {
    let pl = fen.players[plname];
    let uname = pl.name;
    let imgPath = `../base/assets/users/${uname}.jpg`;
    styles['border-color'] = get_user_color(uname);
    let item = mDivItem(dParent, styles, name2id(uname));
    let d = iDiv(item);
    let picstyle = { w: 50, h: 50, box: true };
    let ucolor = get_user_color(uname);
    if (pl.playmode == 'bot') {
      copyKeys({ rounding: 0, border: `double 6px ${ucolor}` }, picstyle);
    } else {
      copyKeys({ rounding: '50%', border: `solid 2px white` }, picstyle);
    }
    let img = mImage(imgPath, d, picstyle, 'img_person');
    items[uname] = item;
  }
  if (DA.SIMSIM || is_advanced_user()) activate_playerstats(items)
  return items;
}
function ui_present_stats(otree) {
  let players = otree.player_names;
  let items = ui_player_info(players.map(x => otree[x]));
  for (const uname of players) {
    let pl = otree[uname];
    let totals = inno_calc_visible_syms(pl.board, pl.splays);
    pl.totals = totals;
    let item = items[uname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    for (const r in totals) {
      inno_stat_sym(r, totals[r], d, 20);
    }
  }
  return items;
}
function ui_present_table(r, dParent) {
  let g = Session;
  let uitree = r.uiNodes = {};
  if (g.cur_game == 'gPreinno') inno_create_ui_tree(R.root, dParent, r);
  else if (g.cur_game == 'gAristo') ari_create_ui_tree(R.root, dParent, r);
  return uitree;
}
function ui_table_actions_stats() {
  let d = mBy('inner_left_panel'); clearElement(d);
  let dou = mDiv100(d, { display: 'flex' });
  dTable = mDiv(dou, { flex: 5, display: 'flex', overflow: 'auto', position: 'relative' });
  mCenterFlex(dTable, false);
  dTable.animate([{ opacity: 0, transform: 'translateY(50px)' }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: 1000, easing: 'ease' });
  dTop = mDiv(dTable, { bg: '#00000040', fg: 'white', w: '100%' }, 'dOben', 'hallo');
  dTop.innerHTML = '';
  dOben = mDiv(dTable, { bg: '#ffffff40', w: '100%' }, 'dOben', 'hallo');
  dOben.innerHTML = '';
  dActions = mDiv(dOben, { w: '100%' });
  for (let i = 0; i <= 5; i++) {
    window[`dActions${i}`] = mDiv(dActions, { w: '100%' });
  }
  dError = mDiv(dOben, { w: '100%', bg: 'red', fg: 'yellow' });
  dPlayerStats = dRechts = mDiv(dou, { flex: 1 }, 'dRechts', 'hallo');
}
function ui_type_building(b, dParent, styles = {}, path = 'farm', title = '', get_card_func = ari_get_card, separate_lead = false, ishidden = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont);
  let list = b.list;
  let d = mDiv(dParent);
  let items = list.map(x => get_card_func(x));
  reindex_items(items);
  let d_harvest = null;
  if (isdef(b.h)) {
    let keycard = items[0];
    let d = iDiv(keycard);
    mStyle(d, { position: 'relative' });
    d_harvest = mDiv(d, { position: 'absolute', w: 20, h: 20, bg: 'orange', opacity: .5, fg: 'black', top: '45%', left: -10, rounding: '50%', align: 'center' }, null, 'H');
  }
  let d_rumors = null, rumorItems = [];
  if (!isEmpty(b.rumors)) {
    let d = cont;
    mStyle(d, { position: 'relative' });
    d_rumors = mDiv(d, { display: 'flex', gap: 2, position: 'absolute', h: 30, bottom: 0, right: 0 });
    for (const rumor of b.rumors) {
      let dr = mDiv(d_rumors, { h: 24, w: 16, vmargin: 3, align: 'center', bg: 'dimgray', rounding: 2 }, null, 'R');
      rumorItems.push({ div: dr, key: rumor });
    }
  }
  let card = isEmpty(items) ? { w: 1, h: 100, ov: 0 } : items[0];
  let [ov, splay] = separate_lead ? [card.ov * 1.5, 5] : [card.ov, 2];
  mContainerSplay(cardcont, 5, card.w, card.h, items.length, card.ov * 1.5 * card.w);
  ui_add_cards_to_hand_container(cardcont, items, list);
  ui_add_container_title(title, cont, items);
  let uischweine = [];
  for (let i = 1; i < items.length; i++) {
    let item = items[i];
    if (!b.schweine.includes(i)) face_down(item); else add_ui_schwein(item, uischweine);
  }
  return {
    ctype: 'hand',
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    items: items,
    schweine: uischweine,
    harvest: d_harvest,
    rumors: rumorItems,
    keycard: items[0],
  };
}
function ui_type_church(list, dParent, styles = {}, path = 'trick', title = '', get_card_func = ari_get_card, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont, { display: 'flex' });
  let items = [];
  let n = Z.plorder.length;
  let inc = 90;
  let rotation = n % 2 ? 0 : 90;
  for (const ckey of list) {
    let d = mDiv(cardcont, { origin: 'center', transform: `rotate( ${rotation}deg )`, position: 'absolute', left: 8 });
    let c = get_card_func(ckey);
    if (ckey != arrLast(list)) face_down(c);
    mAppend(d, iDiv(c));
    remove_card_shadow(c);
    let item = { card: c, div: d };
    items.push(item);
    rotation += inc;
  }
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    items: items,
  }
}
function ui_type_deck(list, dParent, styles = {}, path = 'deck', title = 'deck', get_card_func = ari_get_card, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont);
  let items = [];
  ensure_ui(list, cardcont, items, get_card_func);
  ui_add_container_title(title, cont, items, show_if_empty);
  function get_topcard() { return isEmpty(list) ? null : items[0]; }
  function get_bottomcard() { return isEmpty(list) ? null : arrLast(items); }
  function ensure_ui(list, cardcont, items, get_card_func) {
    clearElement(cardcont); arrClear(items); if (isEmpty(list)) return;
    let n = Math.min(2, list.length); let ct = get_card_func(list[0]); items.push(ct); if (n > 1) { let cb = get_card_func(arrLast(list)); items.push(cb); }
    mStyle(cardcont, { position: 'relative', wmin: ct.w + 8, hmin: ct.h });
    for (let i = items.length - 1; i >= 0; i--) { let x = items[i]; face_down(x); mAppend(cardcont, iDiv(x)); mStyle(iDiv(x), { position: 'absolute', top: 0, left: 0 }) }
    mText(list.length, iDiv(ct), { position: 'absolute', left: list.length >= 100 ? '10%' : '25%', top: 10, fz: ct.h / 3 });
  }
  return {
    ctype: 'deck',
    container: cont,
    cardcontainer: cardcont,
    items: items,
    list: list,
    title: title,
    path: path,
    func: get_card_func,
    get_topcard: get_topcard,
    get_bottomcard: get_bottomcard,
    get_card_func: get_card_func,
    renew: ensure_ui,
  };
}
function ui_type_hand(list, dParent, styles = {}, path = 'hand', title = 'hand', get_card_func = ari_get_card, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let items = list.map(x => get_card_func(x));
  let cardcont = mDiv(cont);
  let card = isEmpty(items) ? { w: 1, h: Config.ui.card.h, ov: 0 } : items[0];
  let splay = 2;
  mContainerSplay(cardcont, splay, card.w, card.h, items.length, card.ov * card.w);
  ui_add_cards_to_hand_container(cardcont, items, list);
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    ctype: 'hand',
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    splay: splay,
    items: items,
  };
}
function ui_type_item(dParent, item, styles = {}, handler = null, show_key = null) {
  addKeys({ align: 'center', overflow: 'hidden', cursor: 'pointer', rounding: 10, margin: 10, padding: 5, w: 120, wmin: 90, display: 'inline-block', bg: 'random', fg: 'contrast' }, styles);
  let d = mDiv(dParent, styles);
  if (!isEmptyOrWhiteSpace(item.text)) mSpan(d, { family: item.family, fz: 50 }, item.text);
  if (show_key) {
    mSpan(d, { family: 'opensans' }, '<br>' + show_key);
  }
  if (isdef(handler)) d.onclick = handler;
  return d;
}
function ui_type_item_line(dParent, item, styles = {}, handler = null, props = []) {
  let d = mDiv(dParent, styles, `d_${item.key}`); mFlex(d);
  for (const p of props) {
    let family = p == 'text' ? item.family : 'arial';
    let fz = p == 'text' ? 40 : 20;
    mDiv(d, { family: family, fz: fz, bg: styles.bg, fg: styles.fg }, null, item[p]);
  }
  if (isdef(handler)) { d.onclick = handler; d.setAttribute('item', JSON.stringify(item)); }
  return d;
}
function ui_type_lead_hand(list, dParent, styles = {}, path = 'hand', title = 'hand', get_card_func = ari_get_card, show_if_empty = false) {
  let hcard = isdef(styles.h) ? styles.h - 30 : Config.ui.card.h;
  addKeys(get_container_styles(styles), styles);
  let cont = ui_make_container(dParent, styles);
  let items = list.map(x => get_card_func(x, hcard));
  let cardcont = mDiv(cont);
  let card = isEmpty(items) ? { w: 1, h: hcard, ov: 0 } : items[0];
  let splay = 5;
  mContainerSplay(cardcont, splay, card.w, card.h, items.length, card.ov * card.w);
  ui_add_cards_to_hand_container(cardcont, items, list);
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    ctype: 'hand',
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    splay: splay,
    items: items,
  };
}
function ui_type_market(list, dParent, styles = {}, path = 'market', title = 'market', get_card_func = ari_get_card, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont, { display: 'flex', gap: 2 });
  let items = list.map(x => get_card_func(x));
  items.map(x => mAppend(cardcont, iDiv(x)));
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    ctype: 'market',
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    items: items,
  };
}
function ui_type_rank_count(list, dParent, styles, path, title, get_card_func, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont, { display: 'flex' });
  let items = [];
  for (const o of list) {
    let d = mDiv(cardcont, { display: 'flex', dir: 'c', padding: 1, fz: 12, align: 'center', position: 'relative' });
    let c = get_card_func(o.key);
    mAppend(d, iDiv(c));
    remove_card_shadow(c);
    d.innerHTML += `<span style="font-weight:bold">${o.count}</span>`;
    let item = { card: c, count: o.count, div: d };
    items.push(item);
  }
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    items: items,
  }
}
function ui_type_sym_text_line(dParent, item, styles = {}, handler = null) {
  let d = mDiv(dParent, styles, `d_${item.key}`); mFlex(d);
  let sym = valf(item.sym, Syms[item.key]);
  mDiv(d, { family: sym.family, fz: 40 }, null, sym.text);
  mDiv(d, { family: 'opensans', fz: 20 }, null, item.text);
  if (isdef(handler)) { d.onclick = handler; d.setAttribute('item', JSON.stringify(item)); }
  return d;
}
function ui_type_tile(ga, d, styles, classes) {
  let item = {};
  copyKeys(ga, item);
  let [sym, bg, id] = [Syms[ga.logo], ga.color, getUID()];
  item.id = id; item.isOpen = true;
  function open() {
    let item = Items[id];
    if (item.isOpen) return; item.isOpen = true;
    let d1 = iDiv(item); iClear(d1);
    let d2 = mDiv(d1, { position: 'absolute', top: 2, left: 2, display: 'flex', gap: 2 });
    let sz = 20;
    mDiv(d2, { fz: sz, family: sym.family, 'line-height': sz }, null, sym.text);
    mDiv(d2, { fz: sz - 5, 'line-height': sz }, null, item.friendly);
    console.log('item.name', item.name)
    let f = window[item.name + '_open']; if (isdef(f)) f(item);
  }
  function close(trigger = true) {
    let item = Items[id];
    if (!item.isOpen) return; item.isOpen = false;
    let d1 = iDiv(item); iClear(d1);
    mDiv(d1, { fz: 50, family: sym.family, 'line-height': 55 }, null, sym.text);
    mLinebreak(d1, 4);
    mDiv(d1, { fz: 18, align: 'center' }, null, item.friendly);
    if (!trigger) return;
    let f = window[item.name + '_close']; if (isdef(f)) f(item);
  }
  function toggle(ev) {
    evNoBubble(ev);
    let item = Items[id];
    if (item.isOpen) close(); else open();
  }
  let d1 = mDiv(d, { cursor: 'pointer', 'user-select': 'none', rounding: 10, margin: 10, vpadding: 15, hmin: 90, wmin: 140, bg: bg, position: 'relative' }, id, null, 'hop1');
  d1.setAttribute('name', ga.name);
  mCenterFlex(d1);
  iReg(item, { div: d1 });
  d1.onclick = toggle;
  close(false);
  return {
    item: item,
    open: open,
    close: close,
    toggle: toggle,
  }
}
function uid() {
  UID += 1;
  return 'a' + UID;
}
function uidHelpers() {
  UIDHelpers += 1;
  return 'id' + UIDHelpers;
}
function uiGetContact(row, msgs = {}) {
  let image = get_image_path(row);
  let mydata = `
      <div class='contact' style='position:relative;text-align:center;margin-bottom:18px;' username='${row.name}' onclick='start_chat(event)'>
        <img src='${image}' draggable='true' ondragstart='drag(event)' class='img_person sz100' style='margin:0;'/>
        <br>${row.name}`;
  if (isdef(msgs[row.username])) {
    mydata += `<div style='width:20px;height:20px;border-radius:50%;background-color:orange;color:white;position:absolute;left:0px;top:0px;'>` + msgs[row.username] + "</div>";
  }
  mydata += "</div>";
  return mydata;
}
function uiGetContacts(myusers, msgs) {
  mydata = '';
  for (const r of myusers) {
    row = r;
    mydata += uiGetContact(row, msgs);
  }
  return mydata;
}
function uiGetContactStylesAndStart() {
  let mydata = `
  <style>
    @keyframes appear{
      0%{opacity:0;transform: translateY(50px)}
      100%{opacity:1;transform: translateY(0px)}
     }
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div style="text-align: center; animation: appear 1s ease both">
  `;
  return mydata;
}
function uiGetGame(gi, tables = []) {
  let sym = Syms[gi.logo];
  let bg = getColorDictColor(gi.color);
  let gname = gi.id;
  let uname = Session.cur_user;
  let color = null, id = getUID();
  if (!isEmpty(tables)) {
    let t = tables[0];
    let table_status = t.status;
    let my_status = t.player_status;
    let have_another_move = my_status == 'joined' || my_status == 'lamov';
    color = have_another_move ? 'green'
      : t.player_status == 'join' ? 'orange'
        : t.host == uname && t.status == 'ready' ? 'yellow'
          : table_status == 'show' || t.status == 'seen' ? 'blue'
            : t.status == 'ending' ? 'red' : 'black';
    id = `rk_${t.id}`;
  }
  return `
  <div onclick="onclick_game_in_games_menu(event)" gamename=${gi.id} style='cursor:pointer;border-radius:10px;margin:10px;padding:5px;padding-top:15px;width:120px;height:90px;display:inline-block;background:${bg};position:relative;'>
  ${nundef(color) ? '' : runderkreis(color, id)}
  <span style='font-size:50px;font-family:${sym.family}'>${sym.text}</span><br>${gi.friendly}</div>
  `;
}
function uiGetGames(mygames, tables) {
  mydata = '';
  for (const r of mygames) {
    row = r;
    mydata += uiGetGame(row, tables[r.id]);
  }
  return mydata;
}
function uiGetGamesStylesAndStart() {
  let mydata = `
  <style>
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div id='game_menu' style="text-align: center; animation: appear 1s ease both">
  `;
  return mydata;
}
function uiGetLoginNew(row, msgs = {}) {
  let image = get_image_path(row);
  let mydata = `
      <div class='contact' style='position:relative;text-align:center;margin-bottom:18px;' username='${row.name}' 
        onclick='onclick_user_login_new(event)'>
        <img src='${image}' draggable='true' ondragstart='drag(event)' class='img_person sz100' style='margin:0;'/>
        <br>${row.name}`;
  if (isdef(msgs[row.username])) {
    mydata += `<div style='width:20px;height:20px;border-radius:50%;background-color:orange;color:white;position:absolute;left:0px;top:0px;'>` + msgs[row.username] + "</div>";
  }
  mydata += "</div>";
  return mydata;
}
function uiGetLoginNewList(myusers, msgs) {
  mydata = '';
  for (const r of myusers) {
    row = r;
    mydata += uiGetLoginNew(row, msgs);
  }
  return mydata;
}
function uiGetLoginNewStylesAndStart() {
  let mydata = `
  <style>
    @keyframes appear{
      0%{opacity:0;transform: translateY(50px)}
      100%{opacity:1;transform: translateY(0px)}
     }
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div style="text-align: center; animation: appear 1s ease both">
  `;
  return mydata;
}
function uiNodesToUiTree(R) {
  let uiTree = {};
  for (const k in R.uiNodes) {
    let n = R.uiNodes[k];
    uiTree[k] = jsCopyMinus(n, 'act', 'ui', 'defParams', 'params');
  }
  return uiTree;
}
function unCamel(s) { return separateAtCapitals(s); }
function unCamelCase(s) { return separateAtCapitals(s); }
function uncheckAvailable(i) {
  id = getidAvailable(i); document.getElementById(id).checked = false;
}
function uncheckPlayer(i) {
  id = getidNum(i); document.getElementById(id).checked = false;
}
function uncollapseAll() {
  let coll = document.getElementsByClassName("collapsible");
  for (let i = 0; i < coll.length; i++) {
    let elem = coll[i];
    if (!isVisible(getLinkContainerId(elem.id))) fireClick(elem);
  }
}
function unfillChar(inp) { unfillCharInput(inp); }
function unfillCharInput(inp) {
  let d = iDiv(inp);
  d.innerHTML = '_';
  mClass(d, 'blink');
  inp.isBlank = true;
}
function unfillWord(winp) { winp.charInputs.map(x => unfillCharInput(x)); }
function unfocusOnEnter(ev) {
  if (ev.key === 'Enter') {
    ev.preventDefault();
    mBy('dummy').focus();
  }
}
function unfreezeUI() {
  if (!frozen) return;
  frozen = false;
  hide('tempFreezer');
}
function unhighAll(oid) { mapSafe('unhigh', getVisuals, oid); }
function unhighAux(oid) { mapSafe('unhigh', getAuxVisuals, oid); }
function unhighlightBoat() {
  if (boatHighlighted) {
    unhighlightMsAndRelatives(null, boatHighlighted);
    closeInfoboxesForBoatOids(boatHighlighted);
    boatHighlighted = null;
  }
}
function unhighlightContentIds(b) {
  let s = b.innerHTML;
  let ids = s.split(/[ ,:;]+/);
  for (const id of ids) {
    if (id == '_') continue;
    let msList = getVisuals(id);
    if (!msList) continue;
    for (const ms of msList) ms.unhigh();
  }
}
function unhighlightMsAndRelatives(ev, mobj, partName) {
  let id = mobj.id;
  mobj.unhigh(partName);
  let relativeIds = id2uids[id];
  if (nundef(relativeIds)) return;
  for (const idRel of relativeIds) {
    let msRel = UIS[idRel];
    msRel.unhigh('title');
  }
}
function unhighMain(oid) { mapSafe('unhigh', getVisual, oid); }
function unhighSelfAndRelatives(uid, R) {
  for (const oid of R.uid2oids[uid]) {
    for (const uid1 of R.oid2uids[oid]) {
      let ui = R.getUI(uid1);
      mUnhigh(ui);
    }
  }
  let n = R.uiNodes[uid];
  if (n.potentialOverlap) {
    let ui = R.getUI(uid);
    sendToBack(ui);
  }
}
function uniformSizeToContent(uid) {
  let n = R.uiNodes[uid];
  if (nundef(n.children)) return { w: 0, h: 0 }
  parentPadding = isdef(n.params.paddingAroundChildren) ? n.params.paddingAroundChildren : DEFS.defaultPadding;
  childMargin = isdef(n.params.gapBetweenChildren) ? n.params.gapBetweenChildren : DEFS.defaultGap;
  let or = n.params.orientation;
  let rows = cols = 1;
  if (or == 'w') { rows = n.params.rows; cols = n.params.cols; }
  let bl = n.params.baseline;
  let [y0, wTitle] = calcParentContentYOffsetAndWidth(n, parentPadding);
  let children = n.children.map(x => R.uiNodes[x]);
  if (or == 'w') {
    let wchi = Math.max(...children.map(x => x.size.w));
    let hchi = Math.max(...children.map(x => x.size.h));
    let wpar = 2 * parentPadding + wchi * cols + (cols - 1) * childMargin;
    let hpar = y0 + parentPadding + hchi * rows + (rows - 1) * childMargin;
    let xoff = (wTitle > wpar) ? (wTitle - wpar) / 2 : 0;
    let x = xoff + parentPadding;
    let y = y0;
    let i = 0;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        let ch = children[i];
        i += 1;
        ch.params.size = { w: wchi, h: hchi };
        ch.params.pos = { x: x, y: y };
        x += wchi + childMargin;
        setFixedSizeAndPos(ch);
      }
      x = xoff + parentPadding;
      y += hchi + childMargin;
    }
    return { w: wpar, h: hpar };
  }
  let axMain, ax2;
  if (or == 'v') { axMain = 'h'; ax2 = 'w'; }
  else if (or == 'h') { axMain = 'w'; ax2 = 'h'; }
  let ax2Max = Math.max(...children.map(x => x.size[ax2]));
  let axMainSum = children.reduce((a, b) => a + (b.size[axMain] || 0), 0);
  axMainSum += childMargin * (children.length - 1);
  let wmax = (or == 'v' ? ax2Max : axMainSum);
  let xoff = 0;
  if (wTitle > wmax) xoff = (wTitle - wmax) / 2;
  let x0 = parentPadding + xoff;
  let x = x0;
  let y = y0;
  let lastChild = R.uiNodes[n.children[n.children.length - 1]];
  for (const n1 of children) {
    if (or == 'v') {
      switch (bl) {
        case 'start': x = x0; break;
        case 'end': x = x0 + ax2Max - n1.size[ax2]; break;
        case 'centered': x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
        case 'stretch':
          x = x0;
          if (n1.size.w < ax2Max) {
            n1.size.w = ax2Max;
            n1.ui.style.minWidth = n1.size.w + 'px';
          }
          break;
        default: x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
      }
      n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
      y += n1.size[axMain];
      if (n1 != lastChild) y += childMargin;
    } else {
      switch (bl) {
        case 'start': y = y0; break;
        case 'end': y = y0 + ax2Max - n1.size[ax2]; break;
        case 'centered': y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
        case 'stretch':
          y = y0;
          if (n1.size.h < ax2Max) {
            n1.size.h = ax2Max;
            n1.ui.style.minHeight = n1.size.h + 'px';
          }
          break;
        default: y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
      }
      n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
      x += n1.size.w;
      if (n1 != lastChild) x += childMargin;
    }
    n1.ui.style.left = n1.pos.x + 'px';
    n1.ui.style.top = n1.pos.y + 'px';
  }
  let wParent, hParent;
  if (or == 'h') {
    wParent = Math.max(wTitle + parentPadding * 2, x + parentPadding);
    hParent = y0 + ax2Max + parentPadding;
  } else {
    wParent = Math.max(wTitle + parentPadding * 2, ax2Max + 2 * x0);
    hParent = y0 + axMainSum + parentPadding;
  }
  return { w: wParent, h: hParent };
}
function union(lst1, lst2) {
  return [...new Set([...lst1, ...lst2])];
}
function uniqueFirstLetters(arr) {
  let res = [];
  for (const s of arr) {
    if (s.length > 0) {
      addIf_dep(s[0], res);
    }
  }
  return res;
}
function unitTest8() {
  if (execOptions.activatedTests.includes('8699')) console.log(...arguments);
}
function unitTestAutoplay() {
  if (execOptions.activatedTests.includes('autoplay')) console.log(...arguments);
}
function unitTestBattle() {
  if (execOptions.activatedTests.includes('battle')) console.log(...arguments);
}
function unitTestBuildUnit() {
  if (execOptions.activatedTests.includes('buildUnit')) console.log(...arguments);
}
function unitTestCard() {
  if (execOptions.activatedTests.includes('card')) console.log(...arguments);
}
function unitTestCards() {
  if (execOptions.activatedTests.includes('cards')) console.log(...arguments);
}
function unitTestCardsNew() {
  if (execOptions.activatedTests.includes('cardsNew')) console.log(...arguments);
}
function unitTestChoice() {
  if (execOptions.activatedTests.includes('choice')) console.log(...arguments);
}
function unitTestChoicemin() {
  if (execOptions.activatedTests.includes('choice') || execOptions.activatedTests.includes('choicemin')) console.log(...arguments);
}
function unitTestCombat() {
  if (execOptions.activatedTests.includes('combat')) console.log(...arguments);
}
function unitTestCombatStage() {
  if (execOptions.activatedTests.includes('combatStage')) console.log(...arguments);
}
function unitTestConflict() {
  if (execOptions.activatedTests.includes('conflicts')) console.log(...arguments);
}
function unitTestControl() {
  if (execOptions.activatedTests.includes('control')) console.log(...arguments);
}
function unitTestConvoy() {
  if (execOptions.activatedTests.includes('convoy')) console.log(...arguments);
}
function unitTestDecision() {
  if (execOptions.activatedTests.includes('decision')) console.log(...arguments);
}
function unitTestDiplomacy() {
  if (execOptions.activatedTests.includes('diplomacy')) console.log(...arguments);
}
function unitTestFilter() {
  if (execOptions.activatedTests.includes('filter')) console.log(...arguments);
}
function unitTestFilterByType() {
  if (execOptions.activatedTests.includes('filterByType')) console.log(...arguments);
}
function unitTestFilterNation() {
  if (execOptions.activatedTests.includes('filterNation')) console.log(...arguments);
}
function unitTestGameloop() {
  if (execOptions.activatedTests.includes('gameloop')) console.log(...arguments);
}
function unitTestHover() {
  if (execOptions.activatedTests.includes('hover')) console.log(...arguments);
}
function unitTestInit() {
  if (execOptions.activatedTests.includes('init')) console.log(...arguments);
}
function unitTestLoad() {
  if (execOptions.activatedTests.includes('load')) console.log(...arguments);
}
function unitTestLog() {
  if (execOptions.activatedTests.includes('log')) console.log(...arguments);
}
function unitTestMap() {
  if (execOptions.activatedTests.includes('map')) console.log(...arguments);
}
function unitTestMatch() {
  if (execOptions.activatedTests.includes('match')) console.log(...arguments);
}
function unitTestMirrorBattle() {
  if (execOptions.activatedTests.includes('mirror')) console.log(...arguments);
}
function unitTestMovement() {
  if (execOptions.activatedTests.includes('movement')) console.log(...arguments);
}
function unitTestMoving() {
  if (execOptions.activatedTests.includes('moving')) console.log(...arguments);
}
function unitTestMS() {
  if (execOptions.activatedTests.includes('ms')) console.log(...arguments);
}
function unitTestPlayer() {
  if (execOptions.activatedTests.includes('player')) console.log(...arguments);
}
function unitTestRandom() {
  if (execOptions.activatedTests.includes('random')) console.log(...arguments);
}
function unitTestRemove() {
  if (execOptions.activatedTests.includes('remove')) console.log(...arguments);
}
function unitTestRemoved() {
  if (execOptions.activatedTests.includes('removed')) console.log(...arguments);
}
function unitTestRemovedCheck(data) {
  return execOptions.activatedTests.includes('removed') && 'removed' in data && !empty(Object.keys(data.removed));
}
function unitTestRequest() {
  if (execOptions.activatedTests.includes('request')) console.log(...arguments);
}
function unitTestResnail() {
  if (execOptions.activatedTests.includes('resnail')) console.log(...arguments);
}
function unitTestResponse() {
  if (execOptions.activatedTests.includes('response')) console.log(...arguments);
}
function unitTestSave() {
  if (execOptions.activatedTests.includes('save')) console.log(...arguments);
}
function unitTestScenario() {
  if (execOptions.activatedTests.includes('scenario')) console.log(...arguments);
}
function unitTestScenarioMin() {
  if (execOptions.activatedTests.includes('scenarioMin')) console.log(...arguments);
}
function unitTestScenarioWar() {
  if (execOptions.activatedTests.includes('scenarioWar')) console.log(...arguments);
}
function unitTestSeason() {
  if (execOptions.activatedTests.includes('season')) console.log(...arguments);
}
function unitTestSender() {
  if (execOptions.activatedTests.includes('sender')) console.log(...arguments);
}
function unitTestServer() {
  if (execOptions.activatedTests.includes('server')) console.log(...arguments);
}
function unitTestSkip() {
  if (execOptions.activatedTests.includes('skip')) console.log(...arguments);
}
function unitTestStage() {
  if (execOptions.activatedTests.includes('stage')) console.log(...arguments);
}
function unitTestStrategy() {
  if (execOptions.activatedTests.includes('strategy')) console.log(...arguments);
}
function unitTestUnits() {
  if (execOptions.activatedTests.includes('units')) console.log(...arguments);
}
function unitTestUnitVisibility() {
  if (execOptions.activatedTests.includes('visible')) console.log(...arguments);
}
function unitTestUpgradeUnit() {
  if (execOptions.activatedTests.includes('upgradeUnit')) console.log(...arguments);
}
function unitTimeUp() { return (Settings.minutesPerUnit * 60000 - getTimeElapsed()) <= 0; }
function unlink(id) {
  let oids = id2oids[id];
  let uids = id2uids[id];
  if (isdef(uids)) for (const uid of uids) removeInPlace(id2uids[uid], id);
  if (isdef(oids)) for (const oid of oids) removeInPlace(oid2ids[oid], id);
  delete id2uids[id];
  delete id2oids[id];
}
function unpack_table(table) {
  for (const k of ['players', 'fen', 'options', 'scoring']) {
    let val = table[k];
    if (isdef(table[k])) table[k] = if_stringified(val); if (nundef(table[k])) table[k] = {};
  }
  if (isdef(table.modified)) { table.modified = Number(table.modified); table.timestamp = new Date(table.modified); table.stime = stringBeforeLast(table.timestamp.toString(), 'G').trim(); }
  assertion(isdef(window[table.game]), 'game function for ' + table.game + ' not defined in window');
  if (isdef(table.game)) { table.func = window[table.game](); }
  if (isdef(table.options.mode)) { table.mode = table.options.mode; }
  delete table.action; delete table.expected;
  return table;
}
function untie_card(card) {
  remove_from_selection(card);
  clear_selection();
  let oldgroupid = card.groupid;
  if (isdef(oldgroupid)) delete card.owner;
  let oldgroup = Items[oldgroupid];
  let oldindex = isdef(oldgroup) ? oldgroup.ids.indexOf(card.id) : null;
  if (isdef(oldgroup)) removeInPlace(oldgroup.ids, card.id);
  return [oldgroup, oldindex];
}
function update_car(canvas, item) {
  let di = { ArrowUp: canvas.math ? 90 : 270, ArrowDown: canvas.math ? 270 : 90, ArrowLeft: 180, ArrowRight: 0 };
  for (const key in di) {
    if (is_key_down(key)) {
      item.v.a = di[key];
      update_position(item);
      return true;
    }
  }
  return false;
}
function update_cur_table(obj, color) {
  let t = Session.cur_table;
  let tnew = obj.table;
  if (isdef(obj.player_record)) copyKeys(obj.player_record, tnew);
  copyKeys(tnew, t);
  if (isdef(color)) {
    let d = mBy(`rk_${obj.table.id}`);
    if (isdef(d)) mStyle(d, { bg: color });
  }
}
function update_current_table() {
  let o = Serverdata.table;
  assertion(isdef(U), 'NO USER LOGGED IN WHEN GETTING TABLE FROM SERVER!!!!!!!!!!!!!!!!!!!!', U, o);
  if (nundef(Z) || nundef(Z.prev)) Z = { prev: {} };
  assertion(isdef(Z), 'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ', Z);
  set_user(U.name);
  for (const wichtig of ['notes', 'uplayer', 'friendly', 'step', 'round', 'phase', 'stage', 'timestamp', 'modified', 'stime', 'mode', 'scoring']) {
    if (isdef(Z[wichtig])) Z.prev[wichtig] = jsCopy(Z[wichtig]);
  }
  Z.prev.turn = Clientdata.last_turn;
  copyKeys(o, Z, { uname: true });
  let [mode, turn, uname, plorder, fen, host] = [Z.mode, Z.turn, Z.uname, Z.plorder, Z.fen, Z.host];
  assertion(!isEmpty(turn), 'turn empty!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', turn, fen, plorder);
  Z.role = !plorder.includes(uname) ? 'spectator' : turn.includes(uname) ? 'active' : 'inactive';
  if (Z.game == 'fritz' && Z.role == 'spectator' && isdef(Z.fen.roundorder) && Z.fen.roundorder.includes(uname)) {
    Z.role = 'inactive';
  }
  let upl = Z.role == 'active' ? uname : turn[0];
  if (mode == 'hotseat' && turn.length > 1) { let next = get_next_human_player(Z.prev.uplayer); if (next) upl = next; }
  if (mode == 'multi' && Z.role == 'inactive' && (uname != host || is_human_player(upl))) {
    upl = uname;
  }
  set_player(upl, fen);
  let [uplayer, pl] = [Z.uplayer, Z.pl];
  Z.playmode = pl.playmode;
  if (Z.playmode != 'human') Z.strategy = pl.strategy;
  let [friendly, modified] = [Z.friendly, Z.modified];
  Z.skip_presentation = !FORCE_REDRAW && friendly == Z.prev.friendly && modified <= Z.prev.modified && uplayer == Z.prev.uplayer;
  FORCE_REDRAW = false;
  if (Z.skip_presentation) {
    show_status(`nothing new in ${Z.friendly}`);
    const STOP_POLLING_AFTER = 30000;
    if (nundef(DA.noshow)) DA.noshow = 1; else DA.noshow++; if (DA.noshow >= STOP_POLLING_AFTER) onclick_stoppolling();
    autopoll();
  } else {
    DA.noshow = 0;
    delete DA.sperre;
    clear_timeouts();
  }
}
function update_db_user_from_pl_options(fen, game) {
  let parts = fen.split(',');
  for (const p of parts) {
    let [name, startlevel, lang] = p.split(':');
    startlevel = Number(startlevel);
    set_startlevel(name, game, startlevel);
    set_preferred_lang(name, lang);
  }
}
function update_draw_items() {
  for (const item of get_values(Items)) {
    if (isdef(item.update)) item.update(item);
    if (isdef(item.draw)) item.draw(item);
  }
}
function update_func(canvas, item) {
  let [cv, ctx, ia, ib, ifunc, axes] = [canvas.cv, canvas.cx, item.ia, item.ib, item.ifunc, item.axes];
  cClear(cv, ctx);
  showAxes(ctx, axes);
  let [la, lb, lf] = [[1, 2, 3, 4, 5, 5, 5, 4, 3, 2], [0, .5, 1, 1.5, 2, 2.5, 2.5, 2.5, 2, 1.5, 1, .5], ['sin', 'cos']];
  let [a, b, f] = [la[ia], lb[ib], lf[ifunc]];
  [item.ia, item.ib, item.ifunc] = [(ia + 1) % la.length, (ib + 1) % lb.length, (ifunc + 1) % lf.length];
  funGraph(ctx, axes, x => Math[f](a * x), "rgb(11,153,11)", 1);
  return false;
}
function update_game_status(players) {
  let d = dTitle;
  clearElement(d);
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname in players) {
    let pl = players[plname];
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='${pl.imgPath}' style="display:block" class='img_person' width=50 height=50>${pl.score}`);
  }
}
function update_game_values() {
  let game = Session.cur_game;
  let uname = Session.cur_user;
  let g = Session;
  let basevals = lookup(DB.games, [game]); if (basevals) copyKeys(basevals, g);
  for (const k in g.options) { g[k] = get_game_or_user_option(g, k); }
  let uservals = lookup(DB.users, [uname, 'games', game]); if (uservals) copyKeys(uservals, g);
  let levels = lookup(DB.games, [game, 'levels']);
  g.maxlevel = valf(get_keys(levels).length, 0) - 1;
  g.color = getColorDictColor(g.color);
  let level = g.level = nundef(g.level_setting) || g.level_setting == 'player' ? valf(g.startlevel, g.def_startlevel)
    : g.level_setting == 'min' ? 0 : g.level_setting == 'max' ? g.maxlevel : g.def_startlevel;
  if (levels) copyKeys(levels[level], g);
  delete g.levels;
  return g;
}
function update_language_choices(g) {
  let langs = g.availableLanguages;
  let language_holder = mBy('language_holder');
  clearElement(language_holder);
  let friendly = { E: 'english', D: 'german', S: 'spanish', F: 'french', C: 'mandarin' };
  if (isdef(language_holder) && isdef(langs) && langs.length > 1) {
    let avail = toLetterList(langs);
    let labels = avail.map(x => friendly[x]);
    let esel = mSelect(language_holder, avail, friendly, valf(g.lang, 'E'), (ev) => {
      let sel = ev.target;
      let val = sel.value;
      console.log('selected language', val)
      set_language(val, false);
    });
    mClass(esel.firstChild, 'statusselect');
  } else if (isdef(language_holder)) {
    mDiv(language_holder, { patop: 6 }, null, friendly[g.lang], 'statusselect');
  }
}
function update_move(canvas, item) {
  item.y += 1;
  item.y = cycle(item.y, canvas.miny, canvas.maxy);
  return true;
}
function update_my_score(inc) {
  let me = Session.cur_players[Session.cur_user];
  me.score += inc;
  return me.score;
}
function update_otree_from_ui(otree, objects) {
  for (const k in objects) {
    otree[k] = objects[k].list;
  }
  qanim();
}
function update_position(item) {
  let [a1, a2] = [item.a, item.v.a];
  let diff = Math.abs(a2 - a1);
  let inc = valf(item.turn_inc, 0);
  if (inc && diff > inc) {
    let cclock = is_turn_counter_clockwise(a1, a2);
    if (cclock) inc = -inc;
    let anew = a1 + inc;
    anew = (anew + 360) % 360;
    item.a = anew;
  } else {
    item.a = a2 % 360;
    let angle = toRadian(item.a);
    item.x += Math.cos(angle) * item.v.mag;
    item.y += Math.sin(angle) * item.v.mag;
  }
}
function update_session(obj) {
  for (const k in obj) { if (isdef(Session[k])) copyKeys(obj[k], Session[k]); else Session[k] = obj[k]; }
  if (isdef(obj.table)) {
    Session.cur_table = Session.table;
    Session.cur_funcs = window[Session.cur_game]();
    if (!isEmpty(obj.playerdata)) make_players(Session.table.players);
    console.assert(isdef(Session.cur_user) && Session.cur_game == Session.table.game && Session.cur_tid == Session.table.id, "SESSION MISMATCH IN GAME_OPEN_FOR_MOVE!!!!!!!!!!!!!!!!!!!!!");
  }
  if (isdef(obj.playerdata)) {
    let o = Session.cur_players;
    for (const rec of obj.playerdata) {
      if (rec.state == 'null') rec.state = null;
      copyKeys(rec, o[rec.name]);
    }
  }
}
function update_settings() {
  for (const k in settings) {
    let lower = k.toLowerCase();
    let inp = mBy(`i_${lower}`);
    if (isdef(inp)) {
      let value = Number(inp.innerHTML);
      if (isNumber(value)) settings[k] = value;
    }
  }
  socket.emit('settings', JSON.stringify(settings));
}
function update_table() {
  assertion(isdef(U), 'NO USER LOGGED IN WHEN GETTING TABLE FROM SERVER!!!!!!!!!!!!!!!!!!!!', U);
  if (nundef(Z) || nundef(Z.prev)) Z = { prev: {} };
  for (const wichtig of ['playerdata', 'notes', 'uplayer', 'uname', 'friendly', 'step', 'round', 'phase', 'stage', 'timestamp', 'modified', 'stime', 'mode', 'scoring']) {
    if (isdef(Z[wichtig])) Z.prev[wichtig] = jsCopy(Z[wichtig]);
  }
  Z.prev.turn = Clientdata.last_turn = Clientdata.this_turn;
  copyKeys(Serverdata, Z);
  if (isdef(Serverdata.table)) { copyKeys(Serverdata.table, Z); Z.playerlist = Z.players; copyKeys(Serverdata.table.fen, Z); }
  assertion(isdef(Z.fen), 'no fen in Z bei cmd=table or startgame!!!', Serverdata);
  Clientdata.this_turn = Z.turn;
  set_user(U.name);
  assertion(!isEmpty(Z.turn), 'turn empty!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', Z.turn);
  let fen = Z.fen;
  Z.role = !is_playing(Z.uname, fen) ? 'spectator' : fen.turn.includes(Z.uname) ? 'active' : 'inactive';
  let [uname, turn, mode, host] = [Z.uname, fen.turn, Z.mode, Z.host];
  let upl = Z.role == 'active' ? uname : turn[0];
  if (mode == 'hotseat' && turn.length > 1) { let next = get_next_human_player(Z.prev.uplayer); if (next) upl = next; }
  if (mode == 'multi' && Z.role == 'inactive' && (uname != host || is_human_player(upl))) { upl = uname; }
  set_player(upl, fen);
  let pl = Z.pl;
  Z.playmode = pl.playmode;
  Z.strategy = uname == pl.name ? valf(Clientdata.strategy, pl.strategy) : pl.strategy;
  let [uplayer, friendly, modified] = [Z.uplayer, Z.friendly, Z.modified];
  Z.uplayer_data = firstCond(Z.playerdata, x => x.name == Z.uplayer);
  let sametable = !FORCE_REDRAW && friendly == Z.prev.friendly && modified <= Z.prev.modified && uplayer == Z.prev.uplayer;
  let sameplayerdata = isEmpty(Z.playerdata_changed_for);
  let myplayerdatachanged = Z.playerdata_changed_for.includes(Z.uplayer);
  let specialcase = !i_am_host() && !i_am_acting_host() && !i_am_trigger() && !myplayerdatachanged;
  Z.skip_presentation = sametable && (sameplayerdata || specialcase);
  if (DA.TEST0 && (!sametable || !sameplayerdata)) {
    console.log('======>Z.skip_presentation', Z.skip_presentation, '\nplayerdata_changed_for', Z.playerdata_changed_for);
    console.log('_______ *** THE END *** ___________')
  }
  FORCE_REDRAW = false;
}
function update_table_options_for_user(uname, table_options, game) {
  let lang = get_preferred_lang(uname);
  update_db_user_from_pl_options(table_options, game);
  let lang2 = get_preferred_lang(uname);
  if (lang != lang2) get_dictionary();
}
function updateBindings(supd, R) {
  for (const oid in supd) {
    for (const upd of supd[oid]) {
      let ukind = upd.ukind;
      if (ukind == 'valueChange') {
        let propUpdated = upd.prop;
        let skeys = R.getR(oid);
        let akku = [];
        recCollect(R.ROOT, x => { return x.oid == oid }, akku, true);
        for (const n of akku) {
          updateNode(n, upd, R);
        }
      }
    }
  }
}
function updateBubbleColors(e) {
  const w = window.innerWidth / 255;
  const h = window.innerHeight / 255;
  const x = parseInt(e.pageX / w, 10);
  const y = parseInt(e.pageY / h, 10);
  const r = x;
  const g = (y - 255) * -1;
  const b = x <= y ? y - x : 0;
  container.style.setProperty('--colorEnd', `rgb(${r},${g},${b})`);
}
function updateCollections() {
  S.settings.collectionTypes = { playerProps: ['hand', 'devcards'], objectProps: ['neutral'] };
  _updateCollections(G.playersUpdated, G.playersAugmented, S.settings.collectionTypes.playerProps);
  _updateCollections(G.tableUpdated, G.table, S.settings.collectionTypes.objectProps);
}
function updateColors(o) {
  let pal = S.pals[o.iPalette];
  let bg = pal[o.ipal];
  o.setBg(bg);
  if (o.strInfo && o.strInfo.ipals) {
    let ipals = o.strInfo.ipals;
    for (const id of o.ids) {
      let o = getVisual(id);
      if (o.isManual) continue;
      let info = o.memInfo;
      if (info && info.isPal) {
        let ipal = ipals[info.memType == 'field' ? 0 : info.memType == 'corner' ? 1 : 2];
        o.setBg(pal[ipal], false);
      }
    }
  }
}
function updateCreatedBindings(sCreated, R) {
  for (const oid in sCreated) {
    R.addObject(oid, o);
    for (const sp in R.getSpec()) {
    }
    for (const upd of sCreated[oid]) {
      let ukind = upd.ukind;
      if (ukind == 'valueChange') {
        let propUpdated = upd.prop;
        let skeys = R.getR(oid);
        let akku = [];
        recCollect(R.ROOT, x => { return x.oid == oid }, akku, true);
        for (const n of akku) {
          updateNode(n, upd, R);
        }
      }
    }
  }
}
function UpdateDOMStats() {
  var scoreText = "Score: " + (domUpdate_score / 100).toFixed(2);
  if (Math.abs(domUpdate_score) > MATE - MAXDEPTH) {
    scoreText = "Score: " + "Mate In " + (MATE - Math.abs(domUpdate_score)) + " moves";
  }
  $("#OrderingOut").text("Ordering: " + domUpdate_ordering + "%");
  $("#DepthOut").text("Depth: " + domUpdate_depth);
  $("#ScoreOut").text(scoreText);
  $("#NodesOut").text("Nodes: " + domUpdate_nodes);
  $("#TimeOut").text("Time: " + (($.now() - srch_start) / 1000).toFixed(1) + "s");
}
function updateGameArea() {
  var x, height, gap, minHeight, maxHeight, minGap, maxGap;
  for (i = 0; i < obstacles.length; i += 1) {
    if (meme.crashWith(obstacles[i])) {
      return;
    }
  }
  myGameArea.clear();
  myGameArea.frameNo += 1;
  if (myGameArea.frameNo == 1 || everyinterval(150)) {
    x = myGameArea.canvas.width;
    minHeight = 20;
    maxHeight = 200;
    height = Math.floor(Math.random() * (maxHeight - minHeight + 1) + minHeight);
    minGap = 50;
    maxGap = 200;
    gap = Math.floor(Math.random() * (maxGap - minGap + 1) + minGap);
    obstacles.push(new component(10, height, 'green', x, 0));
    obstacles.push(new component(10, x - height - gap, 'green', x, height + gap));
  }
  for (i = 0; i < obstacles.length; i += 1) {
    obstacles[i].x += -1;
    obstacles[i].draw();
  }
  score.text = 'SCORE: ' + myGameArea.frameNo;
  score.draw();
  meme.newPos();
  meme.draw();
}
function updateGamename(gamename) {
  currentGamename = gamename;
  let gi = allGames[gamename];
  currentPlayersById = {};
  plidByIndex = gi.player_names;
  for (const plid of gi.player_names) {
    currentPlayersById[plid] = {};
  }
  numPlayersMin = arrMin(gi.num_players);
  numPlayersMax = arrMax(gi.num_players);
}
function updateGamenameUi(id, color) {
  let uiName = 'spGame';
  let ui = mBy(uiName);
  if (nundef(ui)) {
    ui = mEditableOnEdited(uiName, dLineTopMiddle, 'game: ', '', changeGameTo, () => {
      console.log('Games', getGames());
    });
  }
  ui.innerHTML = id;
  mStyleX(ui, { fg: color });
}
function updateGameplayerCardCollections(pid, oPlayer) {
  let msPlayerArea = getPlayerArea(pid);
  for (const propName in oPlayer) {
    let plColls = getCollections(pid, propName);
    if (nundef(plColls)) continue;
    for (const key in plColls) {
      let coll = plColls[key];
      if (!coll.tbd) continue;
      let idCollection = getCollectionArea(key, msPlayerArea);
      showCollection(coll, idCollection);
      coll.tbd = null;
    }
  }
}
async function updateGroupInfo() {
  let syms20 = await route_path_yaml_dict('../assets/speech/syms2020.yaml');
  console.log(syms20);
  console.log(KeySets);
  for (const k in syms20) {
    KeySets.all.push(k);
    KeySets.huge.push(k);
    let info = syms20[k];
    if (isdef(info.ngroup)) {
      for (const n of [25, 50, 100]) {
        if (info.ngroup <= n) KeySets['best' + n].push(k);
      }
    }
    if (info.group != 'smileys-emotion') { KeySets.nemo.push(k); if (isdef(info.ngroup)) KeySets.nemo100.push(k); }
    switch (info.group) {
      case 'object': KeySets.object.push(k); KeySets.object50.push(k); KeySets.objectPlus.push(k); break;
      case 'animal': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'fruit': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'food': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'drink': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'vegetable': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'smileys-emotion': KeySets.emo.push(k); break;
      case 'people-body': break;
      default: console.log('forgot group', info.group); break;
    }
  }
  addCatsToKeys();
}
function updateKeySettings(nMin) {
  if (nundef(G)) return;
  G.keys = setKeys({ nMin, lang: Settings.language, keysets: KeySets, key: Settings.vocab });
}
function updateLabelSettings() {
  console.assert(isdef(Score.labels), 'Score not set!!!!!')
  if (Settings.showLabels == 'toggle') Settings.labels = Score.labels == true;
  else Settings.labels = (Settings.showLabels == 'always');
}
function UpdateListsMaterial() {
  var piece, sq, index, colour;
  for (index = 0; index < BRD_SQ_NUM; ++index) {
    sq = index;
    piece = brd_pieces[index];
    if (piece != PIECES.OFFBOARD && piece != PIECES.EMPTY) {
      colour = PieceCol[piece];
      brd_material[colour] += PieceVal[piece];
      brd_pList[PCEINDEX(piece, brd_pceNum[piece])] = sq;
      brd_pceNum[piece]++;
    }
  }
}
function updateLoginHeader() { document.getElementById('hUsername').innerHTML = 'logged in as <b>' + clientData.name + '</b>'; }
function updateNode(n, upd, R) {
  let oid = upd.oid;
  let o = R.getO(upd.oid);
  if (upd.ukind == 'valueChange') {
    let prop = upd.prop;
    let oldval = o[prop];
    o[prop] = upd.newval;
    let f = RUPDATE[n.type];
    if (isdef(f)) {
      let ui = n.ui;
      let data = n.data;
      if (data == '.' + upd.prop) {
        n.content = calcContentFromData(oid, o, n.data, R);
      }
      f(ui, n.content);
    }
  }
}
function updateOutput(R) {
  for (const area of ['spec', 'uiTree', 'rTree', 'oidNodes', 'dicts', 'refsIds']) { //'channelsStatic', 'channelsLive' 
    clearElement(area);
  }
  if (SHOW_SPEC) { presentNodes(R.lastSpec, 'spec'); }
  if (SHOW_UITREE) {
    presentDictTree(R.uiNodes, R.tree.uid, 'uiTree', 'children', R,
      ['children'],
      null,
      ['ui', 'act', 'params', 'defParams', 'cssParams', 'typParams', 'stdParams'],
      { 'max-width': '35%', font: '14px arial' });
  }
  if (SHOW_RTREE) {
    presentDictTree(R.rNodes, R.tree.uid, 'rTree', 'children', R,
      ['children'], null, null, { 'max-width': '35%', font: '14px arial' });
  }
  if (SHOW_OIDNODES) { presentOidNodes(R, 'oidNodes'); }
  if (SHOW_DICTIONARIES) {
    mDictionary(R.rNodesOidKey, { dParent: mBy('dicts'), title: 'rNodesOidKey ' + Object.keys(R.rNodesOidKey).length });
    mDictionary(R.Locations, { dParent: mBy('dicts'), title: 'locations ' + Object.keys(R.Locations).length });
  }
  if (SHOW_IDS_REFS) {
    mDictionary(R.places, { dParent: mBy('refsIds'), title: 'places ' + Object.keys(R.places).length });
    mDictionary(R.refs, { dParent: mBy('refsIds'), title: 'refs ' + Object.keys(R.refs).length });
  }
  if (nundef(R.rNodes)) return;
  let numRTree = Object.keys(R.rNodes).length;
  let numUiNodes = nundef(R.uiNodes) ? 0 : Object.keys(R.uiNodes).length;
  let handCounted = R.ROOT.data;
  console.assert(numRTree == numUiNodes, '!!!FEHLCOUNT!!! #rtree=' + numRTree + ', #uiNodes=' + numUiNodes);
}
function updateOutput_dep(R) {
  for (const area of ['spec', 'uiTree', 'rTree', 'oidNodes', 'dicts']) {
    clearElement(area);
  }
  if (SHOW_SPEC) { presentNodes(R.lastSpec, 'spec'); }
  if (SHOW_UITREE) {
    presentDictTree(R.uiNodes, R.tree.uid, 'uiTree', 'children', R,
      ['children'],
      ['uid', 'adirty', 'type', 'data', 'content', 'uiType', 'oid', 'key', 'boardType'],
      null,
      { 'max-width': '35%', font: '14px arial' });
  }
  if (SHOW_RTREE) {
    presentDictTree(R.rNodes, R.tree.uid, 'rTree', 'children', R,
      ['children'], null, null, { 'max-width': '35%', font: '14px arial' });
  }
  if (SHOW_OIDNODES) { presentOidNodes(R, 'oidNodes'); }
  if (SHOW_DICTIONARIES) {
    mDictionary(R.rNodesOidKey, { dParent: mBy('dicts'), title: 'rNodesOidKey ' + Object.keys(R.rNodesOidKey).length });
    mDictionary(R.Locations, { dParent: mBy('dicts'), title: 'locations ' + Object.keys(R.Locations).length });
  }
  let numRTree = Object.keys(R.rNodes).length;
  let numUiNodes = nundef(R.uiNodes) ? 0 : Object.keys(R.uiNodes).length;
  let handCounted = R.ROOT.data;
  console.assert(numRTree == numUiNodes, '!!!FEHLCOUNT!!! #rtree=' + numRTree + ', #uiNodes=' + numUiNodes);
}
function updatePlayerConfig() {
  let keysPlayerColors = Object.keys(PLAYER_COLORS);
  let iColor = 0;
  for (const id in serverData.players) {
    let pl = serverData.players[id];
    let colorName = isdef(pl.color) ? pl.color : keysPlayerColors[iColor];
    colorName = colorName.toLowerCase();
    let altName = capitalize(colorName);
    let color = isdef(PLAYER_COLORS[colorName]) ? PLAYER_COLORS[colorName] : colorName;
    playerConfig[GAME].players[id].color = color;
    iColor += 1;
  }
}
function updatePlayersForGame() {
  currentNumPlayers = 0;
  for (let i = 1; i <= MAX_PLAYERS_AVAILABLE; i += 1) {
    if (i <= numPlayersMin) { currentNumPlayers += 1; showPlayer(i); checkPlayer(i); makePlayerReadOnly(i); }
    else if (i <= numPlayersMax) { showPlayer(i); uncheckPlayer(i); }
    else { hidePlayer(i); }
  }
}
function updatePlayersForMode() {
  let mode = currentPlaymode;
  let val = 'me';
  let n = MAX_PLAYERS_AVAILABLE;
  for (let i = 1; i <= n; i += 1) {
    let id = getidType(i);
    if (!isVisible(id)) continue;
    if (mode == 'solo') { populateSelect(i, soloTypes, val); val = 'AI regular'; }
    else if (mode == 'hotseat' || mode == 'passplay') { populateSelect(i, soloTypes, val); }
    else {
      populateSelect(i, allPlayerTypes, val);
      val = PLAYER_CONFIG_FOR_MULTIPLAYER.length > i ? PLAYER_CONFIG_FOR_MULTIPLAYER[i] : 'human';
    }
  }
}
function updatePlaymode(mode) {
  currentPlaymode = mode;
  makePlayermodeReadOnly('multiplayer');
}
function updatePreviewImage(dParent, file, sz = 768) {
  const url = URL.createObjectURL(file);
  dParent.innerHTML = `<img src="${url}" height=${sz}/>`;
}
function updatePreviewImages(dParent, files) {
  for (const f of files) {
    let sz = 200;
    let d = mDiv(dParent, { display: 'inline', w: sz, h: sz });
    updatePreviewImage(d, f, sz);
  }
}
function updateSettings() {
  appSpecificSettings();
  for (const k in SettingTypesCommon) {
    if (SettingTypesCommon[k]) {
      lookupSetOverride(U, ['settings', k], Settings[k]);
    } else {
      if (isdef(G.id)) lookupSetOverride(U, ['games', G.id, 'settings', k], Settings[k]);
    }
  }
}
function updateSizes(nuiBoard) {
  let szOrig = nuiBoard.params.sizes.f;
  let szNew = szOrig;
  let cSizeOrig = nuiBoard.params.sizes.c;
  let cSizeNew = cSizeOrig;
  let eSizeOrig = nuiBoard.params.sizes.e;
  let eSizeNew = eSizeOrig;
  if (nundef(nuiBoard.resizeInfo)) nuiBoard.resizeInfo = {};
  if (isdef(nuiBoard.resizeInfo.fields)) {
    szNew = nuiBoard.resizeInfo.fields;
  }
  if (isdef(nuiBoard.resizeInfo.corners)) {
    cSizeNew = nuiBoard.resizeInfo.corners;
  }
  szNew = Math.max(szNew, cSizeNew);
  if (isdef(nuiBoard.resizeInfo.edges)) {
    eSizeNew = nuiBoard.resizeInfo.edges;
  }
  szNew = Math.max(szNew, eSizeNew);
  return { sOrig: { f: szOrig, c: cSizeOrig, e: eSizeOrig }, sNew: { f: szNew, c: cSizeNew, e: eSizeNew } };
}
function updateSpeakmodeSettings() {
  if (Settings.silentMode && Settings.spokenFeedback) Settings.spokenFeedback = false;
}
function updateStartLevelForUser(game, level, msg) {
  lookupSetOverride(U.games, [game, 'startLevel'], level);
  saveUser();
}
async function updateSymbolDict() {
  let snew = await route_path_yaml_dict('../assets/syms.yaml');
  let sold = await route_path_yaml_dict('../assets/symbolDict.yaml');
  let soldlc = {};
  for (const k in sold) {
    let klc = k.toLowerCase();
    let o = soldlc[klc] = sold[k];
    o.key = klc;
  }
  for (const k in snew) {
    if (nundef(soldlc[k])) {
      soldlc[k] = snew[k];
      console.log('new key added to symbolDict', k)
    } else {
      let onew = snew[k];
      let oold = soldlc[k];
      if (onew.type != oold.type) {
        soldlc[k] = onew;
        console.log('symbolDict key updated', k)
      }
    }
  }
  downloadAsYaml(soldlc, 'symbolDict_upd');
}
async function updateSymbolDictFromDictionaries() {
  [EdDict, DeDict] = await loadGerman();
  let ekeys = Object.keys(EdDict);
  let lowerEKeys = ekeys.map(x => x.toLowerCase());
  console.log('dict e=>d', ekeys);
  ensureSymByType();
  let keys = symKeysByType['icon'];
  console.log('keys', keys);
  let inter = intersection(keys, lowerEKeys);
  console.log('intersection:', inter);
  for (const k of inter) {
    let entry = lookup(EdDict, [k, 'd']);
    if (nundef(entry)) {
      console.log('gibt es nicht!', k)
    } else {
      console.log('entry', entry)
      console.log('JA!', k, entry.join('|'));
      symbolDict[k].D = entry.join('|').toLowerCase();
      symbolDict[k].E = k;
    }
  }
  downloadAsYaml(symbolDict, 'symbolDict');
}
function updateTableCardCollections() {
  let msTableArea = getTabletopCardsArea();
  for (const oid in collections) {
    if (nundef(G.table[oid])) continue;
    let o = G.table[oid];
    for (const propName in o) {
      let colls = getCollections(oid, propName);
      if (nundef(colls)) continue;
      for (const key in colls) {
        let coll = colls[key];
        if (!coll.tbd) continue;
        let idCollection = getCollectionArea(key, msTableArea);
        showCollection(coll, idCollection);
        coll.tbd = null;
      }
    }
  }
}
function updateTableCardCollections_COPY(oid) {
  if (nundef(collections[oid])) return;
  let msArea = getTabletopCardsArea();
  if (isEmpty(collections)) {
    return;
  }
  for (const propName of G.tableUpdated[oid].summary) {
    let o = G.table[propName];
    let plColl = getTableCollections(oid, propName);
    if (isdef(plColl)) {
      for (const key in plColl) {
        let ha = plColl[key];
        let idCollection = getCollectionArea(key, msArea);
        let divHand = UIS[idCollection].elem;
        divHand.style.position = null;
        getSimpleSetElements(ha.hand)
        showPlayerHandNew(ha.name, ha.arr, key);
      }
    }
  }
}
function updateTablenameUi(id, color) {
  let uiName = 'spTable';
  let ui = mBy(uiName);
  if (nundef(ui)) {
    ui = mEditableOnEdited(uiName, dLineTopRight, 'table: ', '', changeTableTo, () => {
      console.log('Tables', getTables());
    });
  }
  ui.innerHTML = id;
  mStyleX(ui, { fg: color });
}
function updateTestInput(index) {
  let elem = mBy('iTestCase');
  if (isdef(elem)) {
    elem.max = Object.keys(testEngine.specs).length - 1;
    elem.min = 0;
    elem.value = index;
  }
}
function updateTimeSettings() {
  let timeElem = mBy('time');
  if (Settings.showTime) { show(timeElem); startTime(timeElem); }
  else hide(timeElem);
}
function updateTooltipContent(oid) {
  let pool = findPool(oid);
  let o = pool[oid];
  ttTitle(oid, o);
  ttBody(oid, o);
}
function updateTooltipContent_hallo(id) {
  let oid = getOidForMainId(id);
  let pool = findPool(id);
  let o = pool[id];
  console.log('tt', id, oid, o)
  return;
  ttTitle(id, o);
  ttBody(id, o);
}
function updateUsernameUi(id, color) {
  let uiName = 'spUser';
  let ui = mBy(uiName);
  if (nundef(ui)) {
    ui = mEditableOnEdited(uiName, dLineTopLeft, 'user: ', '', changeUserTo, () => {
      console.log('Users', getUsers());
    });
  }
  ui.innerHTML = id;
  mStyleX(ui, { fg: color });
}
function updateUserScore() {
  if (nundef(Score.nTotal) || Score.nTotal <= 0) return;
  let sc = { nTotal: Score.nTotal, nCorrect: Score.nCorrect, nCorrect1: Score.nCorrect1, nWins: Score.nWins, nLoses: Score.nLoses, nTied: Score.nTied };
  let g = G.id;
  let recOld = lookupSet(U, ['games', g], { startLevel: 0, nTotal: 0, nCorrect: 0, nCorrect1: 0, nWins: 0, nLoses: 0, nTied: 0 });
  let recSession = lookupSet(U, ['session', g], { startLevel: 0, nTotal: 0, nCorrect: 0, nCorrect1: 0, nWins: 0, nLoses: 0, nTied: 0 });
  addByKey(sc, recSession);
  let counts = DB.games[g].controllerType == 'solo' ? recSession.nWins : recSession.nCorrect;
  recSession.percentage = Math.round(100 * counts / recSession.nTotal);
  addByKey(sc, recOld);
  counts = DB.games[g].controllerType == 'solo' ? recOld.nWins : recOld.nCorrect;
  recOld.percentage = Math.round(100 * recOld.nCorrect / recOld.nTotal);
  Score.nTotal = Score.nCorrect = Score.nCorrect1 = 0;
  saveUser();
}
function upgradeToSimpleGraph(g, dParent, styles = {}) {
  g.id = nundef(dParent.id) ? getUID() : dParent.id;
  let styleDict = {
    node: { 'width': 25, 'height': 25, 'background-color': 'red', "color": "#fff", 'label': 'data(id)', "text-valign": "center", "text-halign": "center", },
    edge: { 'width': 2, 'line-color': 'silver', 'curve-style': 'haystack', },
    'node.highlight': { 'background-color': 'yellow' },
    'node.trans': { 'opacity': '0.5' },
  }
  for (const ks of ['node', 'edge', 'node.highlight', 'node.trans']) {
    if (isdef(styles[ks])) {
      for (const k in styles[ks]) {
        let [prop, val] = translateToCssStyle(k, styles[ks][k], false);
        styleDict[ks][prop] = val;
      }
    }
  }
  let cyStyle = [];
  for (const k in styleDict) { cyStyle.push({ selector: k, style: styleDict[k] }); }
  let size = getSize(dParent);
  let d1 = mDiv(dParent, { position: 'relative', bg: 'green', w: size.w - 80, left: 40, top: 0, h: size.h, align: 'left' });
  g.cy.mount(d1);
  g.cy.style(cyStyle);
  g.enablePanZoom();
  iAdd(g, { div: dParent, dCy: d1 });
}
function uploadImgData(imgFile) {
  let pack = {};
  let data = imgFile.data;
  let filename = imgFile.name; console.log('filename', filename);
  let key = stringBefore(filename, '.');
  pack[key] = { data: data, name: key, filename: filename, type: 'imageData' };
  Socket.emit('generalImages', { pack: pack });
  console.log('uploading pack', pack);
}
function user_already_loaded(name) { return isdef(name && name == Session.cur_user); }
function userUpdate(proplist, val) {
  lookupSetOverride(U, proplist, val);
  saveUser();
}
function useSymbolElemNO(key = 'Treff', h = 50, x = 0, y = 0) {
  return mCreateFrom(`<use xlink:href="#${key}" height="${h}" x="${x}" y="${y}"></use>`);
}
function utter(text, r = .5, p = .8, v = .5, voiceDesc, callback = null) {
  let [voiceKey, voice] = findSuitableVoice(text, voiceDesc);
  utterance.text = sepWords(text, voiceKey);
  utterance.rate = r;
  utterance.pitch = p;
  utterance.volume = v;
  utterance.voice = voice;
  utterance.onend = callback;
  synth.onend
  if (isdef(timeout2)) { clearTimeout(timeout2); }
  timeout2 = setTimeout(() => {
    if (!isINTERRUPT) {
      isSpeakerRunning = true;
    }
    synth.speak(utterance); focus(mBy(defaultFocusElement));
  }, 200);
}
function valf() {
  for (const arg of arguments) if (isdef(arg)) return arg;
  return null;
}
function valfi() {
  for (const arg of arguments) {
    if (isdef(arg)) return arg;
  }
  return null;
}
function valnwhite() {
  for (const arg of arguments) if (isdef(arg) && !isEmptyOrWhiteSpace(arg)) return arg;
  return null;
}
function valToString(n) { if (isFractionType(n)) return getTextForFractionX(n.n, n.d); else return n; }
function valueOfElement(id) {
  return document.getElementById(id).value;
}
function verify_min_req() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let pl = fen.players[uplayer];
  let jsorted = jsCopy(pl.journeys).sort((a, b) => b.length - a.length);
  let di = {
    '3': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 3,
    '33': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 3
      && is_group(jsorted[1]) && jsorted[1].length >= 3,
    '4': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 4,
    '44': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 4
      && is_group(jsorted[1]) && jsorted[1].length >= 4,
    '5': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 5,
    '55': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 5
      && is_group(jsorted[1]) && jsorted[1].length >= 5,
    '7R': jsorted.length > 0 && is_sequence(jsorted[0]) && jsorted[0].length >= 7,
  };
  let goals = is_fixed_goal() ? [get_round_goal()] : get_available_goals(uplayer);
  for (const g of goals) {
    if (di[g] == true) { return true; }
  }
  return false;
}
function verify_unit_test(otree) {
  if (isdef(DA.verify) && ITER == DA.iter_verify) {
    TestRunning = false;
    let res = DA.verify(otree);
    console.log('***UNIT TEST ' + TestNumber, res ? 'passed...' : 'FAILED!!!!!!!!!!!!!!!!');
    console.assert(res, '*** STOP TEST FAIL ***')
    if (TestSuiteRunning) test_engine_run_next(TestList);
  }
  return true;
}
async function verifySequence(indexFrom, indexTo, saveOnCompleted = false) {
  show('btnStop');
  console.log('______________ verify from', indexFrom, 'to', indexTo, 'save', saveOnCompleted);
  testEngine.autosave = true;
  clearElement(mBy('table'));
  let series = testEngine.series;
  let maxIndex = indexTo;
  let index = indexFrom;
  await testEngine.loadTestCase(series, index);
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
  setTimeout(async () => { await verNext(series, index + 1, maxIndex, saveOnCompleted); }, 1000);
}
async function verNext(series, index, maxIndex, saveOnCompleted = false) {
  await testEngine.loadTestCase(series, index);
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
  let timeOUT = 500;
  if (index < maxIndex && !STOP) setTimeout(async () => { await verNext(series, index + 1, maxIndex, saveOnCompleted); }, timeOUT);
  else {
    isTraceOn = SHOW_TRACE;
    STOP = false;
    hide('btnStop');
    if (saveOnCompleted) saveSolutions(series, testEngine.Dict[series].solutions);
  }
}
function visNumber(n, dParent, color, or = 'h', asNumber = [0]) {
  if (!isNumber(n) || asNumber.includes(n)) return zText('' + n, dParent, { fg: 'white', fz: 64 });
  return _visualizeNumber(n, dParent, color, or);
}
function visOperation(op, a, b, dParent, symResult) {
  switch (op) {
    case 'plus':
    case 'minus': return _visualizeAritOp(op, a, b, dParent, symResult); break;
    case 'mult': return _visualizeMult(a, b, dParent, symResult); break;
  }
}
function visOperator(s, dParent, styles = { fg: 'white', fz: 64 }) {
  zText(s, dParent, styles);
}
function visual(shape, { ipal, fill, x, y, w, h, sPoints, border, thickness, rounding, path, txt, fz, sz }, overlay = true, draw = true) {
  let ms = new MS(uid(), 'g');
  let options = {};
  if (ipal) fill = getpal(ipal);
  if (fill) options.fill = fill;
  if (x) options.x = x;
  if (y) options.y = y;
  if (w) options.w = w;
  if (h) options.h = h;
  if (txt) options.txt = txt;
  if (fz) options.fz = fz;
  if (sz) options.sz = sz;
  if (sPoints) options.sPoints = sPoints;
  if (border) options.border = border;
  if (thickness) options.thickness = thickness;
  if (rounding) options.rounding = rounding;
  if (path) options.path = './assets/images/transpng/' + path + '.png';
  switch (shape) {
    case 'circle':
      ms.circle(options);
      break;
    case 'hex':
      ms.hex(options);
      break;
    case 'rect':
      ms.rect(options);
      break;
    case 'poly':
      ms.poly(options);
      break;
    case 'image':
      ms.image(options);
      break;
    case 'text':
      ms.text(options);
      break;
    default:
      return null;
  }
  if (overlay) {
    overlayOptions = jsCopy(options);
    overlayOptions.className = 'overlay';
    delete overlayOptions.fill;
    delete overlayOptions.path;
    switch (shape) {
      case 'circle':
        ms.circle(overlayOptions);
        break;
      case 'hex':
        ms.hex(overlayOptions);
        break;
      case 'rect':
        ms.rect(overlayOptions);
        break;
      case 'poly':
        ms.poly(overlayOptions);
        break;
      case 'image':
        ms.rect(overlayOptions);
        break;
      case 'text':
        ms.text(overlayOptions);
        break;
      default:
        return null;
    }
  }
  if (draw) ms.draw();
  return ms;
}
function visualAttributeSetter(c) {
  let props = 'innerHTML onclick';
  for (const k of props.split(' ')) {
    propertyGiver(c, k, x => c.visual[k] = x, () => c.visual[k]);
  }
}
function visualPropertySetter(c) {
  let props = 'bg fg h w background color height width rounding padding fz font align';
  for (const k of props.split(' ')) {
    propertyGiver(c, k,
      x => { let styles = {}; styles[k] = x; mStyle(c.visual, styles); },
      () => { return mGetStyle(c.visual, k); }
    );
  }
}
function waitForLogin() {
  initDom();
  openTabTesting('Seattle');
}
async function wegMitwh() {
  let syms = await route_path_yaml_dict('../assets/syms.yaml');
  let newSyms = {};
  for (const k in syms) {
    let info = jsCopy(syms[k]);
    info.w = info.w[0];
    info.h = info.h[0];
    newSyms[k] = info;
  }
  downloadAsYaml(newSyms, 'syms');
}
function weiter_process_inspect() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let uibuilding = A.uibuilding = item.o;
  let fenbuilding = A.fenbuilding = lookup(fen, uibuilding.path.split('.'));
  let key = uibuilding.keycard.key;
  let cards = uibuilding.items;
  let schweine_cand = [];
  for (let i = 1; i < cards.length; i++) {
    if (fenbuilding.schweine.includes(i)) continue;
    let card = cards[i];
    if (card.key == key) continue;
    assertion(i == card.index, 'wrong card index!!!!')
    schweine_cand.push(card);
  }
  if (schweine_cand.length > 1) {
    Z.stage = 38;
    ari_pre_action();
  } else if (schweine_cand.length == 1) {
    setTimeout(() => turn_new_schwein_up(schweine_cand[0], fenbuilding, uibuilding), 3000);
  } else if (isEmpty(fenbuilding.schweine)) {
    Z.stage = 29;
    ari_history_list([`${uplayer} inspects a correct building`], 'inspect');
    show_instruction('the building is CORRECT - You loose 1 rumor')
    setTimeout(ari_pre_action, 2000);
  } else {
    let rumor = fen.deck_rumors[0]; fen.deck_rumors.shift();
    fen.players[uplayer].rumors.push(rumor);
    show_instruction('no additional schwein has been found - you gain 1 rumor')
    ari_history_list([`${uplayer} inspects a schweine!`], 'inspect');
    setTimeout(ari_next_action, 2000);
  }
}
function whenSoundPaused() {
  _sndPlayer = null;
  _sndPlayerIdle = true;
  _loaded = false;
  if (!isEmpty(_qSound)) { _deqSound(); } else { _idleSound = true; }
}
function where(o) {
  let fname = getFunctionsNameThatCalledThisFunction();
}
function whichGame(callback) { let route = '/game/info'; _sendRouteJS(route, callback); }
function whoAmI() {
  let gc = S.gameConfig;
  return { username: USERNAME, playerOnTurn: G.player, myPlayers: [S.gameConfi] }
}
function wise() {
  function state_info(dParent) { return; }
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: [], num: options.num };
    let starter = fen.starter = fen.plorder[0];
    Sayings = shuffle(Sayings);
    fen.index = 0;
    fen.saying = Sayings[fen.index];
    for (const plname of players) {
      let pl = fen.players[plname] = {
        score: 0,
        name: plname,
        color: get_user_color(plname),
      };
    }
    [fen.phase, fen.stage, fen.step, fen.turn] = ['one', 'write', 0, jsCopy(fen.plorder)];
    return fen;
  }
  function check_gameover() {
    let winners = [];
    for (const plname of Z.plorder) {
      let cond = get_player_score(plname) >= Z.options.winning_score;
      if (cond) { winners.push(plname); }
    }
    if (!isEmpty(winners)) Z.fen.winners = winners;
    return isEmpty(winners) ? false : Z.fen.winners;
  }
  function post_collect() { agmove_resolve(); }
  return { post_collect, state_info, setup, present: wise_present, check_gameover, activate_ui: wise_activate };
}
function wise_activate() {
  let [pldata, stage, A, fen, phase, uplayer] = [Z.playerdata, Z.stage, Z.A, Z.fen, Z.phase, Z.uplayer];
  let donelist = Z.playerdata.filter(x => isDict(x.state));
  let complete = donelist.length == Z.plorder.length;
  let resolvable = uplayer == fen.starter && complete;
  let waiting = !resolvable && isdef(donelist.find(x => x.name == uplayer));
  console.log(uplayer, stage, 'done', donelist, 'complete', complete, 'waiting', waiting);
  Z.isWaiting = false;
  if (waiting) {
    mDiv(dTable, {}, null, 'WAITING FOR PLAYERS TO COMPLETE....');
    if (complete) {
      Z.turn = [fen.starter];
      if (Z.mode != 'multi') take_turn_waiting();
    }
    Z.isWaiting = true;
    autopoll();
  } else if (stage == 'write' && resolvable) {
    assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
    let start = fen.saying.start.toLowerCase();
    let sentences = [];
    for (const pldata of Z.playerdata) {
      let plname = pldata.name;
      let text = start + ' ' + pldata.state.text;
      sentences.push({ plname: plname, text: text.toLowerCase() });
    }
    sentences.push({ plname: '', text: start + ' ' + fen.saying.end.toLowerCase() });
    fen.sentences = shuffle(sentences);
    Z.turn = jsCopy(Z.plorder);
    Z.stage = 'select';
    take_turn_fen_clear();
  } else if (stage == 'write') {
    let d = mCreate('form');
    let dt = dTable;
    mAppend(dt, d);
    d.autocomplete = "off";
    d.action = "javascript:void(0);";
    mDiv(d, { fz: 20 }, 'dForm', fen.saying.start.toLowerCase() + '...');
    Z.form = d;
    mLinebreak(d, 10);
    mInput(d, { wmin: 600 }, 'i_end', 'enter ending');
    d.onsubmit = wise_submit_text;
  } else if (stage == 'select' && resolvable) {
    assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
    let d = mDiv(dTable, {});
    fen.result = {};
    for (const pldata of Z.playerdata) {
      let selecting = pldata.name;
      let selected = pldata.state.plname;
      let text = pldata.state.text;
      if (isEmpty(selected)) {
        console.log('REINGEGANGEN!!!!!!!!!!!!!!')
        fen.players[selecting].score += 1;
        selected = 'correct';
      } else if (selecting != selected) {
        fen.players[selected].score += 1;
      }
      fen.result[selecting] = { plname: selected, text: text };
    }
    delete fen.sentences;
    Z.turn = jsCopy(Z.plorder);
    Z.stage = 'round';
    take_turn_fen_clear();
  } else if (stage == 'select') {
    let d = mDiv(dTable, {});
    let i = 1;
    for (const s of fen.sentences) {
      let d1 = mDiv(d, { fz: 20, hline: 30 }, `dsent_${s.plname}`, '' + (i++) + ') ' + s.text, 'hop1');
      d1.onclick = wise_select_sentence;
    }
  } else if (stage == 'round' && resolvable) {
    assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
    delete fen.result;
    Z.turn = jsCopy(Z.plorder);
    fen.index++;
    fen.saying = Sayings[fen.index];
    Z.stage = 'write';
    take_turn_fen_clear();
  } else if (stage == 'round') {
    let d = mDiv(dTable, {});
    for (const plname in fen.result) {
      let o = fen.result[plname];
      let d1 = mDiv(d, { fz: 20, hline: 30 }, null, `${plname} selected ${o.plname}: ${o.text}`);
    }
    mLinebreak(dTable, 12)
    mButton('WEITER', wise_onclick_weiter, dTable, {}, ['donebutton', 'enabled']);
  } else {
    console.log('Z', Z)
    alert('PROBLEM!!!')
  }
}
function wise_onclick_weiter() {
  Z.state = { plname: Z.uplayer };
  take_turn_multi();
}
function wise_present(dParent) {
  let [fen, ui, stage, uplayer] = [Z.fen, UI, Z.stage, Z.uplayer];
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent, 1, 0);
  let dt = dTable = dOpenTable; clearElement(dt); mCenterFlex(dt);
  wise_stats(dt);
  mLinebreak(dt, 10);
}
function wise_select_sentence(ev) {
  if (!uiActivated) return;
  let text = ev.target.innerHTML;
  let plname = stringAfter(ev.target.id, 'dsent_')
  Z.state = { plname: plname, text: text };
  take_turn_multi();
}
function wise_stats(d) {
  let players = Z.fen.players;
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname of get_present_order()) {
    let pl = players[plname];
    let onturn = Z.turn.includes(plname);
    let sz = 50;
    let bcolor = plname == Z.uplayer ? 'lime' : 'silver';
    let border = pl.playmode == 'bot' ? `double 5px ${bcolor}` : `solid 5px ${bcolor}`;
    let rounding = pl.playmode == 'bot' ? '0px' : '50%';
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='../base/assets/images/${plname}.jpg' style="border-radius:${rounding};display:block;border:${border};box-sizing:border-box" class='img_person' width=${sz} height=${sz}>${get_player_score(plname)}`);
  }
}
function wise_submit_text(ev) { ev.preventDefault(); let text = mBy('i_end').value; Z.state = { text: text }; take_turn_multi(); }
function without(arr, elementToRemove) {
  return arr.filter(function (el) {
    return el !== elementToRemove;
  });
}
function wlog() {
  let s = '';
  for (const a of arguments) {
    s += a + ' ';
  }
  console.log(s);
}
function wordCorrectionFactor(text, styles, w, h, fz) {
  styles.fz = fz;
  let size = getSizeWithStyles(text, styles);
  let hFactor = 1; let wFactor = 1;
  if (size.h > h - 1) { hFactor = size.h / h; }
  if (size.w > w - 1) { wFactor = size.w / w; }
  if (size.w < w && size.h < h) return 0;
  else return Math.max(hFactor, wFactor);
}
function wordsFromToText(i, n = 300) {
  let list = [];
  for (const k in symbolDict) {
    let info = symbolDict[k];
    if (nundef(info.bestE) || !isString(info.bestE) || info.bestE.length < 2) continue;
    addIf(list, info.bestE);
  }
  let sfromi = arrFromIndex(list, i);
  s300 = arrTake(sfromi, n);
  let s = s300.join('\n');
  console.log(s);
  downloadTextFile(s, 'words_' + i);
}
function wordsOfLanguage(key, language) {
  let y = symbolDict[key];
  let w = y[language];
  let wlist = w.split('|');
  return wlist.map(x => x.trim());
}
function worldMap(loc) {
  let html =
    `<div id="map_area" class="grid_div" style="width:340px;height:220px;background-color:rgba(86, 182, 222);">
      <svg width="100%" height="100%" viewBox="0 0 3400 2200" style="box-sizing:border-box;">
        <g id="mapG" >
          <image id="imgMap" href="/assets/tnt/TTmap.jpg" />
        </g>
      </svg>
    </div>`;
  let d = mBy(loc);
  d.innerHTML = html;
}
function wrapLayoutColarr(num) {
  const arr = [[0], [1], [2], [1, 2], [2, 2], [2, 3], [3, 3], [2, 3, 2], [2, 3, 3], [3, 3, 3], [3, 4, 3], [3, 4, 4], [4, 4, 4]];
  return num < arr.length ? arr[num] : [num];
}
function wrapLayoutPosition(nBoard, tile, R) {
  let margin = 2;
  let uids = tile.children;
  let colarr = wrapLayoutColarr(uids.length);
  let rows = colarr.length;
  let iNode = 0;
  let nChild = R.uiNodes[uids[0]];
  let size0 = R.uiNodes[uids[0]].size;
  let wChild = getBounds(nChild.ui).width;
  let xOffset = nBoard.size.w / 2 + tile.pos.x - size0.w / 2;
  let yOffset = nBoard.size.h / 2 + tile.pos.y - size0.h / 2;
  let x = 0;
  let y = 0;
  let dx = size0.w + margin;
  let dy = size0.h + margin;
  for (let r = 0; r < rows; r++) {
    x = 0;
    y = r * dy - (rows * dy - dy) / 2;
    let wrow = colarr[r] * dx - dx;
    for (let c = 0; c < colarr[r]; c++) {
      let robber = R.uiNodes[uids[iNode]];
      let ui = robber.ui;
      ui.style.position = 'absolute';
      ui.style.display = 'inline-block';
      ui.style.boxSizing = 'border-box'
      let xPos = x + xOffset - wrow / 2;
      let yPos = y + yOffset;
      robber.pos = { x: xPos, y: yPos };
      ui.style.left = xPos + 'px';
      ui.style.top = yPos + 'px';
      ui.style.margin = '0px';
      x += dx;
      iNode += 1;
    }
  }
}
function wrapLayoutSizeNeeded(uids, R) {
  const arr = [[0], [1], [2], [1, 2], [2, 2], [2, 3], [3, 3], [2, 3, 2], [2, 3, 3], [3, 3, 3], [3, 4, 3], [3, 4, 4], [4, 4, 4]];
  let colarr = wrapLayoutColarr(uids.length);
  let rows = colarr.length;
  let iNode = 0;
  let wmax = 0;
  let maxNumPerRow = 0;
  let htot = 0;
  for (let r = 0; r < rows; r++) {
    let hmax = 0;
    let wtot = 0;
    for (let c = 0; c < colarr[r]; c++) {
      let n = R.uiNodes[uids[iNode]];
      let h = n.size.h;
      let w = n.size.w;
      hmax = Math.max(hmax, h);
      wtot += w;
      maxNumPerRow = Math.max(maxNumPerRow, c);
    }
    wmax = Math.max(wmax, wtot);
    htot += hmax;
  }
  let margin = 2;
  let wNeeded = wmax + margin * (maxNumPerRow + 1);
  let hNeeded = htot + margin * (rows + 1);
  return { w: wNeeded, h: hNeeded };
}
function write() { if (verbose) console.log(...arguments); }
function write_code_text_file(keylist) {
  let text = '';
  for (const k of keylist) {
    let o = lookup(CODE, ['all', k]);
    let type, code;
    type = isdef(o) ? o.type : null;
    if (type == 'var') { code = CODE.justcode[k]; }
    else if (type == 'const') { code = CODE.justcode[k]; }
    else if (type == 'cla') { code = CODE.justcode[k]; }
    else if (type == 'func') { code = isdef(window[k]) ? window[k].toString() : CODE.justcode[k]; }
    else { code = window[k].toString(); }
    if (OWNPROPS.includes(k)) { continue; } 
    if (k != 'write_code_text_file' && (code.includes('[native code]') || code.includes('function('))) continue;
    if (!isEmpty(code)) text += code + '\n';
  }
  text = replaceAllSpecialChars(text, '\r', '');
  AU.ta.value = text;
  return text;
}
function writeComments(pre) {
  console.log('NEEEEEEEEEEEEEEEEEEEEIIIIIIIIIIIIIIIIIN', getFunctionsNameThatCalledThisFunction())
  if (ROUND_OUTPUT) {
    console.log('...' + currentGame.substring(1), pre + ' currentLevel:' + currentLevel, 'pics:' + NumPics,
      'labels:' + NumLabels,
      '\nkeys:' + currentKeys.length, 'minlen:' + MinWordLength, 'maxlen:' + MaxWordLength, 'trials#:' + MaxNumTrials);
  }
}
function writeExp() { }
function writeSound() { return; console.log('calling playSound'); }
function yesNo() { return tossCoin(50); }
function yPics(ifs, options) {
  let keys = choose(SymKeys, n);
  console.log(keys)
  showPicsS(keys);
}
function yRandomPic(ifs, options) { }
function zoom(factor) {
  bodyZoom = factor;
  if (Math.abs(bodyZoom - 1) < .2) bodyZoom = 1;
  document.body.style.transformOrigin = '0% 0%';
  document.body.style.transform = 'scale(' + bodyZoom + ')';
  localStorage.setItem('bodyZoom', bodyZoom);
}
function zoom_on_resize(referenceDivId) {
  if (!window.onresize) {
    window.onresize = () => {
      let newBrowserZoom = Math.round(window.devicePixelRatio * 100);
      if (isdef(browserZoom) && browserZoom != newBrowserZoom) { browserZoom = newBrowserZoom; return; }
      if (nundef(browserZoom) || browserZoom == newBrowserZoom) {
        let wNeeded = document.getElementById(referenceDivId).getBoundingClientRect().width;
        let wNeededReally = wNeeded / bodyZoom;
        let wHave = window.innerWidth;
        let zn = wHave / wNeeded;
        let znr = wHave / wNeededReally;
        if (Math.abs(znr - bodyZoom) > .01) zoom(znr);
      }
      browserZoom = newBrowserZoom;
    };
  }
}
function zoom_on_wheel_alt() {
  if (!window.onwheel) {
    window.addEventListener("wheel", ev => {
      if (!ev.altKey || ev.ctrlKey) return;
      ev.preventDefault();
      if (ev.deltaY > 0) { zoomOut(); } else if (ev.deltaY < 0) zoomIn();
    }, { passive: false });
  }
}
function zoomBy(x) { if (nundef(bodyZoom)) bodyZoom = 1; zoom(bodyZoom * x); }
function zoomIn() { zoomBy(1.5); }
function zoomOut() { zoomBy(.7); }
function zPicS(item, dParent, styles = {}) {
  let w = styles.w, h = styles.h, padding = styles.padding, hpadding = styles.hpadding, wpadding = styles.wpadding;
  if (isdef(styles.sz)) {
    if (nundef(w)) w = styles.sz;
    if (nundef(h)) h = styles.sz;
  }
  let stylesNew = jsCopy(styles);
  if (isdef(w)) {
    if (isdef(padding)) { w -= 2 * padding; }
    else if (isdef(wpadding)) { w -= 2 * wpadding; }
    stylesNew.w = w;
  }
  if (isdef(h)) {
    if (isdef(padding)) { h -= 2 * padding; }
    else if (isdef(hpadding)) { h -= 2 * hpadding; }
    stylesNew.h = h;
  }
  return _zPicS(item, dParent, stylesNew);
}
function zRepeatEachItem(items, repeat, shufflePositions = false) {
  let orig = items;
  let itRepeat = items;
  for (let i = 1; i < repeat; i++) { itRepeat = itRepeat.concat(orig.map(x => registeredItemCopy(x))); }
  if (shufflePositions) { shuffle(itRepeat); }
  let labelRepeat = {};
  let idx = 0;
  for (const item of itRepeat) {
    let iRepeat = labelRepeat[item.label];
    if (nundef(iRepeat)) iRepeat = 1; else iRepeat += 1;
    item.iRepeat = iRepeat;
    item.index = idx; idx += 1;
    labelRepeat[item.label] = iRepeat;
  }
  return itRepeat;
}
function zRepeatInColorEachItem(items, colorKeys) {
  let itColors = [];
  for (let i = 0; i < colorKeys.length; i++) {
    let newItems;
    if (i > 0) { newItems = jsCopy(items); newItems.map(x => registerAsNewItem(x)); }
    else newItems = items;
    itColors = itColors.concat(newItems);
  }
  for (let i = 0; i < colorKeys.length; i++) {
    let colorKey = colorKeys[i];
    let textShadowColor = ColorDict[colorKey].c;
    for (let j = 0; j < items.length; j++) {
      let index = i * items.length + j;
      let x = itColors[index];
      x.index = index;
      x.textShadowColor = textShadowColor;
      x.color = ColorDict[colorKey];
      x.colorKey = colorKey;
    }
  }
  return itColors;
}
function zText(text, dParent, textStyles, hText, vCenter = false) {
  let tSize = getSizeWithStyles(text, textStyles);
  let extra = 0, lines = 1;
  if (isdef(hText)) {
    extra = hText - tSize.h;
    if (textStyles.fz) lines = Math.floor(tSize.h / textStyles.fz);
  }
  let dText = isdef(text) ? mText(text, dParent, textStyles) : mDiv(dParent);
  if (extra > 0 && vCenter) {
    dText.style.paddingTop = (extra / 2) + 'px';
    dText.style.paddingBottom = (extra / 2) + 'px';
  }
  return { text: text, div: dText, extra: extra, lines: lines, h: tSize.h, w: tSize.w, fz: textStyles.fz };
}
